(function (global, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = global.document ? factory(global, true) : function (w) {
            if (!w.document) {
                throw new Error('jQuery requires a window with a document');
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
}(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
    var arr = [];
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var support = {};
    var document = window.document, version = '2.1.1', jQuery = function (selector, context) {
            return new jQuery.fn.init(selector, context);
        }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function (all, letter) {
            return letter.toUpperCase();
        };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: '',
        length: 0,
        toArray: function () {
            return slice.call(this);
        },
        get: function (num) {
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
        },
        pushStack: function (elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret;
        },
        each: function (callback, args) {
            return jQuery.each(this, callback, args);
        },
        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function () {
            return this.eq(0);
        },
        last: function () {
            return this.eq(-1);
        },
        eq: function (i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function () {
            return this.prevObject || this.constructor(null);
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === 'boolean') {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== 'object' && !jQuery.isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),
        isReady: true,
        error: function (msg) {
            throw new Error(msg);
        },
        noop: function () {
        },
        isFunction: function (obj) {
            return jQuery.type(obj) === 'function';
        },
        isArray: Array.isArray,
        isWindow: function (obj) {
            return obj != null && obj === obj.window;
        },
        isNumeric: function (obj) {
            return !jQuery.isArray(obj) && obj - parseFloat(obj) >= 0;
        },
        isPlainObject: function (obj) {
            if (jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            if (obj.constructor && !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                return false;
            }
            return true;
        },
        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        type: function (obj) {
            if (obj == null) {
                return obj + '';
            }
            return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
        },
        globalEval: function (code) {
            var script, indirect = eval;
            code = jQuery.trim(code);
            if (code) {
                if (code.indexOf('use strict') === 1) {
                    script = document.createElement('script');
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script);
                } else {
                    indirect(code);
                }
            }
        },
        camelCase: function (string) {
            return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
        },
        nodeName: function (elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function (obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                }
            } else {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                }
            }
            return obj;
        },
        trim: function (text) {
            return text == null ? '' : (text + '').replace(rtrim, '');
        },
        makeArray: function (arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function (elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function (first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (; j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function (elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function (elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            if (isArray) {
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function (fn, context) {
            var tmp, args, proxy;
            if (typeof context === 'string') {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function () {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: Date.now,
        support: support
    });
    jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
        class2type['[object ' + name + ']'] = name.toLowerCase();
    });
    function isArraylike(obj) {
        var length = obj.length, type = jQuery.type(obj);
        if (type === 'function' || jQuery.isWindow(obj)) {
            return false;
        }
        if (obj.nodeType === 1 && length) {
            return true;
        }
        return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
    }
    var Sizzle = function (window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                }
                return 0;
            }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function (elem) {
                var i = 0, len = this.length;
                for (; i < len; i++) {
                    if (this[i] === elem) {
                        return i;
                    }
                }
                return -1;
            }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', identifier = characterEncoding.replace('w', 'w#'), attributes = '\\[' + whitespace + '*(' + characterEncoding + ')(?:' + whitespace + '*([*^$|!~]?=)' + whitespace + '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + identifier + '))|)' + whitespace + '*\\]', pseudos = ':(' + characterEncoding + ')(?:\\((' + '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' + '((?:\\\\.|[^\\\\()[\\]]|' + attributes + ')*)|' + '.*' + ')\\)|)', rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
                'ID': new RegExp('^#(' + characterEncoding + ')'),
                'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
                'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
                'ATTR': new RegExp('^' + attributes),
                'PSEUDO': new RegExp('^' + pseudos),
                'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
                'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
            }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
                var high = '0x' + escaped - 65536;
                return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
            };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function (target, els) {
                    push_native.apply(target, slice.call(els));
                } : function (target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {
                    }
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                setDocument(context);
            }
            context = context || document;
            results = results || [];
            if (!selector || typeof selector !== 'string') {
                return results;
            }
            if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
                return [];
            }
            if (documentIsHTML && !seed) {
                if (match = rquickExpr.exec(selector)) {
                    if (m = match[1]) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            if (elem && elem.parentNode) {
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            } else {
                                return results;
                            }
                        } else {
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        }
                    } else if (match[2]) {
                        push.apply(results, context.getElementsByTagName(selector));
                        return results;
                    } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                        push.apply(results, context.getElementsByClassName(m));
                        return results;
                    }
                }
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    nid = old = expando;
                    newContext = context;
                    newSelector = nodeType === 9 && selector;
                    if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
                        groups = tokenize(selector);
                        if (old = context.getAttribute('id')) {
                            nid = old.replace(rescape, '\\$&');
                        } else {
                            context.setAttribute('id', nid);
                        }
                        nid = '[id=\'' + nid + '\'] ';
                        i = groups.length;
                        while (i--) {
                            groups[i] = nid + toSelector(groups[i]);
                        }
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        newSelector = groups.join(',');
                    }
                    if (newSelector) {
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {
                        } finally {
                            if (!old) {
                                context.removeAttribute('id');
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, '$1'), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + ' ') > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + ' '] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var div = document.createElement('div');
            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                div = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split('|'), i = attrs.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return name === 'input' && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === 'input' || name === 'button') && elem.type === type;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function (argument) {
                argument = +argument;
                return markFunction(function (seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== strundefined && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function (elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== 'HTML' : false;
        };
        setDocument = Sizzle.setDocument = function (node) {
            var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = doc.documentElement;
            documentIsHTML = !isXML(doc);
            if (parent && parent !== parent.top) {
                if (parent.addEventListener) {
                    parent.addEventListener('unload', function () {
                        setDocument();
                    }, false);
                } else if (parent.attachEvent) {
                    parent.attachEvent('onunload', function () {
                        setDocument();
                    });
                }
            }
            support.attributes = assert(function (div) {
                div.className = 'i';
                return !div.getAttribute('className');
            });
            support.getElementsByTagName = assert(function (div) {
                div.appendChild(doc.createComment(''));
                return !div.getElementsByTagName('*').length;
            });
            support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function (div) {
                div.innerHTML = '<div class=\'a\'></div><div class=\'a i\'></div>';
                div.firstChild.className = 'i';
                return div.getElementsByClassName('i').length === 2;
            });
            support.getById = assert(function (div) {
                docElem.appendChild(div).id = expando;
                return !doc.getElementsByName || !doc.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.find['ID'] = function (id, context) {
                    if (typeof context.getElementById !== strundefined && documentIsHTML) {
                        var m = context.getElementById(id);
                        return m && m.parentNode ? [m] : [];
                    }
                };
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        return elem.getAttribute('id') === attrId;
                    };
                };
            } else {
                delete Expr.find['ID'];
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode('id');
                        return node && node.value === attrId;
                    };
                };
            }
            Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
                if (typeof context.getElementsByTagName !== strundefined) {
                    return context.getElementsByTagName(tag);
                }
            } : function (tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === '*') {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
                if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(doc.querySelectorAll)) {
                assert(function (div) {
                    div.innerHTML = '<select msallowclip=\'\'><option selected=\'\'></option></select>';
                    if (div.querySelectorAll('[msallowclip^=\'\']').length) {
                        rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
                    }
                    if (!div.querySelectorAll('[selected]').length) {
                        rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                    }
                    if (!div.querySelectorAll(':checked').length) {
                        rbuggyQSA.push(':checked');
                    }
                });
                assert(function (div) {
                    var input = doc.createElement('input');
                    input.setAttribute('type', 'hidden');
                    div.appendChild(input).setAttribute('name', 'D');
                    if (div.querySelectorAll('[name=d]').length) {
                        rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
                    }
                    if (!div.querySelectorAll(':enabled').length) {
                        rbuggyQSA.push(':enabled', ':disabled');
                    }
                    div.querySelectorAll('*,:x');
                    rbuggyQSA.push(',.*:');
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function (div) {
                    support.disconnectedMatch = matches.call(div, 'div');
                    matches.call(div, '[s!=\'\']:x');
                    rbuggyMatches.push('!=', pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function (a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                if (!aup || !bup) {
                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return doc;
        };
        Sizzle.matches = function (expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function (elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, '=\'$1\']');
            if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {
                }
            }
            return Sizzle(expr, document, null, [elem]).length > 0;
        };
        Sizzle.contains = function (context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function (elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function (msg) {
            throw new Error('Syntax error, unrecognized expression: ' + msg);
        };
        Sizzle.uniqueSort = function (results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function (elem) {
            var node, ret = '', i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === 'string') {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                '>': {
                    dir: 'parentNode',
                    first: true
                },
                ' ': { dir: 'parentNode' },
                '+': {
                    dir: 'previousSibling',
                    first: true
                },
                '~': { dir: 'previousSibling' }
            },
            preFilter: {
                'ATTR': function (match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);
                    if (match[2] === '~=') {
                        match[3] = ' ' + match[3] + ' ';
                    }
                    return match.slice(0, 4);
                },
                'CHILD': function (match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === 'nth') {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                        match[5] = +(match[7] + match[8] || match[3] === 'odd');
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                'PSEUDO': function (match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr['CHILD'].test(match[0])) {
                        return null;
                    }
                    if (match[3]) {
                        match[2] = match[4] || match[5] || '';
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                'TAG': function (nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === '*' ? function () {
                        return true;
                    } : function (elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                'CLASS': function (className) {
                    var pattern = classCache[className + ' '];
                    return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
                        return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
                    });
                },
                'ATTR': function (name, operator, check) {
                    return function (elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === '!=';
                        }
                        if (!operator) {
                            return true;
                        }
                        result += '';
                        return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
                    };
                },
                'CHILD': function (type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
                    return first === 1 && last === 0 ? function (elem) {
                        return !!elem.parentNode;
                    } : function (elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === 'only' && !start && 'nextSibling';
                                }
                                return true;
                            }
                            start = [forward ? parent.firstChild : parent.lastChild];
                            if (forward && useCache) {
                                outerCache = parent[expando] || (parent[expando] = {});
                                cache = outerCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = cache[0] === dirruns && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        outerCache[type] = [
                                            dirruns,
                                            nodeIndex,
                                            diff
                                        ];
                                        break;
                                    }
                                }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                diff = cache[1];
                            } else {
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        if (useCache) {
                                            (node[expando] || (node[expando] = {}))[type] = [
                                                dirruns,
                                                diff
                                            ];
                                        }
                                        if (node === elem) {
                                            break;
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                'PSEUDO': function (pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [
                            pseudo,
                            pseudo,
                            '',
                            argument
                        ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf.call(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function (elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                'not': markFunction(function (selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
                    return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function (elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        return !results.pop();
                    };
                }),
                'has': markFunction(function (selector) {
                    return function (elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                'contains': markFunction(function (text) {
                    return function (elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                'lang': markFunction(function (lang) {
                    if (!ridentifier.test(lang || '')) {
                        Sizzle.error('unsupported lang: ' + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function (elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                'target': function (elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                'root': function (elem) {
                    return elem === docElem;
                },
                'focus': function (elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                'enabled': function (elem) {
                    return elem.disabled === false;
                },
                'disabled': function (elem) {
                    return elem.disabled === true;
                },
                'checked': function (elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
                },
                'selected': function (elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                'empty': function (elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                'parent': function (elem) {
                    return !Expr.pseudos['empty'](elem);
                },
                'header': function (elem) {
                    return rheader.test(elem.nodeName);
                },
                'input': function (elem) {
                    return rinputs.test(elem.nodeName);
                },
                'button': function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === 'input' && elem.type === 'button' || name === 'button';
                },
                'text': function (elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
                },
                'first': createPositionalPseudo(function () {
                    return [0];
                }),
                'last': createPositionalPseudo(function (matchIndexes, length) {
                    return [length - 1];
                }),
                'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument];
                }),
                'even': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 0;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'odd': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 1;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; --i >= 0;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; ++i < length;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos['nth'] = Expr.pseudos['eq'];
        for (i in {
                radio: true,
                checkbox: true,
                file: true,
                password: true,
                image: true
            }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
                submit: true,
                reset: true
            }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function (selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, ' ')
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = '';
            for (; i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
            return combinator.first ? function (elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            } : function (elem, context, xml) {
                var oldCache, outerCache, newCache = [
                        dirruns,
                        doneName
                    ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                outerCache[dir] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function (elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (; i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function (seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                    return elem === checkContext;
                }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
                    return indexOf.call(checkContext, elem) > -1;
                }, implicitRelative, true), matchers = [function (elem, context, xml) {
                        return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                    }];
            for (; i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
                    var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                    if (outermost) {
                        outermostContext = context !== document && context;
                    }
                    for (; i !== len && (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            j = 0;
                            while (matcher = elementMatchers[j++]) {
                                if (matcher(elem, context, xml)) {
                                    results.push(elem);
                                    break;
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique;
                            }
                        }
                        if (bySet) {
                            if (elem = !matcher && elem) {
                                matchedCount--;
                            }
                            if (seed) {
                                unmatched.push(elem);
                            }
                        }
                    }
                    matchedCount += i;
                    if (bySet && i !== matchedCount) {
                        j = 0;
                        while (matcher = setMatchers[j++]) {
                            matcher(unmatched, setMatched, context, xml);
                        }
                        if (seed) {
                            if (matchedCount > 0) {
                                while (i--) {
                                    if (!(unmatched[i] || setMatched[i])) {
                                        setMatched[i] = pop.call(results);
                                    }
                                }
                            }
                            setMatched = condense(setMatched);
                        }
                        push.apply(results, setMatched);
                        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                            Sizzle.uniqueSort(results);
                        }
                    }
                    if (outermost) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup;
                    }
                    return unmatched;
                };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function (selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
            if (!cached) {
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                cached.selector = selector;
            }
            return cached;
        };
        select = Sizzle.select = function (selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === 'function' && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;
                    } else if (compiled) {
                        context = context.parentNode;
                    }
                    selector = selector.slice(tokens.shift().value.length);
                }
                i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function (div1) {
            return div1.compareDocumentPosition(document.createElement('div')) & 1;
        });
        if (!assert(function (div) {
                div.innerHTML = '<a href=\'#\'></a>';
                return div.firstChild.getAttribute('href') === '#';
            })) {
            addHandle('type|href|height|width', function (elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function (div) {
                div.innerHTML = '<input/>';
                div.firstChild.setAttribute('value', '');
                return div.firstChild.getAttribute('value') === '';
            })) {
            addHandle('value', function (elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function (div) {
                return div.getAttribute('disabled') == null;
            })) {
            addHandle(booleans, function (elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier === 'string') {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function (elem) {
            return indexOf.call(qualifier, elem) >= 0 !== not;
        });
    }
    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ':not(' + expr + ')';
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function (selector) {
            var i, len = this.length, ret = [], self = this;
            if (typeof selector !== 'string') {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + ' ' + selector : selector;
            return ret;
        },
        filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function (selector) {
            return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function (selector, context) {
            var match, elem;
            if (!selector) {
                return this;
            }
            if (typeof selector === 'string') {
                if (selector[0] === '<' && selector[selector.length - 1] === '>' && selector.length >= 3) {
                    match = [
                        null,
                        selector,
                        null
                    ];
                } else {
                    match = rquickExpr.exec(selector);
                }
                if (match && (match[1] || !context)) {
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                if (jQuery.isFunction(this[match])) {
                                    this[match](context[match]);
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }
                        return this;
                    } else {
                        elem = document.getElementById(match[2]);
                        if (elem && elem.parentNode) {
                            this.length = 1;
                            this[0] = elem;
                        }
                        this.context = document;
                        this.selector = selector;
                        return this;
                    }
                } else if (!context || context.jquery) {
                    return (context || rootjQuery).find(selector);
                } else {
                    return this.constructor(context).find(selector);
                }
            } else if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            } else if (jQuery.isFunction(selector)) {
                return typeof rootjQuery.ready !== 'undefined' ? rootjQuery.ready(selector) : selector(jQuery);
            }
            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context;
            }
            return jQuery.makeArray(selector, this);
        };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };
    jQuery.extend({
        dir: function (elem, dir, until) {
            var matched = [], truncate = until !== undefined;
            while ((elem = elem[dir]) && elem.nodeType !== 9) {
                if (elem.nodeType === 1) {
                    if (truncate && jQuery(elem).is(until)) {
                        break;
                    }
                    matched.push(elem);
                }
            }
            return matched;
        },
        sibling: function (n, elem) {
            var matched = [];
            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    matched.push(n);
                }
            }
            return matched;
        }
    });
    jQuery.fn.extend({
        has: function (target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function () {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function (selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
            for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break;
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },
        index: function (elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === 'string') {
                return indexOf.call(jQuery(elem), this[0]);
            }
            return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function (selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function (selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {
        }
        return cur;
    }
    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return jQuery.dir(elem, 'parentNode');
        },
        parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, 'parentNode', until);
        },
        next: function (elem) {
            return sibling(elem, 'nextSibling');
        },
        prev: function (elem) {
            return sibling(elem, 'previousSibling');
        },
        nextAll: function (elem) {
            return jQuery.dir(elem, 'nextSibling');
        },
        prevAll: function (elem) {
            return jQuery.dir(elem, 'previousSibling');
        },
        nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, 'nextSibling', until);
        },
        prevUntil: function (elem, i, until) {
            return jQuery.dir(elem, 'previousSibling', until);
        },
        siblings: function (elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function (elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function (elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== 'Until') {
                selector = until;
            }
            if (selector && typeof selector === 'string') {
                matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    jQuery.unique(matched);
                }
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }
            return this.pushStack(matched);
        };
    });
    var rnotwhite = /\S+/g;
    var optionsCache = {};
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function (options) {
        options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
        var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function (data) {
                memory = options.memory && data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for (; list && firingIndex < firingLength; firingIndex++) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false;
                        break;
                    }
                }
                firing = false;
                if (list) {
                    if (stack) {
                        if (stack.length) {
                            fire(stack.shift());
                        }
                    } else if (memory) {
                        list = [];
                    } else {
                        self.disable();
                    }
                }
            }, self = {
                add: function () {
                    if (list) {
                        var start = list.length;
                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                var type = jQuery.type(arg);
                                if (type === 'function') {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && type !== 'string') {
                                    add(arg);
                                }
                            });
                        }(arguments));
                        if (firing) {
                            firingLength = list.length;
                        } else if (memory) {
                            firingStart = start;
                            fire(memory);
                        }
                    }
                    return this;
                },
                remove: function () {
                    if (list) {
                        jQuery.each(arguments, function (_, arg) {
                            var index;
                            while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1);
                                if (firing) {
                                    if (index <= firingLength) {
                                        firingLength--;
                                    }
                                    if (index <= firingIndex) {
                                        firingIndex--;
                                    }
                                }
                            }
                        });
                    }
                    return this;
                },
                has: function (fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
                },
                empty: function () {
                    list = [];
                    firingLength = 0;
                    return this;
                },
                disable: function () {
                    list = stack = memory = undefined;
                    return this;
                },
                disabled: function () {
                    return !list;
                },
                lock: function () {
                    stack = undefined;
                    if (!memory) {
                        self.disable();
                    }
                    return this;
                },
                locked: function () {
                    return !stack;
                },
                fireWith: function (context, args) {
                    if (list && (!fired || stack)) {
                        args = args || [];
                        args = [
                            context,
                            args.slice ? args.slice() : args
                        ];
                        if (firing) {
                            stack.push(args);
                        } else {
                            fire(args);
                        }
                    }
                    return this;
                },
                fire: function () {
                    self.fireWith(this, arguments);
                    return this;
                },
                fired: function () {
                    return !!fired;
                }
            };
        return self;
    };
    jQuery.extend({
        Deferred: function (func) {
            var tuples = [
                    [
                        'resolve',
                        'done',
                        jQuery.Callbacks('once memory'),
                        'resolved'
                    ],
                    [
                        'reject',
                        'fail',
                        jQuery.Callbacks('once memory'),
                        'rejected'
                    ],
                    [
                        'notify',
                        'progress',
                        jQuery.Callbacks('memory')
                    ]
                ], state = 'pending', promise = {
                    state: function () {
                        return state;
                    },
                    always: function () {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    then: function () {
                        var fns = arguments;
                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (i, tuple) {
                                var fn = jQuery.isFunction(fns[i]) && fns[i];
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                    } else {
                                        newDefer[tuple[0] + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                }, deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function () {
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + 'With'] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function (subordinate) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function (i, contexts, values) {
                    return function (value) {
                        contexts[i] = this;
                        values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (values === progressValues) {
                            deferred.notifyWith(contexts, values);
                        } else if (!--remaining) {
                            deferred.resolveWith(contexts, values);
                        }
                    };
                }, progressValues, progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    var readyList;
    jQuery.fn.ready = function (fn) {
        jQuery.ready.promise().done(fn);
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function (hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        ready: function (wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [jQuery]);
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler('ready');
                jQuery(document).off('ready');
            }
        }
    });
    function completed() {
        document.removeEventListener('DOMContentLoaded', completed, false);
        window.removeEventListener('load', completed, false);
        jQuery.ready();
    }
    jQuery.ready.promise = function (obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === 'complete') {
                setTimeout(jQuery.ready);
            } else {
                document.addEventListener('DOMContentLoaded', completed, false);
                window.addEventListener('load', completed, false);
            }
        }
        return readyList.promise(obj);
    };
    jQuery.ready.promise();
    var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (jQuery.type(key) === 'object') {
            chainable = true;
            for (i in key) {
                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (; i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    };
    jQuery.acceptData = function (owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        Object.defineProperty(this.cache = {}, 0, {
            get: function () {
                return {};
            }
        });
        this.expando = jQuery.expando + Math.random();
    }
    Data.uid = 1;
    Data.accepts = jQuery.acceptData;
    Data.prototype = {
        key: function (owner) {
            if (!Data.accepts(owner)) {
                return 0;
            }
            var descriptor = {}, unlock = owner[this.expando];
            if (!unlock) {
                unlock = Data.uid++;
                try {
                    descriptor[this.expando] = { value: unlock };
                    Object.defineProperties(owner, descriptor);
                } catch (e) {
                    descriptor[this.expando] = unlock;
                    jQuery.extend(owner, descriptor);
                }
            }
            if (!this.cache[unlock]) {
                this.cache[unlock] = {};
            }
            return unlock;
        },
        set: function (owner, data, value) {
            var prop, unlock = this.key(owner), cache = this.cache[unlock];
            if (typeof data === 'string') {
                cache[data] = value;
            } else {
                if (jQuery.isEmptyObject(cache)) {
                    jQuery.extend(this.cache[unlock], data);
                } else {
                    for (prop in data) {
                        cache[prop] = data[prop];
                    }
                }
            }
            return cache;
        },
        get: function (owner, key) {
            var cache = this.cache[this.key(owner)];
            return key === undefined ? cache : cache[key];
        },
        access: function (owner, key, value) {
            var stored;
            if (key === undefined || key && typeof key === 'string' && value === undefined) {
                stored = this.get(owner, key);
                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key;
        },
        remove: function (owner, key) {
            var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
            if (key === undefined) {
                this.cache[unlock] = {};
            } else {
                if (jQuery.isArray(key)) {
                    name = key.concat(key.map(jQuery.camelCase));
                } else {
                    camel = jQuery.camelCase(key);
                    if (key in cache) {
                        name = [
                            key,
                            camel
                        ];
                    } else {
                        name = camel;
                        name = name in cache ? [name] : name.match(rnotwhite) || [];
                    }
                }
                i = name.length;
                while (i--) {
                    delete cache[name[i]];
                }
            }
        },
        hasData: function (owner) {
            return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
        },
        discard: function (owner) {
            if (owner[this.expando]) {
                delete this.cache[owner[this.expando]];
            }
        }
    };
    var data_priv = new Data();
    var data_user = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
            name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === 'string') {
                try {
                    data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {
                }
                data_user.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    jQuery.extend({
        hasData: function (elem) {
            return data_user.hasData(elem) || data_priv.hasData(elem);
        },
        data: function (elem, name, data) {
            return data_user.access(elem, name, data);
        },
        removeData: function (elem, name) {
            data_user.remove(elem, name);
        },
        _data: function (elem, name, data) {
            return data_priv.access(elem, name, data);
        },
        _removeData: function (elem, name) {
            data_priv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function (key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = data_user.get(elem);
                    if (elem.nodeType === 1 && !data_priv.get(elem, 'hasDataAttrs')) {
                        i = attrs.length;
                        while (i--) {
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf('data-') === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        data_priv.set(elem, 'hasDataAttrs', true);
                    }
                }
                return data;
            }
            if (typeof key === 'object') {
                return this.each(function () {
                    data_user.set(this, key);
                });
            }
            return access(this, function (value) {
                var data, camelKey = jQuery.camelCase(key);
                if (elem && value === undefined) {
                    data = data_user.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }
                    data = data_user.get(elem, camelKey);
                    if (data !== undefined) {
                        return data;
                    }
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) {
                        return data;
                    }
                    return;
                }
                this.each(function () {
                    var data = data_user.get(this, camelKey);
                    data_user.set(this, camelKey, value);
                    if (key.indexOf('-') !== -1 && data !== undefined) {
                        data_user.set(this, key, value);
                    }
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function (key) {
            return this.each(function () {
                data_user.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;
            if (elem) {
                type = (type || 'fx') + 'queue';
                queue = data_priv.get(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = data_priv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function (elem, type) {
            type = type || 'fx';
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                    jQuery.dequeue(elem, type);
                };
            if (fn === 'inprogress') {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === 'fx') {
                    queue.unshift('inprogress');
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function (elem, type) {
            var key = type + 'queueHooks';
            return data_priv.get(elem, key) || data_priv.access(elem, key, {
                empty: jQuery.Callbacks('once memory').add(function () {
                    data_priv.remove(elem, [
                        type + 'queue',
                        key
                    ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;
            if (typeof type !== 'string') {
                data = type;
                type = 'fx';
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function () {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === 'fx' && queue[0] !== 'inprogress') {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || 'fx', []);
        },
        promise: function (type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                    if (!--count) {
                        defer.resolveWith(elements, [elements]);
                    }
                };
            if (typeof type !== 'string') {
                obj = type;
                type = undefined;
            }
            type = type || 'fx';
            while (i--) {
                tmp = data_priv.get(elements[i], type + 'queueHooks');
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var cssExpand = [
        'Top',
        'Right',
        'Bottom',
        'Left'
    ];
    var isHidden = function (elem, el) {
        elem = el || elem;
        return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
    };
    var rcheckableType = /^(?:checkbox|radio)$/i;
    (function () {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement('div')), input = document.createElement('input');
        input.setAttribute('type', 'radio');
        input.setAttribute('checked', 'checked');
        input.setAttribute('name', 't');
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = '<textarea>x</textarea>';
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    }());
    var strundefined = typeof undefined;
    support.focusinBubbles = 'onfocusin' in window;
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {
        }
    }
    jQuery.event = {
        global: {},
        add: function (elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {
                    return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }
            types = (types || '').match(rnotwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join('.')
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
        },
        remove: function (elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || '').match(rnotwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                data_priv.remove(elem, 'events');
            }
        },
        trigger: function (event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = hasOwn.call(event, 'type') ? event.type : event, namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf('.') >= 0) {
                namespaces = type.split('.');
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(':') < 0 && 'on' + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join('.');
            event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [event] : jQuery.makeArray(data, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (data_priv.get(cur, 'events') || {})[event.type] && data_priv.get(cur, 'handle');
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        dispatch: function (event) {
            event = jQuery.event.fix(event);
            var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (data_priv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function (event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
                for (; cur !== this; cur = cur.parentNode || this) {
                    if (cur.disabled !== true || event.type !== 'click') {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + ' ';
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),
        fixHooks: {},
        keyHooks: {
            props: 'char charCode key keyCode'.split(' '),
            filter: function (event, original) {
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: 'button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
            filter: function (event, original) {
                var eventDoc, doc, body, button = original.button;
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }
                return event;
            }
        },
        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }
            if (!event.target) {
                event.target = document;
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
            load: { noBubble: true },
            focus: {
                trigger: function () {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: 'focusin'
            },
            blur: {
                trigger: function () {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: 'focusout'
            },
            click: {
                trigger: function () {
                    if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {
                        this.click();
                        return false;
                    }
                },
                _default: function (event) {
                    return jQuery.nodeName(event.target, 'a');
                }
            },
            beforeunload: {
                postDispatch: function (event) {
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },
        simulate: function (type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true,
                originalEvent: {}
            });
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };
    jQuery.removeEvent = function (elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
        }
    };
    jQuery.Event = function (src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function () {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && e.preventDefault) {
                e.preventDefault();
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && e.stopPropagation) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && e.stopImmediatePropagation) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    jQuery.each({
        mouseenter: 'mouseover',
        mouseleave: 'mouseout',
        pointerenter: 'pointerover',
        pointerleave: 'pointerout'
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function (event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    if (!support.focusinBubbles) {
        jQuery.each({
            focus: 'focusin',
            blur: 'focusout'
        }, function (orig, fix) {
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };
            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    data_priv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function () {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        data_priv.remove(doc, fix);
                    } else {
                        data_priv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    jQuery.fn.extend({
        on: function (types, selector, data, fn, one) {
            var origFn, type;
            if (typeof types === 'object') {
                if (typeof selector !== 'string') {
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }
            if (data == null && fn == null) {
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === 'string') {
                    fn = data;
                    data = undefined;
                } else {
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }
            if (one === 1) {
                origFn = fn;
                fn = function (event) {
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function () {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function (types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === 'object') {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === 'function') {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        },
        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
            option: [
                1,
                '<select multiple=\'multiple\'>',
                '</select>'
            ],
            thead: [
                1,
                '<table>',
                '</table>'
            ],
            col: [
                2,
                '<table><colgroup>',
                '</colgroup></table>'
            ],
            tr: [
                2,
                '<table><tbody>',
                '</tbody></table>'
            ],
            td: [
                3,
                '<table><tbody><tr>',
                '</tr></tbody></table>'
            ],
            _default: [
                0,
                '',
                ''
            ]
        };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
    }
    function disableScript(elem) {
        elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute('type');
        }
        return elem;
    }
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for (; i < l; i++) {
            data_priv.set(elems[i], 'globalEval', !refElements || data_priv.get(refElements[i], 'globalEval'));
        }
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
            return;
        }
        if (data_priv.hasData(src)) {
            pdataOld = data_priv.access(src);
            pdataCur = data_priv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }
        if (data_user.hasData(src)) {
            udataOld = data_user.access(src);
            udataCur = jQuery.extend({}, udataOld);
            data_user.set(dest, udataCur);
        }
    }
    function getAll(context, tag) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || '*') : context.querySelectorAll ? context.querySelectorAll(tag || '*') : [];
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === 'input' && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
        } else if (nodeName === 'input' || nodeName === 'textarea') {
            dest.defaultValue = src.defaultValue;
        }
    }
    jQuery.extend({
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, 'script');
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
            }
            return clone;
        },
        buildFragment: function (elems, context, scripts, selection) {
            var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
            for (; i < l; i++) {
                elem = elems[i];
                if (elem || elem === 0) {
                    if (jQuery.type(elem) === 'object') {
                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));
                    } else {
                        tmp = tmp || fragment.appendChild(context.createElement('div'));
                        tag = (rtagName.exec(elem) || [
                            '',
                            ''
                        ])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }
                        jQuery.merge(nodes, tmp.childNodes);
                        tmp = fragment.firstChild;
                        tmp.textContent = '';
                    }
                }
            }
            fragment.textContent = '';
            i = 0;
            while (elem = nodes[i++]) {
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue;
                }
                contains = jQuery.contains(elem.ownerDocument, elem);
                tmp = getAll(fragment.appendChild(elem), 'script');
                if (contains) {
                    setGlobalEval(tmp);
                }
                if (scripts) {
                    j = 0;
                    while (elem = tmp[j++]) {
                        if (rscriptType.test(elem.type || '')) {
                            scripts.push(elem);
                        }
                    }
                }
            }
            return fragment;
        },
        cleanData: function (elems) {
            var data, elem, type, key, special = jQuery.event.special, i = 0;
            for (; (elem = elems[i]) !== undefined; i++) {
                if (jQuery.acceptData(elem)) {
                    key = elem[data_priv.expando];
                    if (key && (data = data_priv.cache[key])) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        if (data_priv.cache[key]) {
                            delete data_priv.cache[key];
                        }
                    }
                }
                delete data_user.cache[elem[data_user.expando]];
            }
        }
    });
    jQuery.fn.extend({
        text: function (value) {
            return access(this, function (value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function () {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },
        append: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        remove: function (selector, keepData) {
            var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
            for (; (elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem));
                }
                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, 'script'));
                    }
                    elem.parentNode.removeChild(elem);
                }
            }
            return this;
        },
        empty: function () {
            var elem, i = 0;
            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = '';
                }
            }
            return this;
        },
        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }
                if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
                        '',
                        ''
                    ])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, '<$1></$2>');
                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {
                    }
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function () {
            var arg = arguments[0];
            this.domManip(arguments, function (elem) {
                arg = this.parentNode;
                jQuery.cleanData(getAll(this));
                if (arg) {
                    arg.replaceChild(elem, this);
                }
            });
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },
        detach: function (selector) {
            return this.remove(selector, true);
        },
        domManip: function (args, callback) {
            args = concat.apply([], args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            if (isFunction || l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value)) {
                return this.each(function (index) {
                    var self = set.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    self.domManip(args, callback);
                });
            }
            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }
                if (first) {
                    scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                    hasScripts = scripts.length;
                    for (; i < l; i++) {
                        node = fragment;
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);
                            if (hasScripts) {
                                jQuery.merge(scripts, getAll(node, 'script'));
                            }
                        }
                        callback.call(this[i], node, i);
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;
                        jQuery.map(scripts, restoreScript);
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || '') && !data_priv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                                if (node.src) {
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src);
                                    }
                                } else {
                                    jQuery.globalEval(node.textContent.replace(rcleanScript, ''));
                                }
                            }
                        }
                    }
                }
            }
            return this;
        }
    });
    jQuery.each({
        appendTo: 'append',
        prependTo: 'prepend',
        insertBefore: 'before',
        insertAfter: 'after',
        replaceAll: 'replaceWith'
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {};
    function actualDisplay(name, doc) {
        var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], 'display');
        elem.detach();
        return display;
    }
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            if (display === 'none' || !display) {
                iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>')).appendTo(doc.documentElement);
                doc = iframe[0].contentDocument;
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }
            elemdisplay[nodeName] = display;
        }
        return display;
    }
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');
    var getStyles = function (elem) {
        return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    };
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
        }
        if (computed) {
            if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name);
            }
            if (rnumnonpx.test(ret) && rmargin.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? ret + '' : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function () {
                if (conditionFn()) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    (function () {
        var pixelPositionVal, boxSizingReliableVal, docElem = document.documentElement, container = document.createElement('div'), div = document.createElement('div');
        if (!div.style) {
            return;
        }
        div.style.backgroundClip = 'content-box';
        div.cloneNode(true).style.backgroundClip = '';
        support.clearCloneStyle = div.style.backgroundClip === 'content-box';
        container.style.cssText = 'border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;' + 'position:absolute';
        container.appendChild(div);
        function computePixelPositionAndBoxSizingReliable() {
            div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;' + 'box-sizing:border-box;display:block;margin-top:1%;top:1%;' + 'border:1px;padding:1px;width:4px;position:absolute';
            div.innerHTML = '';
            docElem.appendChild(container);
            var divStyle = window.getComputedStyle(div, null);
            pixelPositionVal = divStyle.top !== '1%';
            boxSizingReliableVal = divStyle.width === '4px';
            docElem.removeChild(container);
        }
        if (window.getComputedStyle) {
            jQuery.extend(support, {
                pixelPosition: function () {
                    computePixelPositionAndBoxSizingReliable();
                    return pixelPositionVal;
                },
                boxSizingReliable: function () {
                    if (boxSizingReliableVal == null) {
                        computePixelPositionAndBoxSizingReliable();
                    }
                    return boxSizingReliableVal;
                },
                reliableMarginRight: function () {
                    var ret, marginDiv = div.appendChild(document.createElement('div'));
                    marginDiv.style.cssText = div.style.cssText = '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;' + 'box-sizing:content-box;display:block;margin:0;border:0;padding:0';
                    marginDiv.style.marginRight = marginDiv.style.width = '0';
                    div.style.width = '1px';
                    docElem.appendChild(container);
                    ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
                    docElem.removeChild(container);
                    return ret;
                }
            });
        }
    }());
    jQuery.swap = function (elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp('^(' + pnum + ')(.*)$', 'i'), rrelNum = new RegExp('^([+-])=(' + pnum + ')', 'i'), cssShow = {
            position: 'absolute',
            visibility: 'hidden',
            display: 'block'
        }, cssNormalTransform = {
            letterSpacing: '0',
            fontWeight: '400'
        }, cssPrefixes = [
            'Webkit',
            'O',
            'Moz',
            'ms'
        ];
    function vendorPropName(style, name) {
        if (name in style) {
            return name;
        }
        var capName = name[0].toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }
        return origName;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
        for (; i < 4; i += 2) {
            if (extra === 'margin') {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                if (extra === 'content') {
                    val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                }
                if (extra !== 'margin') {
                    val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            } else {
                val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                if (extra !== 'padding') {
                    val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
    }
    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length;
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = data_priv.get(elem, 'olddisplay');
            display = elem.style.display;
            if (show) {
                if (!values[index] && display === 'none') {
                    elem.style.display = '';
                }
                if (elem.style.display === '' && isHidden(elem)) {
                    values[index] = data_priv.access(elem, 'olddisplay', defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);
                if (display !== 'none' || !hidden) {
                    data_priv.set(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
                }
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === 'none' || elem.style.display === '') {
                elem.style.display = show ? values[index] || '' : 'none';
            }
        }
        return elements;
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, 'opacity');
                        return ret === '' ? '1' : ret;
                    }
                }
            }
        },
        cssNumber: {
            'columnCount': true,
            'fillOpacity': true,
            'flexGrow': true,
            'flexShrink': true,
            'fontWeight': true,
            'lineHeight': true,
            'opacity': true,
            'order': true,
            'orphans': true,
            'widows': true,
            'zIndex': true,
            'zoom': true
        },
        cssProps: { 'float': 'cssFloat' },
        style: function (elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === 'string' && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    type = 'number';
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === 'number' && !jQuery.cssNumber[origName]) {
                    value += 'px';
                }
                if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                    style[name] = 'inherit';
                }
                if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value;
                }
            } else {
                if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function (elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && 'get' in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === 'normal' && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === '' || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([
        'height',
        'width'
    ], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                if (computed) {
                    return rdisplayswap.test(jQuery.css(elem, 'display')) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function () {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function (elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
            }
        };
    });
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
        if (computed) {
            return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [
                elem,
                'marginRight'
            ]);
        }
    });
    jQuery.each({
        margin: '',
        padding: '',
        border: 'Width'
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state) {
            if (typeof state === 'boolean') {
                return state ? this.show() : this.hide();
            }
            return this.each(function () {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || 'swing';
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;
                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, '');
                return !result || result === 'auto' ? 0 : result;
            },
            set: function (tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        }
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
            '*': [function (prop, value) {
                    var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
                    if (start && start[3] !== unit) {
                        unit = unit || start[3];
                        parts = parts || [];
                        start = +target || 1;
                        do {
                            scale = scale || '.5';
                            start = start / scale;
                            jQuery.style(tween.elem, prop, start + unit);
                        } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                    }
                    if (parts) {
                        start = tween.start = +start || +target || 0;
                        tween.unit = unit;
                        tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
                    }
                    return tween;
                }]
        };
    function createFxNow() {
        setTimeout(function () {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = { height: type };
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs['margin' + which] = attrs['padding' + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
        for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, 'fxshow');
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, 'fx');
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function () {
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, 'fx').length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
            opts.overflow = [
                style.overflow,
                style.overflowX,
                style.overflowY
            ];
            display = jQuery.css(elem, 'display');
            checkDisplay = display === 'none' ? data_priv.get(elem, 'olddisplay') || defaultDisplay(elem.nodeName) : display;
            if (checkDisplay === 'inline' && jQuery.css(elem, 'float') === 'none') {
                style.display = 'inline-block';
            }
        }
        if (opts.overflow) {
            style.overflow = 'hidden';
            anim.always(function () {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === 'toggle';
                if (value === (hidden ? 'hide' : 'show')) {
                    if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            } else {
                display = undefined;
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ('hidden' in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = data_priv.access(elem, 'fxshow', {});
            }
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function () {
                    jQuery(elem).hide();
                });
            }
            anim.done(function () {
                var prop;
                data_priv.remove(elem, 'fxshow');
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
                    }
                }
            }
        } else if ((display === 'none' ? defaultDisplay(elem.nodeName) : display) === 'inline') {
            style.display = display;
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && 'expand' in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
                delete tick.elem;
            }), tick = function () {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }
                deferred.notifyWith(elem, [
                    animation,
                    percent,
                    remaining
                ]);
                if (percent < 1 && length) {
                    return remaining;
                } else {
                    deferred.resolveWith(elem, [animation]);
                    return false;
                }
            }, animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, { specialEasing: {} }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function (gotoEnd) {
                    var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }
                    if (gotoEnd) {
                        deferred.resolveWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    } else {
                        deferred.rejectWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    }
                    return this;
                }
            }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function (props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ['*'];
            } else {
                props = props.split(' ');
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },
        prefilter: function (callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });
    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
            opt.queue = 'fx';
        }
        opt.old = opt.complete;
        opt.complete = function () {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {
            return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                    var anim = Animation(this, jQuery.extend({}, prop), optall);
                    if (empty || data_priv.get(this, 'finish')) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== 'string') {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || 'fx', []);
            }
            return this.each(function () {
                var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = data_priv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function (type) {
            if (type !== false) {
                type = type || 'fx';
            }
            return this.each(function () {
                var index, data = data_priv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([
        'toggle',
        'show',
        'hide'
    ], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx('show'),
        slideUp: genFx('hide'),
        slideToggle: genFx('toggle'),
        fadeIn: { opacity: 'show' },
        fadeOut: { opacity: 'hide' },
        fadeToggle: { opacity: 'toggle' }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = jQuery.now();
        for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function () {
        if (!timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function () {
        clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || 'fx';
        return this.queue(type, function (next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function () {
                clearTimeout(timeout);
            };
        });
    };
    (function () {
        var input = document.createElement('input'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
        input.type = 'checkbox';
        support.checkOn = input.value !== '';
        support.optSelected = opt.selected;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement('input');
        input.value = 't';
        input.type = 'radio';
        support.radioValue = input.value === 't';
    }());
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function (elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === strundefined) {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                } else {
                    elem.setAttribute(name, value + '');
                    return value;
                }
            } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            } else {
                ret = jQuery.find.attr(elem, name);
                return ret == null ? undefined : ret;
            }
        },
        removeAttr: function (elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    if (jQuery.expr.match.bool.test(name)) {
                        elem[propName] = false;
                    }
                    elem.removeAttribute(name);
                }
            }
        },
        attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
                        var val = elem.value;
                        elem.setAttribute('type', value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        }
    });
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function (elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i;
    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function (name) {
            return this.each(function () {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        propFix: {
            'for': 'htmlFor',
            'class': 'className'
        },
        prop: function (elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
            } else {
                return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
            }
        },
        propHooks: {
            tabIndex: {
                get: function (elem) {
                    return elem.hasAttribute('tabindex') || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
                }
            }
        }
    });
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            }
        };
    }
    jQuery.each([
        'tabIndex',
        'readOnly',
        'maxLength',
        'cellSpacing',
        'cellPadding',
        'rowSpan',
        'colSpan',
        'useMap',
        'frameBorder',
        'contentEditable'
    ], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    var rclass = /[\t\r\n\f]/g;
    jQuery.fn.extend({
        addClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = typeof value === 'string' && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || '').match(rnotwhite) || [];
                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                cur += clazz + ' ';
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = arguments.length === 0 || typeof value === 'string' && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || '').match(rnotwhite) || [];
                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                                cur = cur.replace(' ' + clazz + ' ', ' ');
                            }
                        }
                        finalValue = value ? jQuery.trim(cur) : '';
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function (value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === 'boolean' && type === 'string') {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }
            return this.each(function () {
                if (type === 'string') {
                    var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || [];
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (type === strundefined || type === 'boolean') {
                    if (this.className) {
                        data_priv.set(this, '__className__', this.className);
                    }
                    this.className = this.className || value === false ? '' : data_priv.get(this, '__className__') || '';
                }
            });
        },
        hasClass: function (selector) {
            var className = ' ' + selector + ' ', i = 0, l = this.length;
            for (; i < l; i++) {
                if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
                    return true;
                }
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function (value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function (i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = '';
                } else if (typeof val === 'number') {
                    val += '';
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? '' : value + '';
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    var val = jQuery.find.attr(elem, 'value');
                    return val != null ? val : jQuery.trim(jQuery.text(elem));
                }
            },
            select: {
                get: function (elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                    for (; i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function (elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(option.value, values) >= 0) {
                            optionSet = true;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });
    jQuery.each([
        'radio',
        'checkbox'
    ], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute('value') === null ? 'on' : elem.value;
            };
        }
    });
    jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
        jQuery.fn[name] = function (data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },
        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
        }
    });
    var nonce = jQuery.now();
    var rquery = /\?/;
    jQuery.parseJSON = function (data) {
        return JSON.parse(data + '');
    };
    jQuery.parseXML = function (data) {
        var xml, tmp;
        if (!data || typeof data !== 'string') {
            return null;
        }
        try {
            tmp = new DOMParser();
            xml = tmp.parseFromString(data, 'text/xml');
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName('parsererror').length) {
            jQuery.error('Invalid XML: ' + data);
        }
        return xml;
    };
    var ajaxLocParts, ajaxLocation, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = '*/'.concat('*');
    try {
        ajaxLocation = location.href;
    } catch (e) {
        ajaxLocation = document.createElement('a');
        ajaxLocation.href = '';
        ajaxLocation = ajaxLocation.href;
    }
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
    function addToPrefiltersOrTransports(structure) {
        return function (dataTypeExpression, func) {
            if (typeof dataTypeExpression !== 'string') {
                func = dataTypeExpression;
                dataTypeExpression = '*';
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType[0] === '+') {
                        dataType = dataType.slice(1) || '*';
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === '*') {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === '*') {
                    current = prev;
                } else if (prev !== '*' && prev !== current) {
                    conv = converters[prev + ' ' + current] || converters['* ' + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(' ');
                            if (tmp[1] === current) {
                                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s['throws']) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: 'parsererror',
                                    error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: 'success',
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ajaxLocation,
            type: 'GET',
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
            accepts: {
                '*': allTypes,
                text: 'text/plain',
                html: 'text/html',
                xml: 'application/xml, text/xml',
                json: 'application/json, text/javascript'
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: 'responseXML',
                text: 'responseText',
                json: 'responseJSON'
            },
            converters: {
                '* text': String,
                'text html': true,
                'text json': jQuery.parseJSON,
                'text xml': jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function (target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function (url, options) {
            if (typeof url === 'object') {
                options = url;
                url = undefined;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = 'canceled', jqXHR = {
                    readyState: 0,
                    getResponseHeader: function (key) {
                        var match;
                        if (state === 2) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while (match = rheaders.exec(responseHeadersString)) {
                                    responseHeaders[match[1].toLowerCase()] = match[2];
                                }
                            }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match == null ? null : match;
                    },
                    getAllResponseHeaders: function () {
                        return state === 2 ? responseHeadersString : null;
                    },
                    setRequestHeader: function (name, value) {
                        var lname = name.toLowerCase();
                        if (!state) {
                            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },
                    overrideMimeType: function (type) {
                        if (!state) {
                            s.mimeType = type;
                        }
                        return this;
                    },
                    statusCode: function (map) {
                        var code;
                        if (map) {
                            if (state < 2) {
                                for (code in map) {
                                    statusCode[code] = [
                                        statusCode[code],
                                        map[code]
                                    ];
                                }
                            } else {
                                jqXHR.always(map[jqXHR.status]);
                            }
                        }
                        return this;
                    },
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(rnotwhite) || [''];
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
            }
            if (s.data && s.processData && typeof s.data !== 'string') {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) {
                return jqXHR;
            }
            fireGlobals = s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger('ajaxStart');
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? '&' : '?') + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + nonce++) : cacheURL + (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++;
                }
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader('Content-Type', s.contentType);
            }
            jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort();
            }
            strAbort = 'abort';
            for (i in {
                    success: 1,
                    error: 1,
                    complete: 1
                }) {
                jqXHR[i](s[i]);
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, 'No Transport');
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxSend', [
                        jqXHR,
                        s
                    ]);
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function () {
                        jqXHR.abort('timeout');
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) {
                    return;
                }
                state = 2;
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || '';
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader('Last-Modified');
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader('etag');
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === 'HEAD') {
                        statusText = 'nocontent';
                    } else if (status === 304) {
                        statusText = 'notmodified';
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = 'error';
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + '';
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [
                        success,
                        statusText,
                        jqXHR
                    ]);
                } else {
                    deferred.rejectWith(callbackContext, [
                        jqXHR,
                        statusText,
                        error
                    ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
                        jqXHR,
                        s,
                        isSuccess ? success : error
                    ]);
                }
                completeDeferred.fireWith(callbackContext, [
                    jqXHR,
                    statusText
                ]);
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxComplete', [
                        jqXHR,
                        s
                    ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger('ajaxStop');
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, 'json');
        },
        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, 'script');
        }
    });
    jQuery.each([
        'get',
        'post'
    ], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    });
    jQuery.each([
        'ajaxStart',
        'ajaxStop',
        'ajaxComplete',
        'ajaxError',
        'ajaxSuccess',
        'ajaxSend'
    ], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });
    jQuery._evalUrl = function (url) {
        return jQuery.ajax({
            url: url,
            type: 'GET',
            dataType: 'script',
            async: false,
            global: false,
            'throws': true
        });
    };
    jQuery.fn.extend({
        wrapAll: function (html) {
            var wrap;
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function () {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function () {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function (html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function (i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function () {
            return this.parent().each(function () {
                if (!jQuery.nodeName(this, 'body')) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });
    jQuery.expr.filters.hidden = function (elem) {
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    };
    jQuery.expr.filters.visible = function (elem) {
        return !jQuery.expr.filters.hidden(elem);
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === 'object') {
            for (name in obj) {
                buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function (a, traditional) {
        var prefix, s = [], add = function (key, value) {
                value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
                s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
            };
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function () {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join('&').replace(r20, '+');
    };
    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {
                var elements = jQuery.prop(this, 'elements');
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function () {
                var type = this.type;
                return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function (i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, '\r\n')
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, '\r\n')
                };
            }).get();
        }
    });
    jQuery.ajaxSettings.xhr = function () {
        try {
            return new XMLHttpRequest();
        } catch (e) {
        }
    };
    var xhrId = 0, xhrCallbacks = {}, xhrSuccessStatus = {
            0: 200,
            1223: 204
        }, xhrSupported = jQuery.ajaxSettings.xhr();
    if (window.ActiveXObject) {
        jQuery(window).on('unload', function () {
            for (var key in xhrCallbacks) {
                xhrCallbacks[key]();
            }
        });
    }
    support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function (options) {
        var callback;
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function (headers, complete) {
                    var i, xhr = options.xhr(), id = ++xhrId;
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }
                    if (!options.crossDomain && !headers['X-Requested-With']) {
                        headers['X-Requested-With'] = 'XMLHttpRequest';
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }
                    callback = function (type) {
                        return function () {
                            if (callback) {
                                delete xhrCallbacks[id];
                                callback = xhr.onload = xhr.onerror = null;
                                if (type === 'abort') {
                                    xhr.abort();
                                } else if (type === 'error') {
                                    complete(xhr.status, xhr.statusText);
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === 'string' ? { text: xhr.responseText } : undefined, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };
                    xhr.onload = callback();
                    xhr.onerror = callback('error');
                    callback = xhrCallbacks[id] = callback('abort');
                    try {
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        if (callback) {
                            throw e;
                        }
                    }
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    jQuery.ajaxSetup({
        accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
        contents: { script: /(?:java|ecma)script/ },
        converters: {
            'text script': function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter('script', function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = 'GET';
        }
    });
    jQuery.ajaxTransport('script', function (s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function (_, complete) {
                    script = jQuery('<script>').prop({
                        async: true,
                        charset: s.scriptCharset,
                        src: s.url
                    }).on('load error', callback = function (evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === 'error' ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: 'callback',
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
        if (jsonProp || s.dataTypes[0] === 'jsonp') {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
            }
            s.converters['script json'] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + ' was not called');
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = 'json';
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };
            jqXHR.always(function () {
                window[callbackName] = overwritten;
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return 'script';
        }
    });
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (!data || typeof data !== 'string') {
            return null;
        }
        if (typeof context === 'boolean') {
            keepScripts = context;
            context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        if (parsed) {
            return [context.createElement(parsed[1])];
        }
        parsed = jQuery.buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function (url, params, callback) {
        if (typeof url !== 'string' && _load) {
            return _load.apply(this, arguments);
        }
        var selector, type, response, self = this, off = url.indexOf(' ');
        if (off >= 0) {
            selector = jQuery.trim(url.slice(off));
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === 'object') {
            type = 'POST';
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type,
                dataType: 'html',
                data: params
            }).done(function (responseText) {
                response = arguments;
                self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).complete(callback && function (jqXHR, status) {
                self.each(callback, response || [
                    jqXHR.responseText,
                    status,
                    jqXHR
                ]);
            });
        }
        return this;
    };
    jQuery.expr.filters.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };
    var docElem = window.document.documentElement;
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
            if (position === 'static') {
                elem.style.position = 'relative';
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, 'top');
            curCSSLeft = jQuery.css(elem, 'left');
            calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ('using' in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function (options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, elem = this[0], box = {
                    top: 0,
                    left: 0
                }, doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            if (typeof elem.getBoundingClientRect !== strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },
        position: function () {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, elem = this[0], parentOffset = {
                    top: 0,
                    left: 0
                };
            if (jQuery.css(elem, 'position') === 'fixed') {
                offset = elem.getBoundingClientRect();
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], 'html')) {
                    parentOffset = offsetParent.offset();
                }
                parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
                parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
            };
        },
        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent || docElem;
                while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || docElem;
            });
        }
    });
    jQuery.each({
        scrollLeft: 'pageXOffset',
        scrollTop: 'pageYOffset'
    }, function (method, prop) {
        var top = 'pageYOffset' === prop;
        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });
    jQuery.each([
        'top',
        'left'
    ], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
        });
    });
    jQuery.each({
        Height: 'height',
        Width: 'width'
    }, function (name, type) {
        jQuery.each({
            padding: 'inner' + name,
            content: type,
            '': 'outer' + name
        }, function (defaultExtra, funcName) {
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
                return access(this, function (elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return elem.document.documentElement['client' + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    jQuery.fn.size = function () {
        return this.length;
    };
    jQuery.fn.andSelf = jQuery.fn.addBack;
    if (typeof define === 'function' && define.amd) {
        define('jquery', [], function () {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
}));
;
(function () {
    var undefined;
    var arrayPool = [], objectPool = [];
    var idCounter = 0;
    var keyPrefix = +new Date() + '';
    var largeArraySize = 75;
    var maxPoolSize = 40;
    var whitespace = ' \t\x0B\f\xA0\uFEFF' + '\n\r\u2028\u2029' + '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000';
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reFuncName = /^\s*function[ \n\r\t]+\w/;
    var reInterpolate = /<%=([\s\S]+?)%>/g;
    var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
    var reNoMatch = /($^)/;
    var reThis = /\bthis\b/;
    var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
    var contextProps = [
        'Array',
        'Boolean',
        'Date',
        'Function',
        'Math',
        'Number',
        'Object',
        'RegExp',
        'String',
        '_',
        'attachEvent',
        'clearTimeout',
        'isFinite',
        'isNaN',
        'parseInt',
        'setTimeout'
    ];
    var templateCounter = 0;
    var argsClass = '[object Arguments]', arrayClass = '[object Array]', boolClass = '[object Boolean]', dateClass = '[object Date]', funcClass = '[object Function]', numberClass = '[object Number]', objectClass = '[object Object]', regexpClass = '[object RegExp]', stringClass = '[object String]';
    var cloneableClasses = {};
    cloneableClasses[funcClass] = false;
    cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
    var debounceOptions = {
        'leading': false,
        'maxWait': 0,
        'trailing': false
    };
    var descriptor = {
        'configurable': false,
        'enumerable': false,
        'value': null,
        'writable': false
    };
    var objectTypes = {
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
    };
    var stringEscapes = {
        '\\': '\\',
        '\'': '\'',
        '\n': 'n',
        '\r': 'r',
        '\t': 't',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
    };
    var root = objectTypes[typeof window] && window || this;
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
    var freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        root = freeGlobal;
    }
    function baseIndexOf(array, value, fromIndex) {
        var index = (fromIndex || 0) - 1, length = array ? array.length : 0;
        while (++index < length) {
            if (array[index] === value) {
                return index;
            }
        }
        return -1;
    }
    function cacheIndexOf(cache, value) {
        var type = typeof value;
        cache = cache.cache;
        if (type == 'boolean' || value == null) {
            return cache[value] ? 0 : -1;
        }
        if (type != 'number' && type != 'string') {
            type = 'object';
        }
        var key = type == 'number' ? value : keyPrefix + value;
        cache = (cache = cache[type]) && cache[key];
        return type == 'object' ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
    }
    function cachePush(value) {
        var cache = this.cache, type = typeof value;
        if (type == 'boolean' || value == null) {
            cache[value] = true;
        } else {
            if (type != 'number' && type != 'string') {
                type = 'object';
            }
            var key = type == 'number' ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
            if (type == 'object') {
                (typeCache[key] || (typeCache[key] = [])).push(value);
            } else {
                typeCache[key] = true;
            }
        }
    }
    function charAtCallback(value) {
        return value.charCodeAt(0);
    }
    function compareAscending(a, b) {
        var ac = a.criteria, bc = b.criteria, index = -1, length = ac.length;
        while (++index < length) {
            var value = ac[index], other = bc[index];
            if (value !== other) {
                if (value > other || typeof value == 'undefined') {
                    return 1;
                }
                if (value < other || typeof other == 'undefined') {
                    return -1;
                }
            }
        }
        return a.index - b.index;
    }
    function createCache(array) {
        var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
        if (first && typeof first == 'object' && mid && typeof mid == 'object' && last && typeof last == 'object') {
            return false;
        }
        var cache = getObject();
        cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
        var result = getObject();
        result.array = array;
        result.cache = cache;
        result.push = cachePush;
        while (++index < length) {
            result.push(array[index]);
        }
        return result;
    }
    function escapeStringChar(match) {
        return '\\' + stringEscapes[match];
    }
    function getArray() {
        return arrayPool.pop() || [];
    }
    function getObject() {
        return objectPool.pop() || {
            'array': null,
            'cache': null,
            'criteria': null,
            'false': false,
            'index': 0,
            'null': false,
            'number': null,
            'object': null,
            'push': null,
            'string': null,
            'true': false,
            'undefined': false,
            'value': null
        };
    }
    function releaseArray(array) {
        array.length = 0;
        if (arrayPool.length < maxPoolSize) {
            arrayPool.push(array);
        }
    }
    function releaseObject(object) {
        var cache = object.cache;
        if (cache) {
            releaseObject(cache);
        }
        object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
        if (objectPool.length < maxPoolSize) {
            objectPool.push(object);
        }
    }
    function slice(array, start, end) {
        start || (start = 0);
        if (typeof end == 'undefined') {
            end = array ? array.length : 0;
        }
        var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
        while (++index < length) {
            result[index] = array[start + index];
        }
        return result;
    }
    function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
        var arrayRef = [];
        var objectProto = Object.prototype;
        var oldDash = context._;
        var toString = objectProto.toString;
        var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');
        var ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, setTimeout = context.setTimeout, splice = arrayRef.splice, unshift = arrayRef.unshift;
        var defineProperty = function () {
            try {
                var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
            } catch (e) {
            }
            return result;
        }();
        var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random;
        var ctorByClass = {};
        ctorByClass[arrayClass] = Array;
        ctorByClass[boolClass] = Boolean;
        ctorByClass[dateClass] = Date;
        ctorByClass[funcClass] = Function;
        ctorByClass[objectClass] = Object;
        ctorByClass[numberClass] = Number;
        ctorByClass[regexpClass] = RegExp;
        ctorByClass[stringClass] = String;
        function lodash(value) {
            return value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__') ? value : new lodashWrapper(value);
        }
        function lodashWrapper(value, chainAll) {
            this.__chain__ = !!chainAll;
            this.__wrapped__ = value;
        }
        lodashWrapper.prototype = lodash.prototype;
        var support = lodash.support = {};
        support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
        support.funcNames = typeof Function.name == 'string';
        lodash.templateSettings = {
            'escape': /<%-([\s\S]+?)%>/g,
            'evaluate': /<%([\s\S]+?)%>/g,
            'interpolate': reInterpolate,
            'variable': '',
            'imports': { '_': lodash }
        };
        function baseBind(bindData) {
            var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
            function bound() {
                if (partialArgs) {
                    var args = slice(partialArgs);
                    push.apply(args, arguments);
                }
                if (this instanceof bound) {
                    var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
                    return isObject(result) ? result : thisBinding;
                }
                return func.apply(thisArg, args || arguments);
            }
            setBindData(bound, bindData);
            return bound;
        }
        function baseClone(value, isDeep, callback, stackA, stackB) {
            if (callback) {
                var result = callback(value);
                if (typeof result != 'undefined') {
                    return result;
                }
            }
            var isObj = isObject(value);
            if (isObj) {
                var className = toString.call(value);
                if (!cloneableClasses[className]) {
                    return value;
                }
                var ctor = ctorByClass[className];
                switch (className) {
                case boolClass:
                case dateClass:
                    return new ctor(+value);
                case numberClass:
                case stringClass:
                    return new ctor(value);
                case regexpClass:
                    result = ctor(value.source, reFlags.exec(value));
                    result.lastIndex = value.lastIndex;
                    return result;
                }
            } else {
                return value;
            }
            var isArr = isArray(value);
            if (isDeep) {
                var initedStack = !stackA;
                stackA || (stackA = getArray());
                stackB || (stackB = getArray());
                var length = stackA.length;
                while (length--) {
                    if (stackA[length] == value) {
                        return stackB[length];
                    }
                }
                result = isArr ? ctor(value.length) : {};
            } else {
                result = isArr ? slice(value) : assign({}, value);
            }
            if (isArr) {
                if (hasOwnProperty.call(value, 'index')) {
                    result.index = value.index;
                }
                if (hasOwnProperty.call(value, 'input')) {
                    result.input = value.input;
                }
            }
            if (!isDeep) {
                return result;
            }
            stackA.push(value);
            stackB.push(result);
            (isArr ? forEach : forOwn)(value, function (objValue, key) {
                result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
            });
            if (initedStack) {
                releaseArray(stackA);
                releaseArray(stackB);
            }
            return result;
        }
        function baseCreate(prototype, properties) {
            return isObject(prototype) ? nativeCreate(prototype) : {};
        }
        if (!nativeCreate) {
            baseCreate = function () {
                function Object() {
                }
                return function (prototype) {
                    if (isObject(prototype)) {
                        Object.prototype = prototype;
                        var result = new Object();
                        Object.prototype = null;
                    }
                    return result || context.Object();
                };
            }();
        }
        function baseCreateCallback(func, thisArg, argCount) {
            if (typeof func != 'function') {
                return identity;
            }
            if (typeof thisArg == 'undefined' || !('prototype' in func)) {
                return func;
            }
            var bindData = func.__bindData__;
            if (typeof bindData == 'undefined') {
                if (support.funcNames) {
                    bindData = !func.name;
                }
                bindData = bindData || !support.funcDecomp;
                if (!bindData) {
                    var source = fnToString.call(func);
                    if (!support.funcNames) {
                        bindData = !reFuncName.test(source);
                    }
                    if (!bindData) {
                        bindData = reThis.test(source);
                        setBindData(func, bindData);
                    }
                }
            }
            if (bindData === false || bindData !== true && bindData[1] & 1) {
                return func;
            }
            switch (argCount) {
            case 1:
                return function (value) {
                    return func.call(thisArg, value);
                };
            case 2:
                return function (a, b) {
                    return func.call(thisArg, a, b);
                };
            case 3:
                return function (value, index, collection) {
                    return func.call(thisArg, value, index, collection);
                };
            case 4:
                return function (accumulator, value, index, collection) {
                    return func.call(thisArg, accumulator, value, index, collection);
                };
            }
            return bind(func, thisArg);
        }
        function baseCreateWrapper(bindData) {
            var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5];
            var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, key = func;
            function bound() {
                var thisBinding = isBind ? thisArg : this;
                if (partialArgs) {
                    var args = slice(partialArgs);
                    push.apply(args, arguments);
                }
                if (partialRightArgs || isCurry) {
                    args || (args = slice(arguments));
                    if (partialRightArgs) {
                        push.apply(args, partialRightArgs);
                    }
                    if (isCurry && args.length < arity) {
                        bitmask |= 16 & ~32;
                        return baseCreateWrapper([
                            func,
                            isCurryBound ? bitmask : bitmask & ~3,
                            args,
                            null,
                            thisArg,
                            arity
                        ]);
                    }
                }
                args || (args = arguments);
                if (isBindKey) {
                    func = thisBinding[key];
                }
                if (this instanceof bound) {
                    thisBinding = baseCreate(func.prototype);
                    var result = func.apply(thisBinding, args);
                    return isObject(result) ? result : thisBinding;
                }
                return func.apply(thisBinding, args);
            }
            setBindData(bound, bindData);
            return bound;
        }
        function baseDifference(array, values) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, isLarge = length >= largeArraySize && indexOf === baseIndexOf, result = [];
            if (isLarge) {
                var cache = createCache(values);
                if (cache) {
                    indexOf = cacheIndexOf;
                    values = cache;
                } else {
                    isLarge = false;
                }
            }
            while (++index < length) {
                var value = array[index];
                if (indexOf(values, value) < 0) {
                    result.push(value);
                }
            }
            if (isLarge) {
                releaseObject(values);
            }
            return result;
        }
        function baseFlatten(array, isShallow, isStrict, fromIndex) {
            var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (value && typeof value == 'object' && typeof value.length == 'number' && (isArray(value) || isArguments(value))) {
                    if (!isShallow) {
                        value = baseFlatten(value, isShallow, isStrict);
                    }
                    var valIndex = -1, valLength = value.length, resIndex = result.length;
                    result.length += valLength;
                    while (++valIndex < valLength) {
                        result[resIndex++] = value[valIndex];
                    }
                } else if (!isStrict) {
                    result.push(value);
                }
            }
            return result;
        }
        function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
            if (callback) {
                var result = callback(a, b);
                if (typeof result != 'undefined') {
                    return !!result;
                }
            }
            if (a === b) {
                return a !== 0 || 1 / a == 1 / b;
            }
            var type = typeof a, otherType = typeof b;
            if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
                return false;
            }
            if (a == null || b == null) {
                return a === b;
            }
            var className = toString.call(a), otherClass = toString.call(b);
            if (className == argsClass) {
                className = objectClass;
            }
            if (otherClass == argsClass) {
                otherClass = objectClass;
            }
            if (className != otherClass) {
                return false;
            }
            switch (className) {
            case boolClass:
            case dateClass:
                return +a == +b;
            case numberClass:
                return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
            case regexpClass:
            case stringClass:
                return a == String(b);
            }
            var isArr = className == arrayClass;
            if (!isArr) {
                var aWrapped = hasOwnProperty.call(a, '__wrapped__'), bWrapped = hasOwnProperty.call(b, '__wrapped__');
                if (aWrapped || bWrapped) {
                    return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                }
                if (className != objectClass) {
                    return false;
                }
                var ctorA = a.constructor, ctorB = b.constructor;
                if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ('constructor' in a && 'constructor' in b)) {
                    return false;
                }
            }
            var initedStack = !stackA;
            stackA || (stackA = getArray());
            stackB || (stackB = getArray());
            var length = stackA.length;
            while (length--) {
                if (stackA[length] == a) {
                    return stackB[length] == b;
                }
            }
            var size = 0;
            result = true;
            stackA.push(a);
            stackB.push(b);
            if (isArr) {
                length = a.length;
                size = b.length;
                result = size == length;
                if (result || isWhere) {
                    while (size--) {
                        var index = length, value = b[size];
                        if (isWhere) {
                            while (index--) {
                                if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                                    break;
                                }
                            }
                        } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                            break;
                        }
                    }
                }
            } else {
                forIn(b, function (value, key, b) {
                    if (hasOwnProperty.call(b, key)) {
                        size++;
                        return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
                    }
                });
                if (result && !isWhere) {
                    forIn(a, function (value, key, a) {
                        if (hasOwnProperty.call(a, key)) {
                            return result = --size > -1;
                        }
                    });
                }
            }
            stackA.pop();
            stackB.pop();
            if (initedStack) {
                releaseArray(stackA);
                releaseArray(stackB);
            }
            return result;
        }
        function baseMerge(object, source, callback, stackA, stackB) {
            (isArray(source) ? forEach : forOwn)(source, function (source, key) {
                var found, isArr, result = source, value = object[key];
                if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                    var stackLength = stackA.length;
                    while (stackLength--) {
                        if (found = stackA[stackLength] == source) {
                            value = stackB[stackLength];
                            break;
                        }
                    }
                    if (!found) {
                        var isShallow;
                        if (callback) {
                            result = callback(value, source);
                            if (isShallow = typeof result != 'undefined') {
                                value = result;
                            }
                        }
                        if (!isShallow) {
                            value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                        }
                        stackA.push(source);
                        stackB.push(value);
                        if (!isShallow) {
                            baseMerge(value, source, callback, stackA, stackB);
                        }
                    }
                } else {
                    if (callback) {
                        result = callback(value, source);
                        if (typeof result == 'undefined') {
                            result = source;
                        }
                    }
                    if (typeof result != 'undefined') {
                        value = result;
                    }
                }
                object[key] = value;
            });
        }
        function baseRandom(min, max) {
            return min + floor(nativeRandom() * (max - min + 1));
        }
        function baseUniq(array, isSorted, callback) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
            var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
            if (isLarge) {
                var cache = createCache(seen);
                indexOf = cacheIndexOf;
                seen = cache;
            }
            while (++index < length) {
                var value = array[index], computed = callback ? callback(value, index, array) : value;
                if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                    if (callback || isLarge) {
                        seen.push(computed);
                    }
                    result.push(value);
                }
            }
            if (isLarge) {
                releaseArray(seen.array);
                releaseObject(seen);
            } else if (callback) {
                releaseArray(seen);
            }
            return result;
        }
        function createAggregator(setter) {
            return function (collection, callback, thisArg) {
                var result = {};
                callback = lodash.createCallback(callback, thisArg, 3);
                var index = -1, length = collection ? collection.length : 0;
                if (typeof length == 'number') {
                    while (++index < length) {
                        var value = collection[index];
                        setter(result, value, callback(value, index, collection), collection);
                    }
                } else {
                    forOwn(collection, function (value, key, collection) {
                        setter(result, value, callback(value, key, collection), collection);
                    });
                }
                return result;
            };
        }
        function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
            var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32;
            if (!isBindKey && !isFunction(func)) {
                throw new TypeError();
            }
            if (isPartial && !partialArgs.length) {
                bitmask &= ~16;
                isPartial = partialArgs = false;
            }
            if (isPartialRight && !partialRightArgs.length) {
                bitmask &= ~32;
                isPartialRight = partialRightArgs = false;
            }
            var bindData = func && func.__bindData__;
            if (bindData && bindData !== true) {
                bindData = slice(bindData);
                if (bindData[2]) {
                    bindData[2] = slice(bindData[2]);
                }
                if (bindData[3]) {
                    bindData[3] = slice(bindData[3]);
                }
                if (isBind && !(bindData[1] & 1)) {
                    bindData[4] = thisArg;
                }
                if (!isBind && bindData[1] & 1) {
                    bitmask |= 8;
                }
                if (isCurry && !(bindData[1] & 4)) {
                    bindData[5] = arity;
                }
                if (isPartial) {
                    push.apply(bindData[2] || (bindData[2] = []), partialArgs);
                }
                if (isPartialRight) {
                    unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
                }
                bindData[1] |= bitmask;
                return createWrapper.apply(null, bindData);
            }
            var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
            return creater([
                func,
                bitmask,
                partialArgs,
                partialRightArgs,
                thisArg,
                arity
            ]);
        }
        function escapeHtmlChar(match) {
            return htmlEscapes[match];
        }
        function getIndexOf() {
            var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
            return result;
        }
        function isNative(value) {
            return typeof value == 'function' && reNative.test(value);
        }
        var setBindData = !defineProperty ? noop : function (func, value) {
            descriptor.value = value;
            defineProperty(func, '__bindData__', descriptor);
        };
        function shimIsPlainObject(value) {
            var ctor, result;
            if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
                return false;
            }
            forIn(value, function (value, key) {
                result = key;
            });
            return typeof result == 'undefined' || hasOwnProperty.call(value, result);
        }
        function unescapeHtmlChar(match) {
            return htmlUnescapes[match];
        }
        function isArguments(value) {
            return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == argsClass || false;
        }
        var isArray = nativeIsArray || function (value) {
            return value && typeof value == 'object' && typeof value.length == 'number' && toString.call(value) == arrayClass || false;
        };
        var shimKeys = function (object) {
            var index, iterable = object, result = [];
            if (!iterable)
                return result;
            if (!objectTypes[typeof object])
                return result;
            for (index in iterable) {
                if (hasOwnProperty.call(iterable, index)) {
                    result.push(index);
                }
            }
            return result;
        };
        var keys = !nativeKeys ? shimKeys : function (object) {
            if (!isObject(object)) {
                return [];
            }
            return nativeKeys(object);
        };
        var htmlEscapes = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            '\'': '&#39;'
        };
        var htmlUnescapes = invert(htmlEscapes);
        var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'), reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');
        var assign = function (object, source, guard) {
            var index, iterable = object, result = iterable;
            if (!iterable)
                return result;
            var args = arguments, argsIndex = 0, argsLength = typeof guard == 'number' ? 2 : args.length;
            if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
                var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
            } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
                callback = args[--argsLength];
            }
            while (++argsIndex < argsLength) {
                iterable = args[argsIndex];
                if (iterable && objectTypes[typeof iterable]) {
                    var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                    while (++ownIndex < length) {
                        index = ownProps[ownIndex];
                        result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
                    }
                }
            }
            return result;
        };
        function clone(value, isDeep, callback, thisArg) {
            if (typeof isDeep != 'boolean' && isDeep != null) {
                thisArg = callback;
                callback = isDeep;
                isDeep = false;
            }
            return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
        }
        function cloneDeep(value, callback, thisArg) {
            return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
        }
        function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties ? assign(result, properties) : result;
        }
        var defaults = function (object, source, guard) {
            var index, iterable = object, result = iterable;
            if (!iterable)
                return result;
            var args = arguments, argsIndex = 0, argsLength = typeof guard == 'number' ? 2 : args.length;
            while (++argsIndex < argsLength) {
                iterable = args[argsIndex];
                if (iterable && objectTypes[typeof iterable]) {
                    var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                    while (++ownIndex < length) {
                        index = ownProps[ownIndex];
                        if (typeof result[index] == 'undefined')
                            result[index] = iterable[index];
                    }
                }
            }
            return result;
        };
        function findKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwn(object, function (value, key, object) {
                if (callback(value, key, object)) {
                    result = key;
                    return false;
                }
            });
            return result;
        }
        function findLastKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwnRight(object, function (value, key, object) {
                if (callback(value, key, object)) {
                    result = key;
                    return false;
                }
            });
            return result;
        }
        var forIn = function (collection, callback, thisArg) {
            var index, iterable = collection, result = iterable;
            if (!iterable)
                return result;
            if (!objectTypes[typeof iterable])
                return result;
            callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
            for (index in iterable) {
                if (callback(iterable[index], index, collection) === false)
                    return result;
            }
            return result;
        };
        function forInRight(object, callback, thisArg) {
            var pairs = [];
            forIn(object, function (value, key) {
                pairs.push(key, value);
            });
            var length = pairs.length;
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
                if (callback(pairs[length--], pairs[length], object) === false) {
                    break;
                }
            }
            return object;
        }
        var forOwn = function (collection, callback, thisArg) {
            var index, iterable = collection, result = iterable;
            if (!iterable)
                return result;
            if (!objectTypes[typeof iterable])
                return result;
            callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
            var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
            while (++ownIndex < length) {
                index = ownProps[ownIndex];
                if (callback(iterable[index], index, collection) === false)
                    return result;
            }
            return result;
        };
        function forOwnRight(object, callback, thisArg) {
            var props = keys(object), length = props.length;
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
                var key = props[length];
                if (callback(object[key], key, object) === false) {
                    break;
                }
            }
            return object;
        }
        function functions(object) {
            var result = [];
            forIn(object, function (value, key) {
                if (isFunction(value)) {
                    result.push(key);
                }
            });
            return result.sort();
        }
        function has(object, key) {
            return object ? hasOwnProperty.call(object, key) : false;
        }
        function invert(object) {
            var index = -1, props = keys(object), length = props.length, result = {};
            while (++index < length) {
                var key = props[index];
                result[object[key]] = key;
            }
            return result;
        }
        function isBoolean(value) {
            return value === true || value === false || value && typeof value == 'object' && toString.call(value) == boolClass || false;
        }
        function isDate(value) {
            return value && typeof value == 'object' && toString.call(value) == dateClass || false;
        }
        function isElement(value) {
            return value && value.nodeType === 1 || false;
        }
        function isEmpty(value) {
            var result = true;
            if (!value) {
                return result;
            }
            var className = toString.call(value), length = value.length;
            if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == 'number' && isFunction(value.splice)) {
                return !length;
            }
            forOwn(value, function () {
                return result = false;
            });
            return result;
        }
        function isEqual(a, b, callback, thisArg) {
            return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
        }
        function isFinite(value) {
            return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
        }
        function isFunction(value) {
            return typeof value == 'function';
        }
        function isObject(value) {
            return !!(value && objectTypes[typeof value]);
        }
        function isNaN(value) {
            return isNumber(value) && value != +value;
        }
        function isNull(value) {
            return value === null;
        }
        function isNumber(value) {
            return typeof value == 'number' || value && typeof value == 'object' && toString.call(value) == numberClass || false;
        }
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function (value) {
            if (!(value && toString.call(value) == objectClass)) {
                return false;
            }
            var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
            return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
        };
        function isRegExp(value) {
            return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
        }
        function isString(value) {
            return typeof value == 'string' || value && typeof value == 'object' && toString.call(value) == stringClass || false;
        }
        function isUndefined(value) {
            return typeof value == 'undefined';
        }
        function mapValues(object, callback, thisArg) {
            var result = {};
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwn(object, function (value, key, object) {
                result[key] = callback(value, key, object);
            });
            return result;
        }
        function merge(object) {
            var args = arguments, length = 2;
            if (!isObject(object)) {
                return object;
            }
            if (typeof args[2] != 'number') {
                length = args.length;
            }
            if (length > 3 && typeof args[length - 2] == 'function') {
                var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
            } else if (length > 2 && typeof args[length - 1] == 'function') {
                callback = args[--length];
            }
            var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
            while (++index < length) {
                baseMerge(object, sources[index], callback, stackA, stackB);
            }
            releaseArray(stackA);
            releaseArray(stackB);
            return object;
        }
        function omit(object, callback, thisArg) {
            var result = {};
            if (typeof callback != 'function') {
                var props = [];
                forIn(object, function (value, key) {
                    props.push(key);
                });
                props = baseDifference(props, baseFlatten(arguments, true, false, 1));
                var index = -1, length = props.length;
                while (++index < length) {
                    var key = props[index];
                    result[key] = object[key];
                }
            } else {
                callback = lodash.createCallback(callback, thisArg, 3);
                forIn(object, function (value, key, object) {
                    if (!callback(value, key, object)) {
                        result[key] = value;
                    }
                });
            }
            return result;
        }
        function pairs(object) {
            var index = -1, props = keys(object), length = props.length, result = Array(length);
            while (++index < length) {
                var key = props[index];
                result[index] = [
                    key,
                    object[key]
                ];
            }
            return result;
        }
        function pick(object, callback, thisArg) {
            var result = {};
            if (typeof callback != 'function') {
                var index = -1, props = baseFlatten(arguments, true, false, 1), length = isObject(object) ? props.length : 0;
                while (++index < length) {
                    var key = props[index];
                    if (key in object) {
                        result[key] = object[key];
                    }
                }
            } else {
                callback = lodash.createCallback(callback, thisArg, 3);
                forIn(object, function (value, key, object) {
                    if (callback(value, key, object)) {
                        result[key] = value;
                    }
                });
            }
            return result;
        }
        function transform(object, callback, accumulator, thisArg) {
            var isArr = isArray(object);
            if (accumulator == null) {
                if (isArr) {
                    accumulator = [];
                } else {
                    var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                    accumulator = baseCreate(proto);
                }
            }
            if (callback) {
                callback = lodash.createCallback(callback, thisArg, 4);
                (isArr ? forEach : forOwn)(object, function (value, index, object) {
                    return callback(accumulator, value, index, object);
                });
            }
            return accumulator;
        }
        function values(object) {
            var index = -1, props = keys(object), length = props.length, result = Array(length);
            while (++index < length) {
                result[index] = object[props[index]];
            }
            return result;
        }
        function at(collection) {
            var args = arguments, index = -1, props = baseFlatten(args, true, false, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length);
            while (++index < length) {
                result[index] = collection[props[index]];
            }
            return result;
        }
        function contains(collection, target, fromIndex) {
            var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
            fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
            if (isArray(collection)) {
                result = indexOf(collection, target, fromIndex) > -1;
            } else if (typeof length == 'number') {
                result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
            } else {
                forOwn(collection, function (value) {
                    if (++index >= fromIndex) {
                        return !(result = value === target);
                    }
                });
            }
            return result;
        }
        var countBy = createAggregator(function (result, value, key) {
            hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
        });
        function every(collection, callback, thisArg) {
            var result = true;
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == 'number') {
                while (++index < length) {
                    if (!(result = !!callback(collection[index], index, collection))) {
                        break;
                    }
                }
            } else {
                forOwn(collection, function (value, index, collection) {
                    return result = !!callback(value, index, collection);
                });
            }
            return result;
        }
        function filter(collection, callback, thisArg) {
            var result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == 'number') {
                while (++index < length) {
                    var value = collection[index];
                    if (callback(value, index, collection)) {
                        result.push(value);
                    }
                }
            } else {
                forOwn(collection, function (value, index, collection) {
                    if (callback(value, index, collection)) {
                        result.push(value);
                    }
                });
            }
            return result;
        }
        function find(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == 'number') {
                while (++index < length) {
                    var value = collection[index];
                    if (callback(value, index, collection)) {
                        return value;
                    }
                }
            } else {
                var result;
                forOwn(collection, function (value, index, collection) {
                    if (callback(value, index, collection)) {
                        result = value;
                        return false;
                    }
                });
                return result;
            }
        }
        function findLast(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forEachRight(collection, function (value, index, collection) {
                if (callback(value, index, collection)) {
                    result = value;
                    return false;
                }
            });
            return result;
        }
        function forEach(collection, callback, thisArg) {
            var index = -1, length = collection ? collection.length : 0;
            callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
            if (typeof length == 'number') {
                while (++index < length) {
                    if (callback(collection[index], index, collection) === false) {
                        break;
                    }
                }
            } else {
                forOwn(collection, callback);
            }
            return collection;
        }
        function forEachRight(collection, callback, thisArg) {
            var length = collection ? collection.length : 0;
            callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
            if (typeof length == 'number') {
                while (length--) {
                    if (callback(collection[length], length, collection) === false) {
                        break;
                    }
                }
            } else {
                var props = keys(collection);
                length = props.length;
                forOwn(collection, function (value, key, collection) {
                    key = props ? props[--length] : --length;
                    return callback(collection[key], key, collection);
                });
            }
            return collection;
        }
        var groupBy = createAggregator(function (result, value, key) {
            (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
        });
        var indexBy = createAggregator(function (result, value, key) {
            result[key] = value;
        });
        function invoke(collection, methodName) {
            var args = slice(arguments, 2), index = -1, isFunc = typeof methodName == 'function', length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
            forEach(collection, function (value) {
                result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
            });
            return result;
        }
        function map(collection, callback, thisArg) {
            var index = -1, length = collection ? collection.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            if (typeof length == 'number') {
                var result = Array(length);
                while (++index < length) {
                    result[index] = callback(collection[index], index, collection);
                }
            } else {
                result = [];
                forOwn(collection, function (value, key, collection) {
                    result[++index] = callback(value, key, collection);
                });
            }
            return result;
        }
        function max(collection, callback, thisArg) {
            var computed = -Infinity, result = computed;
            if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
                callback = null;
            }
            if (callback == null && isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (value > result) {
                        result = value;
                    }
                }
            } else {
                callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                forEach(collection, function (value, index, collection) {
                    var current = callback(value, index, collection);
                    if (current > computed) {
                        computed = current;
                        result = value;
                    }
                });
            }
            return result;
        }
        function min(collection, callback, thisArg) {
            var computed = Infinity, result = computed;
            if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
                callback = null;
            }
            if (callback == null && isArray(collection)) {
                var index = -1, length = collection.length;
                while (++index < length) {
                    var value = collection[index];
                    if (value < result) {
                        result = value;
                    }
                }
            } else {
                callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                forEach(collection, function (value, index, collection) {
                    var current = callback(value, index, collection);
                    if (current < computed) {
                        computed = current;
                        result = value;
                    }
                });
            }
            return result;
        }
        var pluck = map;
        function reduce(collection, callback, accumulator, thisArg) {
            if (!collection)
                return accumulator;
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
            var index = -1, length = collection.length;
            if (typeof length == 'number') {
                if (noaccum) {
                    accumulator = collection[++index];
                }
                while (++index < length) {
                    accumulator = callback(accumulator, collection[index], index, collection);
                }
            } else {
                forOwn(collection, function (value, index, collection) {
                    accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                });
            }
            return accumulator;
        }
        function reduceRight(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
            forEachRight(collection, function (value, index, collection) {
                accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
            });
            return accumulator;
        }
        function reject(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            return filter(collection, function (value, index, collection) {
                return !callback(value, index, collection);
            });
        }
        function sample(collection, n, guard) {
            if (collection && typeof collection.length != 'number') {
                collection = values(collection);
            }
            if (n == null || guard) {
                return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
            }
            var result = shuffle(collection);
            result.length = nativeMin(nativeMax(0, n), result.length);
            return result;
        }
        function shuffle(collection) {
            var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
            forEach(collection, function (value) {
                var rand = baseRandom(0, ++index);
                result[index] = result[rand];
                result[rand] = value;
            });
            return result;
        }
        function size(collection) {
            var length = collection ? collection.length : 0;
            return typeof length == 'number' ? length : keys(collection).length;
        }
        function some(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if (typeof length == 'number') {
                while (++index < length) {
                    if (result = callback(collection[index], index, collection)) {
                        break;
                    }
                }
            } else {
                forOwn(collection, function (value, index, collection) {
                    return !(result = callback(value, index, collection));
                });
            }
            return !!result;
        }
        function sortBy(collection, callback, thisArg) {
            var index = -1, isArr = isArray(callback), length = collection ? collection.length : 0, result = Array(typeof length == 'number' ? length : 0);
            if (!isArr) {
                callback = lodash.createCallback(callback, thisArg, 3);
            }
            forEach(collection, function (value, key, collection) {
                var object = result[++index] = getObject();
                if (isArr) {
                    object.criteria = map(callback, function (key) {
                        return value[key];
                    });
                } else {
                    (object.criteria = getArray())[0] = callback(value, key, collection);
                }
                object.index = index;
                object.value = value;
            });
            length = result.length;
            result.sort(compareAscending);
            while (length--) {
                var object = result[length];
                result[length] = object.value;
                if (!isArr) {
                    releaseArray(object.criteria);
                }
                releaseObject(object);
            }
            return result;
        }
        function toArray(collection) {
            if (collection && typeof collection.length == 'number') {
                return slice(collection);
            }
            return values(collection);
        }
        var where = filter;
        function compact(array) {
            var index = -1, length = array ? array.length : 0, result = [];
            while (++index < length) {
                var value = array[index];
                if (value) {
                    result.push(value);
                }
            }
            return result;
        }
        function difference(array) {
            return baseDifference(array, baseFlatten(arguments, true, true, 1));
        }
        function findIndex(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
                if (callback(array[index], index, array)) {
                    return index;
                }
            }
            return -1;
        }
        function findLastIndex(array, callback, thisArg) {
            var length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (length--) {
                if (callback(array[length], length, array)) {
                    return length;
                }
            }
            return -1;
        }
        function first(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != 'number' && callback != null) {
                var index = -1;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (++index < length && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback;
                if (n == null || thisArg) {
                    return array ? array[0] : undefined;
                }
            }
            return slice(array, 0, nativeMin(nativeMax(0, n), length));
        }
        function flatten(array, isShallow, callback, thisArg) {
            if (typeof isShallow != 'boolean' && isShallow != null) {
                thisArg = callback;
                callback = typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array ? null : isShallow;
                isShallow = false;
            }
            if (callback != null) {
                array = map(array, callback, thisArg);
            }
            return baseFlatten(array, isShallow);
        }
        function indexOf(array, value, fromIndex) {
            if (typeof fromIndex == 'number') {
                var length = array ? array.length : 0;
                fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
            } else if (fromIndex) {
                var index = sortedIndex(array, value);
                return array[index] === value ? index : -1;
            }
            return baseIndexOf(array, value, fromIndex);
        }
        function initial(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != 'number' && callback != null) {
                var index = length;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (index-- && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback == null || thisArg ? 1 : callback || n;
            }
            return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
        }
        function intersection() {
            var args = [], argsIndex = -1, argsLength = arguments.length, caches = getArray(), indexOf = getIndexOf(), trustIndexOf = indexOf === baseIndexOf, seen = getArray();
            while (++argsIndex < argsLength) {
                var value = arguments[argsIndex];
                if (isArray(value) || isArguments(value)) {
                    args.push(value);
                    caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
                }
            }
            var array = args[0], index = -1, length = array ? array.length : 0, result = [];
            outer:
                while (++index < length) {
                    var cache = caches[0];
                    value = array[index];
                    if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                        argsIndex = argsLength;
                        (cache || seen).push(value);
                        while (--argsIndex) {
                            cache = caches[argsIndex];
                            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                                continue outer;
                            }
                        }
                        result.push(value);
                    }
                }
            while (argsLength--) {
                cache = caches[argsLength];
                if (cache) {
                    releaseObject(cache);
                }
            }
            releaseArray(caches);
            releaseArray(seen);
            return result;
        }
        function last(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if (typeof callback != 'number' && callback != null) {
                var index = length;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (index-- && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback;
                if (n == null || thisArg) {
                    return array ? array[length - 1] : undefined;
                }
            }
            return slice(array, nativeMax(0, length - n));
        }
        function lastIndexOf(array, value, fromIndex) {
            var index = array ? array.length : 0;
            if (typeof fromIndex == 'number') {
                index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
            }
            while (index--) {
                if (array[index] === value) {
                    return index;
                }
            }
            return -1;
        }
        function pull(array) {
            var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0;
            while (++argsIndex < argsLength) {
                var index = -1, value = args[argsIndex];
                while (++index < length) {
                    if (array[index] === value) {
                        splice.call(array, index--, 1);
                        length--;
                    }
                }
            }
            return array;
        }
        function range(start, end, step) {
            start = +start || 0;
            step = typeof step == 'number' ? step : +step || 1;
            if (end == null) {
                end = start;
                start = 0;
            }
            var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length);
            while (++index < length) {
                result[index] = start;
                start += step;
            }
            return result;
        }
        function remove(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0, result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
                var value = array[index];
                if (callback(value, index, array)) {
                    result.push(value);
                    splice.call(array, index--, 1);
                    length--;
                }
            }
            return result;
        }
        function rest(array, callback, thisArg) {
            if (typeof callback != 'number' && callback != null) {
                var n = 0, index = -1, length = array ? array.length : 0;
                callback = lodash.createCallback(callback, thisArg, 3);
                while (++index < length && callback(array[index], index, array)) {
                    n++;
                }
            } else {
                n = callback == null || thisArg ? 1 : nativeMax(0, callback);
            }
            return slice(array, n);
        }
        function sortedIndex(array, value, callback, thisArg) {
            var low = 0, high = array ? array.length : low;
            callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
            value = callback(value);
            while (low < high) {
                var mid = low + high >>> 1;
                callback(array[mid]) < value ? low = mid + 1 : high = mid;
            }
            return low;
        }
        function union() {
            return baseUniq(baseFlatten(arguments, true, true));
        }
        function uniq(array, isSorted, callback, thisArg) {
            if (typeof isSorted != 'boolean' && isSorted != null) {
                thisArg = callback;
                callback = typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array ? null : isSorted;
                isSorted = false;
            }
            if (callback != null) {
                callback = lodash.createCallback(callback, thisArg, 3);
            }
            return baseUniq(array, isSorted, callback);
        }
        function without(array) {
            return baseDifference(array, slice(arguments, 1));
        }
        function xor() {
            var index = -1, length = arguments.length;
            while (++index < length) {
                var array = arguments[index];
                if (isArray(array) || isArguments(array)) {
                    var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
                }
            }
            return result || [];
        }
        function zip() {
            var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, 'length')) : 0, result = Array(length < 0 ? 0 : length);
            while (++index < length) {
                result[index] = pluck(array, index);
            }
            return result;
        }
        function zipObject(keys, values) {
            var index = -1, length = keys ? keys.length : 0, result = {};
            if (!values && length && !isArray(keys[0])) {
                values = [];
            }
            while (++index < length) {
                var key = keys[index];
                if (values) {
                    result[key] = values[index];
                } else if (key) {
                    result[key[0]] = key[1];
                }
            }
            return result;
        }
        function after(n, func) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            return function () {
                if (--n < 1) {
                    return func.apply(this, arguments);
                }
            };
        }
        function bind(func, thisArg) {
            return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
        }
        function bindAll(object) {
            var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object), index = -1, length = funcs.length;
            while (++index < length) {
                var key = funcs[index];
                object[key] = createWrapper(object[key], 1, null, null, object);
            }
            return object;
        }
        function bindKey(object, key) {
            return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
        }
        function compose() {
            var funcs = arguments, length = funcs.length;
            while (length--) {
                if (!isFunction(funcs[length])) {
                    throw new TypeError();
                }
            }
            return function () {
                var args = arguments, length = funcs.length;
                while (length--) {
                    args = [funcs[length].apply(this, args)];
                }
                return args[0];
            };
        }
        function curry(func, arity) {
            arity = typeof arity == 'number' ? arity : +arity || func.length;
            return createWrapper(func, 4, null, null, null, arity);
        }
        function debounce(func, wait, options) {
            var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
            if (!isFunction(func)) {
                throw new TypeError();
            }
            wait = nativeMax(0, wait) || 0;
            if (options === true) {
                var leading = true;
                trailing = false;
            } else if (isObject(options)) {
                leading = options.leading;
                maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
                trailing = 'trailing' in options ? options.trailing : trailing;
            }
            var delayed = function () {
                var remaining = wait - (now() - stamp);
                if (remaining <= 0) {
                    if (maxTimeoutId) {
                        clearTimeout(maxTimeoutId);
                    }
                    var isCalled = trailingCall;
                    maxTimeoutId = timeoutId = trailingCall = undefined;
                    if (isCalled) {
                        lastCalled = now();
                        result = func.apply(thisArg, args);
                        if (!timeoutId && !maxTimeoutId) {
                            args = thisArg = null;
                        }
                    }
                } else {
                    timeoutId = setTimeout(delayed, remaining);
                }
            };
            var maxDelayed = function () {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                maxTimeoutId = timeoutId = trailingCall = undefined;
                if (trailing || maxWait !== wait) {
                    lastCalled = now();
                    result = func.apply(thisArg, args);
                    if (!timeoutId && !maxTimeoutId) {
                        args = thisArg = null;
                    }
                }
            };
            return function () {
                args = arguments;
                stamp = now();
                thisArg = this;
                trailingCall = trailing && (timeoutId || !leading);
                if (maxWait === false) {
                    var leadingCall = leading && !timeoutId;
                } else {
                    if (!maxTimeoutId && !leading) {
                        lastCalled = stamp;
                    }
                    var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0;
                    if (isCalled) {
                        if (maxTimeoutId) {
                            maxTimeoutId = clearTimeout(maxTimeoutId);
                        }
                        lastCalled = stamp;
                        result = func.apply(thisArg, args);
                    } else if (!maxTimeoutId) {
                        maxTimeoutId = setTimeout(maxDelayed, remaining);
                    }
                }
                if (isCalled && timeoutId) {
                    timeoutId = clearTimeout(timeoutId);
                } else if (!timeoutId && wait !== maxWait) {
                    timeoutId = setTimeout(delayed, wait);
                }
                if (leadingCall) {
                    isCalled = true;
                    result = func.apply(thisArg, args);
                }
                if (isCalled && !timeoutId && !maxTimeoutId) {
                    args = thisArg = null;
                }
                return result;
            };
        }
        function defer(func) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            var args = slice(arguments, 1);
            return setTimeout(function () {
                func.apply(undefined, args);
            }, 1);
        }
        function delay(func, wait) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            var args = slice(arguments, 2);
            return setTimeout(function () {
                func.apply(undefined, args);
            }, wait);
        }
        function memoize(func, resolver) {
            if (!isFunction(func)) {
                throw new TypeError();
            }
            var memoized = function () {
                var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
                return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
            };
            memoized.cache = {};
            return memoized;
        }
        function once(func) {
            var ran, result;
            if (!isFunction(func)) {
                throw new TypeError();
            }
            return function () {
                if (ran) {
                    return result;
                }
                ran = true;
                result = func.apply(this, arguments);
                func = null;
                return result;
            };
        }
        function partial(func) {
            return createWrapper(func, 16, slice(arguments, 1));
        }
        function partialRight(func) {
            return createWrapper(func, 32, null, slice(arguments, 1));
        }
        function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (!isFunction(func)) {
                throw new TypeError();
            }
            if (options === false) {
                leading = false;
            } else if (isObject(options)) {
                leading = 'leading' in options ? options.leading : leading;
                trailing = 'trailing' in options ? options.trailing : trailing;
            }
            debounceOptions.leading = leading;
            debounceOptions.maxWait = wait;
            debounceOptions.trailing = trailing;
            return debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
            return createWrapper(wrapper, 16, [value]);
        }
        function constant(value) {
            return function () {
                return value;
            };
        }
        function createCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (func == null || type == 'function') {
                return baseCreateCallback(func, thisArg, argCount);
            }
            if (type != 'object') {
                return property(func);
            }
            var props = keys(func), key = props[0], a = func[key];
            if (props.length == 1 && a === a && !isObject(a)) {
                return function (object) {
                    var b = object[key];
                    return a === b && (a !== 0 || 1 / a == 1 / b);
                };
            }
            return function (object) {
                var length = props.length, result = false;
                while (length--) {
                    if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                        break;
                    }
                }
                return result;
            };
        }
        function escape(string) {
            return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
        }
        function identity(value) {
            return value;
        }
        function mixin(object, source, options) {
            var chain = true, methodNames = source && functions(source);
            if (!source || !options && !methodNames.length) {
                if (options == null) {
                    options = source;
                }
                ctor = lodashWrapper;
                source = object;
                object = lodash;
                methodNames = functions(source);
            }
            if (options === false) {
                chain = false;
            } else if (isObject(options) && 'chain' in options) {
                chain = options.chain;
            }
            var ctor = object, isFunc = isFunction(ctor);
            forEach(methodNames, function (methodName) {
                var func = object[methodName] = source[methodName];
                if (isFunc) {
                    ctor.prototype[methodName] = function () {
                        var chainAll = this.__chain__, value = this.__wrapped__, args = [value];
                        push.apply(args, arguments);
                        var result = func.apply(object, args);
                        if (chain || chainAll) {
                            if (value === result && isObject(result)) {
                                return this;
                            }
                            result = new ctor(result);
                            result.__chain__ = chainAll;
                        }
                        return result;
                    };
                }
            });
        }
        function noConflict() {
            context._ = oldDash;
            return this;
        }
        function noop() {
        }
        var now = isNative(now = Date.now) && now || function () {
            return new Date().getTime();
        };
        var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function (value, radix) {
            return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
        };
        function property(key) {
            return function (object) {
                return object[key];
            };
        }
        function random(min, max, floating) {
            var noMin = min == null, noMax = max == null;
            if (floating == null) {
                if (typeof min == 'boolean' && noMax) {
                    floating = min;
                    min = 1;
                } else if (!noMax && typeof max == 'boolean') {
                    floating = max;
                    noMax = true;
                }
            }
            if (noMin && noMax) {
                max = 1;
            }
            min = +min || 0;
            if (noMax) {
                max = min;
                min = 0;
            } else {
                max = +max || 0;
            }
            if (floating || min % 1 || max % 1) {
                var rand = nativeRandom();
                return nativeMin(min + rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1))), max);
            }
            return baseRandom(min, max);
        }
        function result(object, key) {
            if (object) {
                var value = object[key];
                return isFunction(value) ? object[key]() : value;
            }
        }
        function template(text, data, options) {
            var settings = lodash.templateSettings;
            text = String(text || '');
            options = defaults({}, options, settings);
            var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
            var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = '__p += \'';
            var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
            text.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                interpolateValue || (interpolateValue = esTemplateValue);
                source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                if (escapeValue) {
                    source += '\' +\n__e(' + escapeValue + ') +\n\'';
                }
                if (evaluateValue) {
                    isEvaluating = true;
                    source += '\';\n' + evaluateValue + ';\n__p += \'';
                }
                if (interpolateValue) {
                    source += '\' +\n((__t = (' + interpolateValue + ')) == null ? \'\' : __t) +\n\'';
                }
                index = offset + match.length;
                return match;
            });
            source += '\';\n';
            var variable = options.variable, hasVariable = variable;
            if (!hasVariable) {
                variable = 'obj';
                source = 'with (' + variable + ') {\n' + source + '\n}\n';
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
            source = 'function(' + variable + ') {\n' + (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') + 'var __t, __p = \'\', __e = _.escape' + (isEvaluating ? ', __j = Array.prototype.join;\n' + 'function print() { __p += __j.call(arguments, \'\') }\n' : ';\n') + source + 'return __p\n}';
            var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + templateCounter++ + ']') + '\n*/';
            try {
                var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
            } catch (e) {
                e.source = source;
                throw e;
            }
            if (data) {
                return result(data);
            }
            result.source = source;
            return result;
        }
        function times(n, callback, thisArg) {
            n = (n = +n) > -1 ? n : 0;
            var index = -1, result = Array(n);
            callback = baseCreateCallback(callback, thisArg, 1);
            while (++index < n) {
                result[index] = callback(index);
            }
            return result;
        }
        function unescape(string) {
            return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
        }
        function uniqueId(prefix) {
            var id = ++idCounter;
            return String(prefix == null ? '' : prefix) + id;
        }
        function chain(value) {
            value = new lodashWrapper(value);
            value.__chain__ = true;
            return value;
        }
        function tap(value, interceptor) {
            interceptor(value);
            return value;
        }
        function wrapperChain() {
            this.__chain__ = true;
            return this;
        }
        function wrapperToString() {
            return String(this.__wrapped__);
        }
        function wrapperValueOf() {
            return this.__wrapped__;
        }
        lodash.after = after;
        lodash.assign = assign;
        lodash.at = at;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.chain = chain;
        lodash.compact = compact;
        lodash.compose = compose;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.createCallback = createCallback;
        lodash.curry = curry;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.map = map;
        lodash.mapValues = mapValues;
        lodash.max = max;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.min = min;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.pull = pull;
        lodash.range = range;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.sortBy = sortBy;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.values = values;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.collect = map;
        lodash.drop = rest;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        lodash.unzip = zip;
        mixin(lodash);
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.contains = contains;
        lodash.escape = escape;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.has = has;
        lodash.identity = identity;
        lodash.indexOf = indexOf;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isNaN = isNaN;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isUndefined = isUndefined;
        lodash.lastIndexOf = lastIndexOf;
        lodash.mixin = mixin;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.template = template;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.all = every;
        lodash.any = some;
        lodash.detect = find;
        lodash.findWhere = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.include = contains;
        lodash.inject = reduce;
        mixin(function () {
            var source = {};
            forOwn(lodash, function (func, methodName) {
                if (!lodash.prototype[methodName]) {
                    source[methodName] = func;
                }
            });
            return source;
        }(), false);
        lodash.first = first;
        lodash.last = last;
        lodash.sample = sample;
        lodash.take = first;
        lodash.head = first;
        forOwn(lodash, function (func, methodName) {
            var callbackable = methodName !== 'sample';
            if (!lodash.prototype[methodName]) {
                lodash.prototype[methodName] = function (n, guard) {
                    var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
                    return !chainAll && (n == null || guard && !(callbackable && typeof n == 'function')) ? result : new lodashWrapper(result, chainAll);
                };
            }
        });
        lodash.VERSION = '2.4.1';
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.value = wrapperValueOf;
        lodash.prototype.valueOf = wrapperValueOf;
        forEach([
            'join',
            'pop',
            'shift'
        ], function (methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function () {
                var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
                return chainAll ? new lodashWrapper(result, chainAll) : result;
            };
        });
        forEach([
            'push',
            'reverse',
            'sort',
            'unshift'
        ], function (methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function () {
                func.apply(this.__wrapped__, arguments);
                return this;
            };
        });
        forEach([
            'concat',
            'slice',
            'splice'
        ], function (methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function () {
                return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
            };
        });
        return lodash;
    }
    var _ = runInContext();
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root._ = _;
        define('lodash', [], function () {
            return _;
        });
    } else if (freeExports && freeModule) {
        if (moduleExports) {
            (freeModule.exports = _)._ = _;
        } else {
            freeExports._ = _;
        }
    } else {
        root._ = _;
    }
}.call(this));
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('backbone', [
            'lodash',
            'jquery',
            'exports'
        ], function (_, $, exports) {
            root.Backbone = factory(root, exports, _, $);
        });
    } else if (typeof exports !== 'undefined') {
        var _ = require('underscore');
        factory(root, exports, _);
    } else {
        root.Backbone = factory(root, {}, root._, root.jQuery || root.Zepto || root.ender || root.$);
    }
}(this, function (root, Backbone, _, $) {
    var previousBackbone = root.Backbone;
    var array = [];
    var push = array.push;
    var slice = array.slice;
    var splice = array.splice;
    Backbone.VERSION = '1.1.2';
    Backbone.$ = $;
    Backbone.noConflict = function () {
        root.Backbone = previousBackbone;
        return this;
    };
    Backbone.emulateHTTP = false;
    Backbone.emulateJSON = false;
    var Events = Backbone.Events = {
        on: function (name, callback, context) {
            if (!eventsApi(this, 'on', name, [
                    callback,
                    context
                ]) || !callback)
                return this;
            this._events || (this._events = {});
            var events = this._events[name] || (this._events[name] = []);
            events.push({
                callback: callback,
                context: context,
                ctx: context || this
            });
            return this;
        },
        once: function (name, callback, context) {
            if (!eventsApi(this, 'once', name, [
                    callback,
                    context
                ]) || !callback)
                return this;
            var self = this;
            var once = _.once(function () {
                self.off(name, once);
                callback.apply(this, arguments);
            });
            once._callback = callback;
            return this.on(name, once, context);
        },
        off: function (name, callback, context) {
            var retain, ev, events, names, i, l, j, k;
            if (!this._events || !eventsApi(this, 'off', name, [
                    callback,
                    context
                ]))
                return this;
            if (!name && !callback && !context) {
                this._events = void 0;
                return this;
            }
            names = name ? [name] : _.keys(this._events);
            for (i = 0, l = names.length; i < l; i++) {
                name = names[i];
                if (events = this._events[name]) {
                    this._events[name] = retain = [];
                    if (callback || context) {
                        for (j = 0, k = events.length; j < k; j++) {
                            ev = events[j];
                            if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {
                                retain.push(ev);
                            }
                        }
                    }
                    if (!retain.length)
                        delete this._events[name];
                }
            }
            return this;
        },
        trigger: function (name) {
            if (!this._events)
                return this;
            var args = slice.call(arguments, 1);
            if (!eventsApi(this, 'trigger', name, args))
                return this;
            var events = this._events[name];
            var allEvents = this._events.all;
            if (events)
                triggerEvents(events, args);
            if (allEvents)
                triggerEvents(allEvents, arguments);
            return this;
        },
        stopListening: function (obj, name, callback) {
            var listeningTo = this._listeningTo;
            if (!listeningTo)
                return this;
            var remove = !name && !callback;
            if (!callback && typeof name === 'object')
                callback = this;
            if (obj)
                (listeningTo = {})[obj._listenId] = obj;
            for (var id in listeningTo) {
                obj = listeningTo[id];
                obj.off(name, callback, this);
                if (remove || _.isEmpty(obj._events))
                    delete this._listeningTo[id];
            }
            return this;
        }
    };
    var eventSplitter = /\s+/;
    var eventsApi = function (obj, action, name, rest) {
        if (!name)
            return true;
        if (typeof name === 'object') {
            for (var key in name) {
                obj[action].apply(obj, [
                    key,
                    name[key]
                ].concat(rest));
            }
            return false;
        }
        if (eventSplitter.test(name)) {
            var names = name.split(eventSplitter);
            for (var i = 0, l = names.length; i < l; i++) {
                obj[action].apply(obj, [names[i]].concat(rest));
            }
            return false;
        }
        return true;
    };
    var triggerEvents = function (events, args) {
        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
        switch (args.length) {
        case 0:
            while (++i < l)
                (ev = events[i]).callback.call(ev.ctx);
            return;
        case 1:
            while (++i < l)
                (ev = events[i]).callback.call(ev.ctx, a1);
            return;
        case 2:
            while (++i < l)
                (ev = events[i]).callback.call(ev.ctx, a1, a2);
            return;
        case 3:
            while (++i < l)
                (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
            return;
        default:
            while (++i < l)
                (ev = events[i]).callback.apply(ev.ctx, args);
            return;
        }
    };
    var listenMethods = {
        listenTo: 'on',
        listenToOnce: 'once'
    };
    _.each(listenMethods, function (implementation, method) {
        Events[method] = function (obj, name, callback) {
            var listeningTo = this._listeningTo || (this._listeningTo = {});
            var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
            listeningTo[id] = obj;
            if (!callback && typeof name === 'object')
                callback = this;
            obj[implementation](name, callback, this);
            return this;
        };
    });
    Events.bind = Events.on;
    Events.unbind = Events.off;
    _.extend(Backbone, Events);
    var Model = Backbone.Model = function (attributes, options) {
        var attrs = attributes || {};
        options || (options = {});
        this.cid = _.uniqueId('c');
        this.attributes = {};
        if (options.collection)
            this.collection = options.collection;
        if (options.parse)
            attrs = this.parse(attrs, options) || {};
        attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
    };
    _.extend(Model.prototype, Events, {
        changed: null,
        validationError: null,
        idAttribute: 'id',
        initialize: function () {
        },
        toJSON: function (options) {
            return _.clone(this.attributes);
        },
        sync: function () {
            return Backbone.sync.apply(this, arguments);
        },
        get: function (attr) {
            return this.attributes[attr];
        },
        escape: function (attr) {
            return _.escape(this.get(attr));
        },
        has: function (attr) {
            return this.get(attr) != null;
        },
        set: function (key, val, options) {
            var attr, attrs, unset, changes, silent, changing, prev, current;
            if (key == null)
                return this;
            if (typeof key === 'object') {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }
            options || (options = {});
            if (!this._validate(attrs, options))
                return false;
            unset = options.unset;
            silent = options.silent;
            changes = [];
            changing = this._changing;
            this._changing = true;
            if (!changing) {
                this._previousAttributes = _.clone(this.attributes);
                this.changed = {};
            }
            current = this.attributes, prev = this._previousAttributes;
            if (this.idAttribute in attrs)
                this.id = attrs[this.idAttribute];
            for (attr in attrs) {
                val = attrs[attr];
                if (!_.isEqual(current[attr], val))
                    changes.push(attr);
                if (!_.isEqual(prev[attr], val)) {
                    this.changed[attr] = val;
                } else {
                    delete this.changed[attr];
                }
                unset ? delete current[attr] : current[attr] = val;
            }
            if (!silent) {
                if (changes.length)
                    this._pending = options;
                for (var i = 0, l = changes.length; i < l; i++) {
                    this.trigger('change:' + changes[i], this, current[changes[i]], options);
                }
            }
            if (changing)
                return this;
            if (!silent) {
                while (this._pending) {
                    options = this._pending;
                    this._pending = false;
                    this.trigger('change', this, options);
                }
            }
            this._pending = false;
            this._changing = false;
            return this;
        },
        unset: function (attr, options) {
            return this.set(attr, void 0, _.extend({}, options, { unset: true }));
        },
        clear: function (options) {
            var attrs = {};
            for (var key in this.attributes)
                attrs[key] = void 0;
            return this.set(attrs, _.extend({}, options, { unset: true }));
        },
        hasChanged: function (attr) {
            if (attr == null)
                return !_.isEmpty(this.changed);
            return _.has(this.changed, attr);
        },
        changedAttributes: function (diff) {
            if (!diff)
                return this.hasChanged() ? _.clone(this.changed) : false;
            var val, changed = false;
            var old = this._changing ? this._previousAttributes : this.attributes;
            for (var attr in diff) {
                if (_.isEqual(old[attr], val = diff[attr]))
                    continue;
                (changed || (changed = {}))[attr] = val;
            }
            return changed;
        },
        previous: function (attr) {
            if (attr == null || !this._previousAttributes)
                return null;
            return this._previousAttributes[attr];
        },
        previousAttributes: function () {
            return _.clone(this._previousAttributes);
        },
        fetch: function (options) {
            options = options ? _.clone(options) : {};
            if (options.parse === void 0)
                options.parse = true;
            var model = this;
            var success = options.success;
            options.success = function (resp) {
                if (!model.set(model.parse(resp, options), options))
                    return false;
                if (success)
                    success(model, resp, options);
                model.trigger('sync', model, resp, options);
            };
            wrapError(this, options);
            return this.sync('read', this, options);
        },
        save: function (key, val, options) {
            var attrs, method, xhr, attributes = this.attributes;
            if (key == null || typeof key === 'object') {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }
            options = _.extend({ validate: true }, options);
            if (attrs && !options.wait) {
                if (!this.set(attrs, options))
                    return false;
            } else {
                if (!this._validate(attrs, options))
                    return false;
            }
            if (attrs && options.wait) {
                this.attributes = _.extend({}, attributes, attrs);
            }
            if (options.parse === void 0)
                options.parse = true;
            var model = this;
            var success = options.success;
            options.success = function (resp) {
                model.attributes = attributes;
                var serverAttrs = model.parse(resp, options);
                if (options.wait)
                    serverAttrs = _.extend(attrs || {}, serverAttrs);
                if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
                    return false;
                }
                if (success)
                    success(model, resp, options);
                model.trigger('sync', model, resp, options);
            };
            wrapError(this, options);
            method = this.isNew() ? 'create' : options.patch ? 'patch' : 'update';
            if (method === 'patch')
                options.attrs = attrs;
            xhr = this.sync(method, this, options);
            if (attrs && options.wait)
                this.attributes = attributes;
            return xhr;
        },
        destroy: function (options) {
            options = options ? _.clone(options) : {};
            var model = this;
            var success = options.success;
            var destroy = function () {
                model.trigger('destroy', model, model.collection, options);
            };
            options.success = function (resp) {
                if (options.wait || model.isNew())
                    destroy();
                if (success)
                    success(model, resp, options);
                if (!model.isNew())
                    model.trigger('sync', model, resp, options);
            };
            if (this.isNew()) {
                options.success();
                return false;
            }
            wrapError(this, options);
            var xhr = this.sync('delete', this, options);
            if (!options.wait)
                destroy();
            return xhr;
        },
        url: function () {
            var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
            if (this.isNew())
                return base;
            return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
        },
        parse: function (resp, options) {
            return resp;
        },
        clone: function () {
            return new this.constructor(this.attributes);
        },
        isNew: function () {
            return !this.has(this.idAttribute);
        },
        isValid: function (options) {
            return this._validate({}, _.extend(options || {}, { validate: true }));
        },
        _validate: function (attrs, options) {
            if (!options.validate || !this.validate)
                return true;
            attrs = _.extend({}, this.attributes, attrs);
            var error = this.validationError = this.validate(attrs, options) || null;
            if (!error)
                return true;
            this.trigger('invalid', this, error, _.extend(options, { validationError: error }));
            return false;
        }
    });
    var modelMethods = [
        'keys',
        'values',
        'pairs',
        'invert',
        'pick',
        'omit'
    ];
    _.each(modelMethods, function (method) {
        Model.prototype[method] = function () {
            var args = slice.call(arguments);
            args.unshift(this.attributes);
            return _[method].apply(_, args);
        };
    });
    var Collection = Backbone.Collection = function (models, options) {
        options || (options = {});
        if (options.model)
            this.model = options.model;
        if (options.comparator !== void 0)
            this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models)
            this.reset(models, _.extend({ silent: true }, options));
    };
    var setOptions = {
        add: true,
        remove: true,
        merge: true
    };
    var addOptions = {
        add: true,
        remove: false
    };
    _.extend(Collection.prototype, Events, {
        model: Model,
        initialize: function () {
        },
        toJSON: function (options) {
            return this.map(function (model) {
                return model.toJSON(options);
            });
        },
        sync: function () {
            return Backbone.sync.apply(this, arguments);
        },
        add: function (models, options) {
            return this.set(models, _.extend({ merge: false }, options, addOptions));
        },
        remove: function (models, options) {
            var singular = !_.isArray(models);
            models = singular ? [models] : _.clone(models);
            options || (options = {});
            var i, l, index, model;
            for (i = 0, l = models.length; i < l; i++) {
                model = models[i] = this.get(models[i]);
                if (!model)
                    continue;
                delete this._byId[model.id];
                delete this._byId[model.cid];
                index = this.indexOf(model);
                this.models.splice(index, 1);
                this.length--;
                if (!options.silent) {
                    options.index = index;
                    model.trigger('remove', model, this, options);
                }
                this._removeReference(model, options);
            }
            return singular ? models[0] : models;
        },
        set: function (models, options) {
            options = _.defaults({}, options, setOptions);
            if (options.parse)
                models = this.parse(models, options);
            var singular = !_.isArray(models);
            models = singular ? models ? [models] : [] : _.clone(models);
            var i, l, id, model, attrs, existing, sort;
            var at = options.at;
            var targetModel = this.model;
            var sortable = this.comparator && at == null && options.sort !== false;
            var sortAttr = _.isString(this.comparator) ? this.comparator : null;
            var toAdd = [], toRemove = [], modelMap = {};
            var add = options.add, merge = options.merge, remove = options.remove;
            var order = !sortable && add && remove ? [] : false;
            for (i = 0, l = models.length; i < l; i++) {
                attrs = models[i] || {};
                if (attrs instanceof Model) {
                    id = model = attrs;
                } else {
                    id = attrs[targetModel.prototype.idAttribute || 'id'];
                }
                if (existing = this.get(id)) {
                    if (remove)
                        modelMap[existing.cid] = true;
                    if (merge) {
                        attrs = attrs === model ? model.attributes : attrs;
                        if (options.parse)
                            attrs = existing.parse(attrs, options);
                        existing.set(attrs, options);
                        if (sortable && !sort && existing.hasChanged(sortAttr))
                            sort = true;
                    }
                    models[i] = existing;
                } else if (add) {
                    model = models[i] = this._prepareModel(attrs, options);
                    if (!model)
                        continue;
                    toAdd.push(model);
                    this._addReference(model, options);
                }
                model = existing || model;
                if (order && (model.isNew() || !modelMap[model.id]))
                    order.push(model);
                modelMap[model.id] = true;
            }
            if (remove) {
                for (i = 0, l = this.length; i < l; ++i) {
                    if (!modelMap[(model = this.models[i]).cid])
                        toRemove.push(model);
                }
                if (toRemove.length)
                    this.remove(toRemove, options);
            }
            if (toAdd.length || order && order.length) {
                if (sortable)
                    sort = true;
                this.length += toAdd.length;
                if (at != null) {
                    for (i = 0, l = toAdd.length; i < l; i++) {
                        this.models.splice(at + i, 0, toAdd[i]);
                    }
                } else {
                    if (order)
                        this.models.length = 0;
                    var orderedModels = order || toAdd;
                    for (i = 0, l = orderedModels.length; i < l; i++) {
                        this.models.push(orderedModels[i]);
                    }
                }
            }
            if (sort)
                this.sort({ silent: true });
            if (!options.silent) {
                for (i = 0, l = toAdd.length; i < l; i++) {
                    (model = toAdd[i]).trigger('add', model, this, options);
                }
                if (sort || order && order.length)
                    this.trigger('sort', this, options);
            }
            return singular ? models[0] : models;
        },
        reset: function (models, options) {
            options || (options = {});
            for (var i = 0, l = this.models.length; i < l; i++) {
                this._removeReference(this.models[i], options);
            }
            options.previousModels = this.models;
            this._reset();
            models = this.add(models, _.extend({ silent: true }, options));
            if (!options.silent)
                this.trigger('reset', this, options);
            return models;
        },
        push: function (model, options) {
            return this.add(model, _.extend({ at: this.length }, options));
        },
        pop: function (options) {
            var model = this.at(this.length - 1);
            this.remove(model, options);
            return model;
        },
        unshift: function (model, options) {
            return this.add(model, _.extend({ at: 0 }, options));
        },
        shift: function (options) {
            var model = this.at(0);
            this.remove(model, options);
            return model;
        },
        slice: function () {
            return slice.apply(this.models, arguments);
        },
        get: function (obj) {
            if (obj == null)
                return void 0;
            return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
        },
        at: function (index) {
            return this.models[index];
        },
        where: function (attrs, first) {
            if (_.isEmpty(attrs))
                return first ? void 0 : [];
            return this[first ? 'find' : 'filter'](function (model) {
                for (var key in attrs) {
                    if (attrs[key] !== model.get(key))
                        return false;
                }
                return true;
            });
        },
        findWhere: function (attrs) {
            return this.where(attrs, true);
        },
        sort: function (options) {
            if (!this.comparator)
                throw new Error('Cannot sort a set without a comparator');
            options || (options = {});
            if (_.isString(this.comparator) || this.comparator.length === 1) {
                this.models = this.sortBy(this.comparator, this);
            } else {
                this.models.sort(_.bind(this.comparator, this));
            }
            if (!options.silent)
                this.trigger('sort', this, options);
            return this;
        },
        pluck: function (attr) {
            return _.invoke(this.models, 'get', attr);
        },
        fetch: function (options) {
            options = options ? _.clone(options) : {};
            if (options.parse === void 0)
                options.parse = true;
            var success = options.success;
            var collection = this;
            options.success = function (resp) {
                var method = options.reset ? 'reset' : 'set';
                collection[method](resp, options);
                if (success)
                    success(collection, resp, options);
                collection.trigger('sync', collection, resp, options);
            };
            wrapError(this, options);
            return this.sync('read', this, options);
        },
        create: function (model, options) {
            options = options ? _.clone(options) : {};
            if (!(model = this._prepareModel(model, options)))
                return false;
            if (!options.wait)
                this.add(model, options);
            var collection = this;
            var success = options.success;
            options.success = function (model, resp) {
                if (options.wait)
                    collection.add(model, options);
                if (success)
                    success(model, resp, options);
            };
            model.save(null, options);
            return model;
        },
        parse: function (resp, options) {
            return resp;
        },
        clone: function () {
            return new this.constructor(this.models);
        },
        _reset: function () {
            this.length = 0;
            this.models = [];
            this._byId = {};
        },
        _prepareModel: function (attrs, options) {
            if (attrs instanceof Model)
                return attrs;
            options = options ? _.clone(options) : {};
            options.collection = this;
            var model = new this.model(attrs, options);
            if (!model.validationError)
                return model;
            this.trigger('invalid', this, model.validationError, options);
            return false;
        },
        _addReference: function (model, options) {
            this._byId[model.cid] = model;
            if (model.id != null)
                this._byId[model.id] = model;
            if (!model.collection)
                model.collection = this;
            model.on('all', this._onModelEvent, this);
        },
        _removeReference: function (model, options) {
            if (this === model.collection)
                delete model.collection;
            model.off('all', this._onModelEvent, this);
        },
        _onModelEvent: function (event, model, collection, options) {
            if ((event === 'add' || event === 'remove') && collection !== this)
                return;
            if (event === 'destroy')
                this.remove(model, options);
            if (model && event === 'change:' + model.idAttribute) {
                delete this._byId[model.previous(model.idAttribute)];
                if (model.id != null)
                    this._byId[model.id] = model;
            }
            this.trigger.apply(this, arguments);
        }
    });
    var methods = [
        'forEach',
        'each',
        'map',
        'collect',
        'reduce',
        'foldl',
        'inject',
        'reduceRight',
        'foldr',
        'find',
        'detect',
        'filter',
        'select',
        'reject',
        'every',
        'all',
        'some',
        'any',
        'include',
        'contains',
        'invoke',
        'max',
        'min',
        'toArray',
        'size',
        'first',
        'head',
        'take',
        'initial',
        'rest',
        'tail',
        'drop',
        'last',
        'without',
        'difference',
        'indexOf',
        'shuffle',
        'lastIndexOf',
        'isEmpty',
        'chain',
        'sample'
    ];
    _.each(methods, function (method) {
        Collection.prototype[method] = function () {
            var args = slice.call(arguments);
            args.unshift(this.models);
            return _[method].apply(_, args);
        };
    });
    var attributeMethods = [
        'groupBy',
        'countBy',
        'sortBy',
        'indexBy'
    ];
    _.each(attributeMethods, function (method) {
        Collection.prototype[method] = function (value, context) {
            var iterator = _.isFunction(value) ? value : function (model) {
                return model.get(value);
            };
            return _[method](this.models, iterator, context);
        };
    });
    var View = Backbone.View = function (options) {
        this.cid = _.uniqueId('view');
        options || (options = {});
        _.extend(this, _.pick(options, viewOptions));
        this._ensureElement();
        this.initialize.apply(this, arguments);
        this.delegateEvents();
    };
    var delegateEventSplitter = /^(\S+)\s*(.*)$/;
    var viewOptions = [
        'model',
        'collection',
        'el',
        'id',
        'attributes',
        'className',
        'tagName',
        'events'
    ];
    _.extend(View.prototype, Events, {
        tagName: 'div',
        $: function (selector) {
            return this.$el.find(selector);
        },
        initialize: function () {
        },
        render: function () {
            return this;
        },
        remove: function () {
            this.$el.remove();
            this.stopListening();
            return this;
        },
        setElement: function (element, delegate) {
            if (this.$el)
                this.undelegateEvents();
            this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
            this.el = this.$el[0];
            if (delegate !== false)
                this.delegateEvents();
            return this;
        },
        delegateEvents: function (events) {
            if (!(events || (events = _.result(this, 'events'))))
                return this;
            this.undelegateEvents();
            for (var key in events) {
                var method = events[key];
                if (!_.isFunction(method))
                    method = this[events[key]];
                if (!method)
                    continue;
                var match = key.match(delegateEventSplitter);
                var eventName = match[1], selector = match[2];
                method = _.bind(method, this);
                eventName += '.delegateEvents' + this.cid;
                if (selector === '') {
                    this.$el.on(eventName, method);
                } else {
                    this.$el.on(eventName, selector, method);
                }
            }
            return this;
        },
        undelegateEvents: function () {
            this.$el.off('.delegateEvents' + this.cid);
            return this;
        },
        _ensureElement: function () {
            if (!this.el) {
                var attrs = _.extend({}, _.result(this, 'attributes'));
                if (this.id)
                    attrs.id = _.result(this, 'id');
                if (this.className)
                    attrs['class'] = _.result(this, 'className');
                var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
                this.setElement($el, false);
            } else {
                this.setElement(_.result(this, 'el'), false);
            }
        }
    });
    Backbone.sync = function (method, model, options) {
        var type = methodMap[method];
        _.defaults(options || (options = {}), {
            emulateHTTP: Backbone.emulateHTTP,
            emulateJSON: Backbone.emulateJSON
        });
        var params = {
            type: type,
            dataType: 'json'
        };
        if (!options.url) {
            params.url = _.result(model, 'url') || urlError();
        }
        if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
            params.contentType = 'application/json';
            params.data = JSON.stringify(options.attrs || model.toJSON(options));
        }
        if (options.emulateJSON) {
            params.contentType = 'application/x-www-form-urlencoded';
            params.data = params.data ? { model: params.data } : {};
        }
        if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
            params.type = 'POST';
            if (options.emulateJSON)
                params.data._method = type;
            var beforeSend = options.beforeSend;
            options.beforeSend = function (xhr) {
                xhr.setRequestHeader('X-HTTP-Method-Override', type);
                if (beforeSend)
                    return beforeSend.apply(this, arguments);
            };
        }
        if (params.type !== 'GET' && !options.emulateJSON) {
            params.processData = false;
        }
        if (params.type === 'PATCH' && noXhrPatch) {
            params.xhr = function () {
                return new ActiveXObject('Microsoft.XMLHTTP');
            };
        }
        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
        model.trigger('request', model, xhr, options);
        return xhr;
    };
    var noXhrPatch = typeof window !== 'undefined' && !!window.ActiveXObject && !(window.XMLHttpRequest && new XMLHttpRequest().dispatchEvent);
    var methodMap = {
        'create': 'POST',
        'update': 'PUT',
        'patch': 'PATCH',
        'delete': 'DELETE',
        'read': 'GET'
    };
    Backbone.ajax = function () {
        return Backbone.$.ajax.apply(Backbone.$, arguments);
    };
    var Router = Backbone.Router = function (options) {
        options || (options = {});
        if (options.routes)
            this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
    };
    var optionalParam = /\((.*?)\)/g;
    var namedParam = /(\(\?)?:\w+/g;
    var splatParam = /\*\w+/g;
    var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
    _.extend(Router.prototype, Events, {
        initialize: function () {
        },
        route: function (route, name, callback) {
            if (!_.isRegExp(route))
                route = this._routeToRegExp(route);
            if (_.isFunction(name)) {
                callback = name;
                name = '';
            }
            if (!callback)
                callback = this[name];
            var router = this;
            Backbone.history.route(route, function (fragment) {
                var args = router._extractParameters(route, fragment);
                router.execute(callback, args);
                router.trigger.apply(router, ['route:' + name].concat(args));
                router.trigger('route', name, args);
                Backbone.history.trigger('route', router, name, args);
            });
            return this;
        },
        execute: function (callback, args) {
            if (callback)
                callback.apply(this, args);
        },
        navigate: function (fragment, options) {
            Backbone.history.navigate(fragment, options);
            return this;
        },
        _bindRoutes: function () {
            if (!this.routes)
                return;
            this.routes = _.result(this, 'routes');
            var route, routes = _.keys(this.routes);
            while ((route = routes.pop()) != null) {
                this.route(route, this.routes[route]);
            }
        },
        _routeToRegExp: function (route) {
            route = route.replace(escapeRegExp, '\\$&').replace(optionalParam, '(?:$1)?').replace(namedParam, function (match, optional) {
                return optional ? match : '([^/?]+)';
            }).replace(splatParam, '([^?]*?)');
            return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
        },
        _extractParameters: function (route, fragment) {
            var params = route.exec(fragment).slice(1);
            return _.map(params, function (param, i) {
                if (i === params.length - 1)
                    return param || null;
                return param ? decodeURIComponent(param) : null;
            });
        }
    });
    var History = Backbone.History = function () {
        this.handlers = [];
        _.bindAll(this, 'checkUrl');
        if (typeof window !== 'undefined') {
            this.location = window.location;
            this.history = window.history;
        }
    };
    var routeStripper = /^[#\/]|\s+$/g;
    var rootStripper = /^\/+|\/+$/g;
    var isExplorer = /msie [\w.]+/;
    var trailingSlash = /\/$/;
    var pathStripper = /#.*$/;
    History.started = false;
    _.extend(History.prototype, Events, {
        interval: 50,
        atRoot: function () {
            return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
        },
        getHash: function (window) {
            var match = (window || this).location.href.match(/#(.*)$/);
            return match ? match[1] : '';
        },
        getFragment: function (fragment, forcePushState) {
            if (fragment == null) {
                if (this._hasPushState || !this._wantsHashChange || forcePushState) {
                    fragment = decodeURI(this.location.pathname + this.location.search);
                    var root = this.root.replace(trailingSlash, '');
                    if (!fragment.indexOf(root))
                        fragment = fragment.slice(root.length);
                } else {
                    fragment = this.getHash();
                }
            }
            return fragment.replace(routeStripper, '');
        },
        start: function (options) {
            if (History.started)
                throw new Error('Backbone.history has already been started');
            History.started = true;
            this.options = _.extend({ root: '/' }, this.options, options);
            this.root = this.options.root;
            this._wantsHashChange = this.options.hashChange !== false;
            this._wantsPushState = !!this.options.pushState;
            this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);
            var fragment = this.getFragment();
            var docMode = document.documentMode;
            var oldIE = isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7);
            this.root = ('/' + this.root + '/').replace(rootStripper, '/');
            if (oldIE && this._wantsHashChange) {
                var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
                this.iframe = frame.hide().appendTo('body')[0].contentWindow;
                this.navigate(fragment);
            }
            if (this._hasPushState) {
                Backbone.$(window).on('popstate', this.checkUrl);
            } else if (this._wantsHashChange && 'onhashchange' in window && !oldIE) {
                Backbone.$(window).on('hashchange', this.checkUrl);
            } else if (this._wantsHashChange) {
                this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
            }
            this.fragment = fragment;
            var loc = this.location;
            if (this._wantsHashChange && this._wantsPushState) {
                if (!this._hasPushState && !this.atRoot()) {
                    this.fragment = this.getFragment(null, true);
                    this.location.replace(this.root + '#' + this.fragment);
                    return true;
                } else if (this._hasPushState && this.atRoot() && loc.hash) {
                    this.fragment = this.getHash().replace(routeStripper, '');
                    this.history.replaceState({}, document.title, this.root + this.fragment);
                }
            }
            if (!this.options.silent)
                return this.loadUrl();
        },
        stop: function () {
            Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
            if (this._checkUrlInterval)
                clearInterval(this._checkUrlInterval);
            History.started = false;
        },
        route: function (route, callback) {
            this.handlers.unshift({
                route: route,
                callback: callback
            });
        },
        checkUrl: function (e) {
            var current = this.getFragment();
            if (current === this.fragment && this.iframe) {
                current = this.getFragment(this.getHash(this.iframe));
            }
            if (current === this.fragment)
                return false;
            if (this.iframe)
                this.navigate(current);
            this.loadUrl();
        },
        loadUrl: function (fragment) {
            fragment = this.fragment = this.getFragment(fragment);
            return _.any(this.handlers, function (handler) {
                if (handler.route.test(fragment)) {
                    handler.callback(fragment);
                    return true;
                }
            });
        },
        navigate: function (fragment, options) {
            if (!History.started)
                return false;
            if (!options || options === true)
                options = { trigger: !!options };
            var url = this.root + (fragment = this.getFragment(fragment || ''));
            fragment = fragment.replace(pathStripper, '');
            if (this.fragment === fragment)
                return;
            this.fragment = fragment;
            if (fragment === '' && url !== '/')
                url = url.slice(0, -1);
            if (this._hasPushState) {
                this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);
            } else if (this._wantsHashChange) {
                this._updateHash(this.location, fragment, options.replace);
                if (this.iframe && fragment !== this.getFragment(this.getHash(this.iframe))) {
                    if (!options.replace)
                        this.iframe.document.open().close();
                    this._updateHash(this.iframe.location, fragment, options.replace);
                }
            } else {
                return this.location.assign(url);
            }
            if (options.trigger)
                return this.loadUrl(fragment);
        },
        _updateHash: function (location, fragment, replace) {
            if (replace) {
                var href = location.href.replace(/(javascript:|#).*$/, '');
                location.replace(href + '#' + fragment);
            } else {
                location.hash = '#' + fragment;
            }
        }
    });
    Backbone.history = new History();
    var extend = function (protoProps, staticProps) {
        var parent = this;
        var child;
        if (protoProps && _.has(protoProps, 'constructor')) {
            child = protoProps.constructor;
        } else {
            child = function () {
                return parent.apply(this, arguments);
            };
        }
        _.extend(child, parent, staticProps);
        var Surrogate = function () {
            this.constructor = child;
        };
        Surrogate.prototype = parent.prototype;
        child.prototype = new Surrogate();
        if (protoProps)
            _.extend(child.prototype, protoProps);
        child.__super__ = parent.prototype;
        return child;
    };
    Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
    var urlError = function () {
        throw new Error('A "url" property or function must be specified');
    };
    var wrapError = function (model, options) {
        var error = options.error;
        options.error = function (resp) {
            if (error)
                error(model, resp, options);
            model.trigger('error', model, resp, options);
        };
    };
    return Backbone;
}));
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('marionette', [
            'backbone',
            'lodash'
        ], function (Backbone, _) {
            return root.Marionette = factory(root, Backbone, _);
        });
    } else if (typeof exports !== 'undefined') {
        var Backbone = require('backbone');
        var _ = require('underscore');
        module.exports = factory(root, Backbone, _);
    } else {
        root.Marionette = factory(root, root.Backbone, root._);
    }
}(this, function (root, Backbone, _) {
    'use strict';
    (function (Backbone, _) {
        'use strict';
        var previousChildViewContainer = Backbone.ChildViewContainer;
        Backbone.ChildViewContainer = function (Backbone, _) {
            var Container = function (views) {
                this._views = {};
                this._indexByModel = {};
                this._indexByCustom = {};
                this._updateLength();
                _.each(views, this.add, this);
            };
            _.extend(Container.prototype, {
                add: function (view, customIndex) {
                    var viewCid = view.cid;
                    this._views[viewCid] = view;
                    if (view.model) {
                        this._indexByModel[view.model.cid] = viewCid;
                    }
                    if (customIndex) {
                        this._indexByCustom[customIndex] = viewCid;
                    }
                    this._updateLength();
                    return this;
                },
                findByModel: function (model) {
                    return this.findByModelCid(model.cid);
                },
                findByModelCid: function (modelCid) {
                    var viewCid = this._indexByModel[modelCid];
                    return this.findByCid(viewCid);
                },
                findByCustom: function (index) {
                    var viewCid = this._indexByCustom[index];
                    return this.findByCid(viewCid);
                },
                findByIndex: function (index) {
                    return _.values(this._views)[index];
                },
                findByCid: function (cid) {
                    return this._views[cid];
                },
                remove: function (view) {
                    var viewCid = view.cid;
                    if (view.model) {
                        delete this._indexByModel[view.model.cid];
                    }
                    _.any(this._indexByCustom, function (cid, key) {
                        if (cid === viewCid) {
                            delete this._indexByCustom[key];
                            return true;
                        }
                    }, this);
                    delete this._views[viewCid];
                    this._updateLength();
                    return this;
                },
                call: function (method) {
                    this.apply(method, _.tail(arguments));
                },
                apply: function (method, args) {
                    _.each(this._views, function (view) {
                        if (_.isFunction(view[method])) {
                            view[method].apply(view, args || []);
                        }
                    });
                },
                _updateLength: function () {
                    this.length = _.size(this._views);
                }
            });
            var methods = [
                'forEach',
                'each',
                'map',
                'find',
                'detect',
                'filter',
                'select',
                'reject',
                'every',
                'all',
                'some',
                'any',
                'include',
                'contains',
                'invoke',
                'toArray',
                'first',
                'initial',
                'rest',
                'last',
                'without',
                'isEmpty',
                'pluck'
            ];
            _.each(methods, function (method) {
                Container.prototype[method] = function () {
                    var views = _.values(this._views);
                    var args = [views].concat(_.toArray(arguments));
                    return _[method].apply(_, args);
                };
            });
            return Container;
        }(Backbone, _);
        Backbone.ChildViewContainer.VERSION = '0.1.4';
        Backbone.ChildViewContainer.noConflict = function () {
            Backbone.ChildViewContainer = previousChildViewContainer;
            return this;
        };
        return Backbone.ChildViewContainer;
    }(Backbone, _));
    (function (Backbone, _) {
        'use strict';
        var previousWreqr = Backbone.Wreqr;
        var Wreqr = Backbone.Wreqr = {};
        Backbone.Wreqr.VERSION = '1.3.1';
        Backbone.Wreqr.noConflict = function () {
            Backbone.Wreqr = previousWreqr;
            return this;
        };
        Wreqr.Handlers = function (Backbone, _) {
            'use strict';
            var Handlers = function (options) {
                this.options = options;
                this._wreqrHandlers = {};
                if (_.isFunction(this.initialize)) {
                    this.initialize(options);
                }
            };
            Handlers.extend = Backbone.Model.extend;
            _.extend(Handlers.prototype, Backbone.Events, {
                setHandlers: function (handlers) {
                    _.each(handlers, function (handler, name) {
                        var context = null;
                        if (_.isObject(handler) && !_.isFunction(handler)) {
                            context = handler.context;
                            handler = handler.callback;
                        }
                        this.setHandler(name, handler, context);
                    }, this);
                },
                setHandler: function (name, handler, context) {
                    var config = {
                        callback: handler,
                        context: context
                    };
                    this._wreqrHandlers[name] = config;
                    this.trigger('handler:add', name, handler, context);
                },
                hasHandler: function (name) {
                    return !!this._wreqrHandlers[name];
                },
                getHandler: function (name) {
                    var config = this._wreqrHandlers[name];
                    if (!config) {
                        return;
                    }
                    return function () {
                        var args = Array.prototype.slice.apply(arguments);
                        return config.callback.apply(config.context, args);
                    };
                },
                removeHandler: function (name) {
                    delete this._wreqrHandlers[name];
                },
                removeAllHandlers: function () {
                    this._wreqrHandlers = {};
                }
            });
            return Handlers;
        }(Backbone, _);
        Wreqr.CommandStorage = function () {
            'use strict';
            var CommandStorage = function (options) {
                this.options = options;
                this._commands = {};
                if (_.isFunction(this.initialize)) {
                    this.initialize(options);
                }
            };
            _.extend(CommandStorage.prototype, Backbone.Events, {
                getCommands: function (commandName) {
                    var commands = this._commands[commandName];
                    if (!commands) {
                        commands = {
                            command: commandName,
                            instances: []
                        };
                        this._commands[commandName] = commands;
                    }
                    return commands;
                },
                addCommand: function (commandName, args) {
                    var command = this.getCommands(commandName);
                    command.instances.push(args);
                },
                clearCommands: function (commandName) {
                    var command = this.getCommands(commandName);
                    command.instances = [];
                }
            });
            return CommandStorage;
        }();
        Wreqr.Commands = function (Wreqr) {
            'use strict';
            return Wreqr.Handlers.extend({
                storageType: Wreqr.CommandStorage,
                constructor: function (options) {
                    this.options = options || {};
                    this._initializeStorage(this.options);
                    this.on('handler:add', this._executeCommands, this);
                    var args = Array.prototype.slice.call(arguments);
                    Wreqr.Handlers.prototype.constructor.apply(this, args);
                },
                execute: function (name, args) {
                    name = arguments[0];
                    args = Array.prototype.slice.call(arguments, 1);
                    if (this.hasHandler(name)) {
                        this.getHandler(name).apply(this, args);
                    } else {
                        this.storage.addCommand(name, args);
                    }
                },
                _executeCommands: function (name, handler, context) {
                    var command = this.storage.getCommands(name);
                    _.each(command.instances, function (args) {
                        handler.apply(context, args);
                    });
                    this.storage.clearCommands(name);
                },
                _initializeStorage: function (options) {
                    var storage;
                    var StorageType = options.storageType || this.storageType;
                    if (_.isFunction(StorageType)) {
                        storage = new StorageType();
                    } else {
                        storage = StorageType;
                    }
                    this.storage = storage;
                }
            });
        }(Wreqr);
        Wreqr.RequestResponse = function (Wreqr) {
            'use strict';
            return Wreqr.Handlers.extend({
                request: function () {
                    var name = arguments[0];
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (this.hasHandler(name)) {
                        return this.getHandler(name).apply(this, args);
                    }
                }
            });
        }(Wreqr);
        Wreqr.EventAggregator = function (Backbone, _) {
            'use strict';
            var EA = function () {
            };
            EA.extend = Backbone.Model.extend;
            _.extend(EA.prototype, Backbone.Events);
            return EA;
        }(Backbone, _);
        Wreqr.Channel = function (Wreqr) {
            'use strict';
            var Channel = function (channelName) {
                this.vent = new Backbone.Wreqr.EventAggregator();
                this.reqres = new Backbone.Wreqr.RequestResponse();
                this.commands = new Backbone.Wreqr.Commands();
                this.channelName = channelName;
            };
            _.extend(Channel.prototype, {
                reset: function () {
                    this.vent.off();
                    this.vent.stopListening();
                    this.reqres.removeAllHandlers();
                    this.commands.removeAllHandlers();
                    return this;
                },
                connectEvents: function (hash, context) {
                    this._connect('vent', hash, context);
                    return this;
                },
                connectCommands: function (hash, context) {
                    this._connect('commands', hash, context);
                    return this;
                },
                connectRequests: function (hash, context) {
                    this._connect('reqres', hash, context);
                    return this;
                },
                _connect: function (type, hash, context) {
                    if (!hash) {
                        return;
                    }
                    context = context || this;
                    var method = type === 'vent' ? 'on' : 'setHandler';
                    _.each(hash, function (fn, eventName) {
                        this[type][method](eventName, _.bind(fn, context));
                    }, this);
                }
            });
            return Channel;
        }(Wreqr);
        Wreqr.radio = function (Wreqr) {
            'use strict';
            var Radio = function () {
                this._channels = {};
                this.vent = {};
                this.commands = {};
                this.reqres = {};
                this._proxyMethods();
            };
            _.extend(Radio.prototype, {
                channel: function (channelName) {
                    if (!channelName) {
                        throw new Error('Channel must receive a name');
                    }
                    return this._getChannel(channelName);
                },
                _getChannel: function (channelName) {
                    var channel = this._channels[channelName];
                    if (!channel) {
                        channel = new Wreqr.Channel(channelName);
                        this._channels[channelName] = channel;
                    }
                    return channel;
                },
                _proxyMethods: function () {
                    _.each([
                        'vent',
                        'commands',
                        'reqres'
                    ], function (system) {
                        _.each(messageSystems[system], function (method) {
                            this[system][method] = proxyMethod(this, system, method);
                        }, this);
                    }, this);
                }
            });
            var messageSystems = {
                vent: [
                    'on',
                    'off',
                    'trigger',
                    'once',
                    'stopListening',
                    'listenTo',
                    'listenToOnce'
                ],
                commands: [
                    'execute',
                    'setHandler',
                    'setHandlers',
                    'removeHandler',
                    'removeAllHandlers'
                ],
                reqres: [
                    'request',
                    'setHandler',
                    'setHandlers',
                    'removeHandler',
                    'removeAllHandlers'
                ]
            };
            var proxyMethod = function (radio, system, method) {
                return function (channelName) {
                    var messageSystem = radio._getChannel(channelName)[system];
                    var args = Array.prototype.slice.call(arguments, 1);
                    return messageSystem[method].apply(messageSystem, args);
                };
            };
            return new Radio();
        }(Wreqr);
        return Backbone.Wreqr;
    }(Backbone, _));
    var previousMarionette = root.Marionette;
    var Marionette = Backbone.Marionette = {};
    Marionette.VERSION = '2.0.3';
    Marionette.noConflict = function () {
        root.Marionette = previousMarionette;
        return this;
    };
    Backbone.Marionette = Marionette;
    Marionette.Deferred = Backbone.$.Deferred;
    var slice = Array.prototype.slice;
    function throwError(message, name) {
        var error = new Error(message);
        error.name = name || 'Error';
        throw error;
    }
    Marionette.extend = Backbone.Model.extend;
    Marionette.getOption = function (target, optionName) {
        if (!target || !optionName) {
            return;
        }
        var value;
        if (target.options && target.options[optionName] !== undefined) {
            value = target.options[optionName];
        } else {
            value = target[optionName];
        }
        return value;
    };
    Marionette.proxyGetOption = function (optionName) {
        return Marionette.getOption(this, optionName);
    };
    Marionette.normalizeMethods = function (hash) {
        var normalizedHash = {}, method;
        _.each(hash, function (fn, name) {
            method = fn;
            if (!_.isFunction(method)) {
                method = this[method];
            }
            if (!method) {
                return;
            }
            normalizedHash[name] = method;
        }, this);
        return normalizedHash;
    };
    Marionette.normalizeUIKeys = function (hash, ui) {
        if (typeof hash === 'undefined') {
            return;
        }
        _.each(_.keys(hash), function (v) {
            var pattern = /@ui.[a-zA-Z_$0-9]*/g;
            if (v.match(pattern)) {
                hash[v.replace(pattern, function (r) {
                    return ui[r.slice(4)];
                })] = hash[v];
                delete hash[v];
            }
        });
        return hash;
    };
    Marionette.actAsCollection = function (object, listProperty) {
        var methods = [
            'forEach',
            'each',
            'map',
            'find',
            'detect',
            'filter',
            'select',
            'reject',
            'every',
            'all',
            'some',
            'any',
            'include',
            'contains',
            'invoke',
            'toArray',
            'first',
            'initial',
            'rest',
            'last',
            'without',
            'isEmpty',
            'pluck'
        ];
        _.each(methods, function (method) {
            object[method] = function () {
                var list = _.values(_.result(this, listProperty));
                var args = [list].concat(_.toArray(arguments));
                return _[method].apply(_, args);
            };
        });
    };
    Marionette.triggerMethod = function () {
        var splitter = /(^|:)(\w)/gi;
        function getEventName(match, prefix, eventName) {
            return eventName.toUpperCase();
        }
        var triggerMethod = function (event) {
            var methodName = 'on' + event.replace(splitter, getEventName);
            var method = this[methodName];
            var result;
            if (_.isFunction(method)) {
                result = method.apply(this, _.tail(arguments));
            }
            if (_.isFunction(this.trigger)) {
                this.trigger.apply(this, arguments);
            }
            return result;
        };
        return triggerMethod;
    }();
    Marionette.MonitorDOMRefresh = function (documentElement) {
        function handleShow(view) {
            view._isShown = true;
            triggerDOMRefresh(view);
        }
        function handleRender(view) {
            view._isRendered = true;
            triggerDOMRefresh(view);
        }
        function triggerDOMRefresh(view) {
            if (view._isShown && view._isRendered && isInDOM(view)) {
                if (_.isFunction(view.triggerMethod)) {
                    view.triggerMethod('dom:refresh');
                }
            }
        }
        function isInDOM(view) {
            return documentElement.contains(view.el);
        }
        return function (view) {
            view.listenTo(view, 'show', function () {
                handleShow(view);
            });
            view.listenTo(view, 'render', function () {
                handleRender(view);
            });
        };
    }(document.documentElement);
    (function (Marionette) {
        'use strict';
        function bindFromStrings(target, entity, evt, methods) {
            var methodNames = methods.split(/\s+/);
            _.each(methodNames, function (methodName) {
                var method = target[methodName];
                if (!method) {
                    throwError('Method "' + methodName + '" was configured as an event handler, but does not exist.');
                }
                target.listenTo(entity, evt, method);
            });
        }
        function bindToFunction(target, entity, evt, method) {
            target.listenTo(entity, evt, method);
        }
        function unbindFromStrings(target, entity, evt, methods) {
            var methodNames = methods.split(/\s+/);
            _.each(methodNames, function (methodName) {
                var method = target[methodName];
                target.stopListening(entity, evt, method);
            });
        }
        function unbindToFunction(target, entity, evt, method) {
            target.stopListening(entity, evt, method);
        }
        function iterateEvents(target, entity, bindings, functionCallback, stringCallback) {
            if (!entity || !bindings) {
                return;
            }
            if (_.isFunction(bindings)) {
                bindings = bindings.call(target);
            }
            _.each(bindings, function (methods, evt) {
                if (_.isFunction(methods)) {
                    functionCallback(target, entity, evt, methods);
                } else {
                    stringCallback(target, entity, evt, methods);
                }
            });
        }
        Marionette.bindEntityEvents = function (target, entity, bindings) {
            iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);
        };
        Marionette.unbindEntityEvents = function (target, entity, bindings) {
            iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);
        };
        Marionette.proxyBindEntityEvents = function (entity, bindings) {
            return Marionette.bindEntityEvents(this, entity, bindings);
        };
        Marionette.proxyUnbindEntityEvents = function (entity, bindings) {
            return Marionette.unbindEntityEvents(this, entity, bindings);
        };
    }(Marionette));
    Marionette.Callbacks = function () {
        this._deferred = Marionette.Deferred();
        this._callbacks = [];
    };
    _.extend(Marionette.Callbacks.prototype, {
        add: function (callback, contextOverride) {
            var promise = _.result(this._deferred, 'promise');
            this._callbacks.push({
                cb: callback,
                ctx: contextOverride
            });
            promise.then(function (args) {
                if (contextOverride) {
                    args.context = contextOverride;
                }
                callback.call(args.context, args.options);
            });
        },
        run: function (options, context) {
            this._deferred.resolve({
                options: options,
                context: context
            });
        },
        reset: function () {
            var callbacks = this._callbacks;
            this._deferred = Marionette.Deferred();
            this._callbacks = [];
            _.each(callbacks, function (cb) {
                this.add(cb.cb, cb.ctx);
            }, this);
        }
    });
    Marionette.Controller = function (options) {
        this.options = options || {};
        if (_.isFunction(this.initialize)) {
            this.initialize(this.options);
        }
    };
    Marionette.Controller.extend = Marionette.extend;
    _.extend(Marionette.Controller.prototype, Backbone.Events, {
        destroy: function () {
            var args = Array.prototype.slice.call(arguments);
            this.triggerMethod.apply(this, ['before:destroy'].concat(args));
            this.triggerMethod.apply(this, ['destroy'].concat(args));
            this.stopListening();
            this.off();
        },
        triggerMethod: Marionette.triggerMethod,
        getOption: Marionette.proxyGetOption
    });
    Marionette.Region = function (options) {
        this.options = options || {};
        this.el = this.getOption('el');
        this.el = this.el instanceof Backbone.$ ? this.el[0] : this.el;
        if (!this.el) {
            throwError('An "el" must be specified for a region.', 'NoElError');
        }
        this.$el = this.getEl(this.el);
        if (this.initialize) {
            var args = Array.prototype.slice.apply(arguments);
            this.initialize.apply(this, args);
        }
    };
    _.extend(Marionette.Region, {
        buildRegion: function (regionConfig, defaultRegionClass) {
            var regionIsString = _.isString(regionConfig);
            var regionSelectorIsString = _.isString(regionConfig.selector);
            var regionClassIsUndefined = _.isUndefined(regionConfig.regionClass);
            var regionIsClass = _.isFunction(regionConfig);
            if (!regionIsClass && !regionIsString && !regionSelectorIsString) {
                throwError('Region must be specified as a Region class,' + 'a selector string or an object with selector property');
            }
            var selector, RegionClass;
            if (regionIsString) {
                selector = regionConfig;
            }
            if (regionConfig.selector) {
                selector = regionConfig.selector;
                delete regionConfig.selector;
            }
            if (regionIsClass) {
                RegionClass = regionConfig;
            }
            if (!regionIsClass && regionClassIsUndefined) {
                RegionClass = defaultRegionClass;
            }
            if (regionConfig.regionClass) {
                RegionClass = regionConfig.regionClass;
                delete regionConfig.regionClass;
            }
            if (regionIsString || regionIsClass) {
                regionConfig = {};
            }
            regionConfig.el = selector;
            var region = new RegionClass(regionConfig);
            if (regionConfig.parentEl) {
                region.getEl = function (el) {
                    if (_.isObject(el)) {
                        return Backbone.$(el);
                    }
                    var parentEl = regionConfig.parentEl;
                    if (_.isFunction(parentEl)) {
                        parentEl = parentEl();
                    }
                    return parentEl.find(el);
                };
            }
            return region;
        }
    });
    _.extend(Marionette.Region.prototype, Backbone.Events, {
        show: function (view, options) {
            this._ensureElement();
            var showOptions = options || {};
            var isDifferentView = view !== this.currentView;
            var preventDestroy = !!showOptions.preventDestroy;
            var forceShow = !!showOptions.forceShow;
            var isChangingView = !!this.currentView;
            var _shouldDestroyView = !preventDestroy && isDifferentView;
            if (_shouldDestroyView) {
                this.empty();
            }
            var _shouldShowView = isDifferentView || forceShow;
            if (_shouldShowView) {
                view.once('destroy', _.bind(this.empty, this));
                view.render();
                if (isChangingView) {
                    this.triggerMethod('before:swap', view);
                }
                this.triggerMethod('before:show', view);
                if (_.isFunction(view.triggerMethod)) {
                    view.triggerMethod('before:show');
                } else {
                    this.triggerMethod.call(view, 'before:show');
                }
                this.attachHtml(view);
                this.currentView = view;
                if (isChangingView) {
                    this.triggerMethod('swap', view);
                }
                this.triggerMethod('show', view);
                if (_.isFunction(view.triggerMethod)) {
                    view.triggerMethod('show');
                } else {
                    this.triggerMethod.call(view, 'show');
                }
                return this;
            }
            return this;
        },
        _ensureElement: function () {
            if (!_.isObject(this.el)) {
                this.$el = this.getEl(this.el);
                this.el = this.$el[0];
            }
            if (!this.$el || this.$el.length === 0) {
                throwError('An "el" ' + this.$el.selector + ' must exist in DOM');
            }
        },
        getEl: function (el) {
            return Backbone.$(el);
        },
        attachHtml: function (view) {
            this.el.innerHTML = '';
            this.el.appendChild(view.el);
        },
        empty: function () {
            var view = this.currentView;
            if (!view) {
                return;
            }
            this.triggerMethod('before:empty', view);
            this._destroyView();
            this.triggerMethod('empty', view);
            delete this.currentView;
        },
        _destroyView: function () {
            var view = this.currentView;
            if (view.destroy && !view.isDestroyed) {
                view.destroy();
            } else if (view.remove) {
                view.remove();
            }
        },
        attachView: function (view) {
            this.currentView = view;
        },
        reset: function () {
            this.empty();
            if (this.$el) {
                this.el = this.$el.selector;
            }
            delete this.$el;
        },
        getOption: Marionette.proxyGetOption,
        triggerMethod: Marionette.triggerMethod
    });
    Marionette.Region.extend = Marionette.extend;
    Marionette.RegionManager = function (Marionette) {
        var RegionManager = Marionette.Controller.extend({
            constructor: function (options) {
                this._regions = {};
                Marionette.Controller.call(this, options);
            },
            addRegions: function (regionDefinitions, defaults) {
                var regions = {};
                _.each(regionDefinitions, function (definition, name) {
                    if (_.isString(definition)) {
                        definition = { selector: definition };
                    }
                    if (definition.selector) {
                        definition = _.defaults({}, definition, defaults);
                    }
                    var region = this.addRegion(name, definition);
                    regions[name] = region;
                }, this);
                return regions;
            },
            addRegion: function (name, definition) {
                var region;
                var isObject = _.isObject(definition);
                var isString = _.isString(definition);
                var hasSelector = !!definition.selector;
                if (isString || isObject && hasSelector) {
                    region = Marionette.Region.buildRegion(definition, Marionette.Region);
                } else if (_.isFunction(definition)) {
                    region = Marionette.Region.buildRegion(definition, Marionette.Region);
                } else {
                    region = definition;
                }
                this.triggerMethod('before:add:region', name, region);
                this._store(name, region);
                this.triggerMethod('add:region', name, region);
                return region;
            },
            get: function (name) {
                return this._regions[name];
            },
            getRegions: function () {
                return _.clone(this._regions);
            },
            removeRegion: function (name) {
                var region = this._regions[name];
                this._remove(name, region);
            },
            removeRegions: function () {
                _.each(this._regions, function (region, name) {
                    this._remove(name, region);
                }, this);
            },
            emptyRegions: function () {
                _.each(this._regions, function (region) {
                    region.empty();
                }, this);
            },
            destroy: function () {
                this.removeRegions();
                Marionette.Controller.prototype.destroy.apply(this, arguments);
            },
            _store: function (name, region) {
                this._regions[name] = region;
                this._setLength();
            },
            _remove: function (name, region) {
                this.triggerMethod('before:remove:region', name, region);
                region.empty();
                region.stopListening();
                delete this._regions[name];
                this._setLength();
                this.triggerMethod('remove:region', name, region);
            },
            _setLength: function () {
                this.length = _.size(this._regions);
            }
        });
        Marionette.actAsCollection(RegionManager.prototype, '_regions');
        return RegionManager;
    }(Marionette);
    Marionette.TemplateCache = function (templateId) {
        this.templateId = templateId;
    };
    _.extend(Marionette.TemplateCache, {
        templateCaches: {},
        get: function (templateId) {
            var cachedTemplate = this.templateCaches[templateId];
            if (!cachedTemplate) {
                cachedTemplate = new Marionette.TemplateCache(templateId);
                this.templateCaches[templateId] = cachedTemplate;
            }
            return cachedTemplate.load();
        },
        clear: function () {
            var i;
            var args = slice.call(arguments);
            var length = args.length;
            if (length > 0) {
                for (i = 0; i < length; i++) {
                    delete this.templateCaches[args[i]];
                }
            } else {
                this.templateCaches = {};
            }
        }
    });
    _.extend(Marionette.TemplateCache.prototype, {
        load: function () {
            if (this.compiledTemplate) {
                return this.compiledTemplate;
            }
            var template = this.loadTemplate(this.templateId);
            this.compiledTemplate = this.compileTemplate(template);
            return this.compiledTemplate;
        },
        loadTemplate: function (templateId) {
            var template = Backbone.$(templateId).html();
            if (!template || template.length === 0) {
                throwError('Could not find template: "' + templateId + '"', 'NoTemplateError');
            }
            return template;
        },
        compileTemplate: function (rawTemplate) {
            return _.template(rawTemplate);
        }
    });
    Marionette.Renderer = {
        render: function (template, data) {
            if (!template) {
                throwError('Cannot render the template since its false, null or undefined.', 'TemplateNotFoundError');
            }
            var templateFunc;
            if (typeof template === 'function') {
                templateFunc = template;
            } else {
                templateFunc = Marionette.TemplateCache.get(template);
            }
            return templateFunc(data);
        }
    };
    Marionette.View = Backbone.View.extend({
        constructor: function (options) {
            _.bindAll(this, 'render');
            this.options = _.extend({}, _.result(this, 'options'), _.isFunction(options) ? options.call(this) : options);
            this.events = this.normalizeUIKeys(_.result(this, 'events'));
            if (_.isObject(this.behaviors)) {
                new Marionette.Behaviors(this);
            }
            Backbone.View.apply(this, arguments);
            Marionette.MonitorDOMRefresh(this);
            this.listenTo(this, 'show', this.onShowCalled);
        },
        getTemplate: function () {
            return this.getOption('template');
        },
        mixinTemplateHelpers: function (target) {
            target = target || {};
            var templateHelpers = this.getOption('templateHelpers');
            if (_.isFunction(templateHelpers)) {
                templateHelpers = templateHelpers.call(this);
            }
            return _.extend(target, templateHelpers);
        },
        normalizeUIKeys: function (hash) {
            var ui = _.result(this, 'ui');
            var uiBindings = _.result(this, '_uiBindings');
            return Marionette.normalizeUIKeys(hash, uiBindings || ui);
        },
        configureTriggers: function () {
            if (!this.triggers) {
                return;
            }
            var triggerEvents = {};
            var triggers = this.normalizeUIKeys(_.result(this, 'triggers'));
            _.each(triggers, function (value, key) {
                var hasOptions = _.isObject(value);
                var eventName = hasOptions ? value.event : value;
                triggerEvents[key] = function (e) {
                    if (e) {
                        var prevent = e.preventDefault;
                        var stop = e.stopPropagation;
                        var shouldPrevent = hasOptions ? value.preventDefault : prevent;
                        var shouldStop = hasOptions ? value.stopPropagation : stop;
                        if (shouldPrevent && prevent) {
                            prevent.apply(e);
                        }
                        if (shouldStop && stop) {
                            stop.apply(e);
                        }
                    }
                    var args = {
                        view: this,
                        model: this.model,
                        collection: this.collection
                    };
                    this.triggerMethod(eventName, args);
                };
            }, this);
            return triggerEvents;
        },
        delegateEvents: function (events) {
            this._delegateDOMEvents(events);
            this.bindEntityEvents(this.model, this.getOption('modelEvents'));
            this.bindEntityEvents(this.collection, this.getOption('collectionEvents'));
        },
        _delegateDOMEvents: function (events) {
            events = events || this.events;
            if (_.isFunction(events)) {
                events = events.call(this);
            }
            events = this.normalizeUIKeys(events);
            var combinedEvents = {};
            var behaviorEvents = _.result(this, 'behaviorEvents') || {};
            var triggers = this.configureTriggers();
            _.extend(combinedEvents, behaviorEvents, events, triggers);
            Backbone.View.prototype.delegateEvents.call(this, combinedEvents);
        },
        undelegateEvents: function () {
            var args = Array.prototype.slice.call(arguments);
            Backbone.View.prototype.undelegateEvents.apply(this, args);
            this.unbindEntityEvents(this.model, this.getOption('modelEvents'));
            this.unbindEntityEvents(this.collection, this.getOption('collectionEvents'));
        },
        onShowCalled: function () {
        },
        _ensureViewIsIntact: function () {
            if (this.isDestroyed) {
                var err = new Error('Cannot use a view thats already been destroyed.');
                err.name = 'ViewDestroyedError';
                throw err;
            }
        },
        destroy: function () {
            if (this.isDestroyed) {
                return;
            }
            var args = Array.prototype.slice.call(arguments);
            this.triggerMethod.apply(this, ['before:destroy'].concat(args));
            this.isDestroyed = true;
            this.triggerMethod.apply(this, ['destroy'].concat(args));
            this.unbindUIElements();
            this.remove();
        },
        bindUIElements: function () {
            if (!this.ui) {
                return;
            }
            if (!this._uiBindings) {
                this._uiBindings = this.ui;
            }
            var bindings = _.result(this, '_uiBindings');
            this.ui = {};
            _.each(_.keys(bindings), function (key) {
                var selector = bindings[key];
                this.ui[key] = this.$(selector);
            }, this);
        },
        unbindUIElements: function () {
            if (!this.ui || !this._uiBindings) {
                return;
            }
            _.each(this.ui, function ($el, name) {
                delete this.ui[name];
            }, this);
            this.ui = this._uiBindings;
            delete this._uiBindings;
        },
        triggerMethod: Marionette.triggerMethod,
        normalizeMethods: Marionette.normalizeMethods,
        getOption: Marionette.proxyGetOption,
        bindEntityEvents: Marionette.proxyBindEntityEvents,
        unbindEntityEvents: Marionette.proxyUnbindEntityEvents
    });
    Marionette.ItemView = Marionette.View.extend({
        constructor: function () {
            Marionette.View.apply(this, arguments);
        },
        serializeData: function () {
            var data = {};
            if (this.model) {
                data = this.model.toJSON();
            } else if (this.collection) {
                data = { items: this.collection.toJSON() };
            }
            return data;
        },
        render: function () {
            this._ensureViewIsIntact();
            this.triggerMethod('before:render', this);
            var data = this.serializeData();
            data = this.mixinTemplateHelpers(data);
            var template = this.getTemplate();
            var html = Marionette.Renderer.render(template, data);
            this.attachElContent(html);
            this.bindUIElements();
            this.triggerMethod('render', this);
            return this;
        },
        attachElContent: function (html) {
            this.$el.html(html);
            return this;
        },
        destroy: function () {
            if (this.isDestroyed) {
                return;
            }
            Marionette.View.prototype.destroy.apply(this, arguments);
        }
    });
    Marionette.CollectionView = Marionette.View.extend({
        childViewEventPrefix: 'childview',
        constructor: function (options) {
            var initOptions = options || {};
            this.sort = _.isUndefined(initOptions.sort) ? true : initOptions.sort;
            this._initChildViewStorage();
            Marionette.View.apply(this, arguments);
            this._initialEvents();
            this.initRenderBuffer();
        },
        initRenderBuffer: function () {
            this.elBuffer = document.createDocumentFragment();
            this._bufferedChildren = [];
        },
        startBuffering: function () {
            this.initRenderBuffer();
            this.isBuffering = true;
        },
        endBuffering: function () {
            this.isBuffering = false;
            this._triggerBeforeShowBufferedChildren();
            this.attachBuffer(this, this.elBuffer);
            this._triggerShowBufferedChildren();
            this.initRenderBuffer();
        },
        _triggerBeforeShowBufferedChildren: function () {
            if (this._isShown) {
                _.invoke(this._bufferedChildren, 'triggerMethod', 'before:show');
            }
        },
        _triggerShowBufferedChildren: function () {
            if (this._isShown) {
                _.each(this._bufferedChildren, function (child) {
                    if (_.isFunction(child.triggerMethod)) {
                        child.triggerMethod('show');
                    } else {
                        Marionette.triggerMethod.call(child, 'show');
                    }
                });
                this._bufferedChildren = [];
            }
        },
        _initialEvents: function () {
            if (this.collection) {
                this.listenTo(this.collection, 'add', this._onCollectionAdd);
                this.listenTo(this.collection, 'remove', this._onCollectionRemove);
                this.listenTo(this.collection, 'reset', this.render);
                if (this.sort) {
                    this.listenTo(this.collection, 'sort', this._sortViews);
                }
            }
        },
        _onCollectionAdd: function (child, collection, options) {
            this.destroyEmptyView();
            var ChildView = this.getChildView(child);
            var index = this.collection.indexOf(child);
            this.addChild(child, ChildView, index);
        },
        _onCollectionRemove: function (model) {
            var view = this.children.findByModel(model);
            this.removeChildView(view);
            this.checkEmpty();
        },
        onShowCalled: function () {
            this.children.each(function (child) {
                if (_.isFunction(child.triggerMethod)) {
                    child.triggerMethod('show');
                } else {
                    Marionette.triggerMethod.call(child, 'show');
                }
            });
        },
        render: function () {
            this._ensureViewIsIntact();
            this.triggerMethod('before:render', this);
            this._renderChildren();
            this.triggerMethod('render', this);
            return this;
        },
        _sortViews: function () {
            var orderChanged = this.collection.find(function (item, index) {
                var view = this.children.findByModel(item);
                return view && view._index !== index;
            }, this);
            if (orderChanged) {
                this.render();
            }
        },
        _renderChildren: function () {
            this.destroyEmptyView();
            this.destroyChildren();
            if (this.isEmpty(this.collection)) {
                this.showEmptyView();
            } else {
                this.triggerMethod('before:render:collection', this);
                this.startBuffering();
                this.showCollection();
                this.endBuffering();
                this.triggerMethod('render:collection', this);
            }
        },
        showCollection: function () {
            var ChildView;
            this.collection.each(function (child, index) {
                ChildView = this.getChildView(child);
                this.addChild(child, ChildView, index);
            }, this);
        },
        showEmptyView: function () {
            var EmptyView = this.getEmptyView();
            if (EmptyView && !this._showingEmptyView) {
                this.triggerMethod('before:render:empty');
                this._showingEmptyView = true;
                var model = new Backbone.Model();
                this.addEmptyView(model, EmptyView);
                this.triggerMethod('render:empty');
            }
        },
        destroyEmptyView: function () {
            if (this._showingEmptyView) {
                this.destroyChildren();
                delete this._showingEmptyView;
            }
        },
        getEmptyView: function () {
            return this.getOption('emptyView');
        },
        addEmptyView: function (child, EmptyView) {
            var emptyViewOptions = this.getOption('emptyViewOptions') || this.getOption('childViewOptions');
            if (_.isFunction(emptyViewOptions)) {
                emptyViewOptions = emptyViewOptions.call(this);
            }
            var view = this.buildChildView(child, EmptyView, emptyViewOptions);
            if (this._isShown) {
                this.triggerMethod.call(view, 'before:show');
            }
            this.children.add(view);
            this.renderChildView(view, -1);
            if (this._isShown) {
                this.triggerMethod.call(view, 'show');
            }
        },
        getChildView: function (child) {
            var childView = this.getOption('childView');
            if (!childView) {
                throwError('A "childView" must be specified', 'NoChildViewError');
            }
            return childView;
        },
        addChild: function (child, ChildView, index) {
            var childViewOptions = this.getOption('childViewOptions');
            if (_.isFunction(childViewOptions)) {
                childViewOptions = childViewOptions.call(this, child, index);
            }
            var view = this.buildChildView(child, ChildView, childViewOptions);
            this._updateIndices(view, true, index);
            this._addChildView(view, index);
            return view;
        },
        _updateIndices: function (view, increment, index) {
            if (!this.sort) {
                return;
            }
            if (increment) {
                view._index = index;
                this.children.each(function (laterView) {
                    if (laterView._index >= view._index) {
                        laterView._index++;
                    }
                });
            } else {
                this.children.each(function (laterView) {
                    if (laterView._index >= view._index) {
                        laterView._index--;
                    }
                });
            }
        },
        _addChildView: function (view, index) {
            this.proxyChildEvents(view);
            this.triggerMethod('before:add:child', view);
            this.children.add(view);
            this.renderChildView(view, index);
            if (this._isShown && !this.isBuffering) {
                if (_.isFunction(view.triggerMethod)) {
                    view.triggerMethod('show');
                } else {
                    Marionette.triggerMethod.call(view, 'show');
                }
            }
            this.triggerMethod('add:child', view);
        },
        renderChildView: function (view, index) {
            view.render();
            this.attachHtml(this, view, index);
        },
        buildChildView: function (child, ChildViewClass, childViewOptions) {
            var options = _.extend({ model: child }, childViewOptions);
            return new ChildViewClass(options);
        },
        removeChildView: function (view) {
            if (view) {
                this.triggerMethod('before:remove:child', view);
                if (view.destroy) {
                    view.destroy();
                } else if (view.remove) {
                    view.remove();
                }
                this.stopListening(view);
                this.children.remove(view);
                this.triggerMethod('remove:child', view);
                this._updateIndices(view, false);
            }
        },
        isEmpty: function (collection) {
            return !this.collection || this.collection.length === 0;
        },
        checkEmpty: function () {
            if (this.isEmpty(this.collection)) {
                this.showEmptyView();
            }
        },
        attachBuffer: function (collectionView, buffer) {
            collectionView.$el.append(buffer);
        },
        attachHtml: function (collectionView, childView, index) {
            if (collectionView.isBuffering) {
                collectionView.elBuffer.appendChild(childView.el);
                collectionView._bufferedChildren.push(childView);
            } else {
                if (!collectionView._insertBefore(childView, index)) {
                    collectionView._insertAfter(childView);
                }
            }
        },
        _insertBefore: function (childView, index) {
            var currentView;
            var findPosition = this.sort && index < this.children.length - 1;
            if (findPosition) {
                currentView = this.children.find(function (view) {
                    return view._index === index + 1;
                });
            }
            if (currentView) {
                currentView.$el.before(childView.el);
                return true;
            }
            return false;
        },
        _insertAfter: function (childView) {
            this.$el.append(childView.el);
        },
        _initChildViewStorage: function () {
            this.children = new Backbone.ChildViewContainer();
        },
        destroy: function () {
            if (this.isDestroyed) {
                return;
            }
            this.triggerMethod('before:destroy:collection');
            this.destroyChildren();
            this.triggerMethod('destroy:collection');
            Marionette.View.prototype.destroy.apply(this, arguments);
        },
        destroyChildren: function () {
            this.children.each(this.removeChildView, this);
            this.checkEmpty();
        },
        proxyChildEvents: function (view) {
            var prefix = this.getOption('childViewEventPrefix');
            this.listenTo(view, 'all', function () {
                var args = Array.prototype.slice.call(arguments);
                var rootEvent = args[0];
                var childEvents = this.normalizeMethods(_.result(this, 'childEvents'));
                args[0] = prefix + ':' + rootEvent;
                args.splice(1, 0, view);
                if (typeof childEvents !== 'undefined' && _.isFunction(childEvents[rootEvent])) {
                    childEvents[rootEvent].apply(this, args.slice(1));
                }
                this.triggerMethod.apply(this, args);
            }, this);
        }
    });
    Marionette.CompositeView = Marionette.CollectionView.extend({
        constructor: function () {
            Marionette.CollectionView.apply(this, arguments);
        },
        _initialEvents: function () {
            this.once('render', function () {
                if (this.collection) {
                    this.listenTo(this.collection, 'add', this._onCollectionAdd);
                    this.listenTo(this.collection, 'remove', this._onCollectionRemove);
                    this.listenTo(this.collection, 'reset', this._renderChildren);
                    if (this.sort) {
                        this.listenTo(this.collection, 'sort', this._sortViews);
                    }
                }
            });
        },
        getChildView: function (child) {
            var childView = this.getOption('childView') || this.constructor;
            if (!childView) {
                throwError('A "childView" must be specified', 'NoChildViewError');
            }
            return childView;
        },
        serializeData: function () {
            var data = {};
            if (this.model) {
                data = this.model.toJSON();
            }
            return data;
        },
        render: function () {
            this._ensureViewIsIntact();
            this.isRendered = true;
            this.resetChildViewContainer();
            this.triggerMethod('before:render', this);
            this._renderRoot();
            this._renderChildren();
            this.triggerMethod('render', this);
            return this;
        },
        _renderChildren: function () {
            if (this.isRendered) {
                Marionette.CollectionView.prototype._renderChildren.call(this);
            }
        },
        _renderRoot: function () {
            var data = {};
            data = this.serializeData();
            data = this.mixinTemplateHelpers(data);
            this.triggerMethod('before:render:template');
            var template = this.getTemplate();
            var html = Marionette.Renderer.render(template, data);
            this.attachElContent(html);
            this.bindUIElements();
            this.triggerMethod('render:template');
        },
        attachElContent: function (html) {
            this.$el.html(html);
            return this;
        },
        attachBuffer: function (compositeView, buffer) {
            var $container = this.getChildViewContainer(compositeView);
            $container.append(buffer);
        },
        _insertAfter: function (childView) {
            var $container = this.getChildViewContainer(this);
            $container.append(childView.el);
        },
        getChildViewContainer: function (containerView) {
            if ('$childViewContainer' in containerView) {
                return containerView.$childViewContainer;
            }
            var container;
            var childViewContainer = Marionette.getOption(containerView, 'childViewContainer');
            if (childViewContainer) {
                var selector = _.isFunction(childViewContainer) ? childViewContainer.call(containerView) : childViewContainer;
                if (selector.charAt(0) === '@' && containerView.ui) {
                    container = containerView.ui[selector.substr(4)];
                } else {
                    container = containerView.$(selector);
                }
                if (container.length <= 0) {
                    throwError('The specified "childViewContainer" was not found: ' + containerView.childViewContainer, 'ChildViewContainerMissingError');
                }
            } else {
                container = containerView.$el;
            }
            containerView.$childViewContainer = container;
            return container;
        },
        resetChildViewContainer: function () {
            if (this.$childViewContainer) {
                delete this.$childViewContainer;
            }
        }
    });
    Marionette.LayoutView = Marionette.ItemView.extend({
        regionClass: Marionette.Region,
        constructor: function (options) {
            options = options || {};
            this._firstRender = true;
            this._initializeRegions(options);
            Marionette.ItemView.call(this, options);
        },
        render: function () {
            this._ensureViewIsIntact();
            if (this._firstRender) {
                this._firstRender = false;
            } else {
                this._reInitializeRegions();
            }
            return Marionette.ItemView.prototype.render.apply(this, arguments);
        },
        destroy: function () {
            if (this.isDestroyed) {
                return;
            }
            this.regionManager.destroy();
            Marionette.ItemView.prototype.destroy.apply(this, arguments);
        },
        addRegion: function (name, definition) {
            this.triggerMethod('before:region:add', name);
            var regions = {};
            regions[name] = definition;
            return this._buildRegions(regions)[name];
        },
        addRegions: function (regions) {
            this.regions = _.extend({}, this.regions, regions);
            return this._buildRegions(regions);
        },
        removeRegion: function (name) {
            this.triggerMethod('before:region:remove', name);
            delete this.regions[name];
            return this.regionManager.removeRegion(name);
        },
        getRegion: function (region) {
            return this.regionManager.get(region);
        },
        getRegions: function () {
            return this.regionManager.getRegions();
        },
        _buildRegions: function (regions) {
            var that = this;
            var defaults = {
                regionClass: this.getOption('regionClass'),
                parentEl: function () {
                    return that.$el;
                }
            };
            return this.regionManager.addRegions(regions, defaults);
        },
        _initializeRegions: function (options) {
            var regions;
            this._initRegionManager();
            if (_.isFunction(this.regions)) {
                regions = this.regions(options);
            } else {
                regions = this.regions || {};
            }
            var regionOptions = this.getOption.call(options, 'regions');
            if (_.isFunction(regionOptions)) {
                regionOptions = regionOptions.call(this, options);
            }
            _.extend(regions, regionOptions);
            this.addRegions(regions);
        },
        _reInitializeRegions: function () {
            this.regionManager.emptyRegions();
            this.regionManager.each(function (region) {
                region.reset();
            });
        },
        getRegionManager: function () {
            return new Marionette.RegionManager();
        },
        _initRegionManager: function () {
            this.regionManager = this.getRegionManager();
            this.listenTo(this.regionManager, 'before:add:region', function (name) {
                this.triggerMethod('before:add:region', name);
            });
            this.listenTo(this.regionManager, 'add:region', function (name, region) {
                this[name] = region;
                this.triggerMethod('add:region', name, region);
            });
            this.listenTo(this.regionManager, 'before:remove:region', function (name) {
                this.triggerMethod('before:remove:region', name);
            });
            this.listenTo(this.regionManager, 'remove:region', function (name, region) {
                delete this[name];
                this.triggerMethod('remove:region', name, region);
            });
        }
    });
    Marionette.Behavior = function (_, Backbone) {
        function Behavior(options, view) {
            this.view = view;
            this.defaults = _.result(this, 'defaults') || {};
            this.options = _.extend({}, this.defaults, options);
            this.$ = function () {
                return this.view.$.apply(this.view, arguments);
            };
            this.initialize.apply(this, arguments);
        }
        _.extend(Behavior.prototype, Backbone.Events, {
            initialize: function () {
            },
            destroy: function () {
                this.stopListening();
            },
            triggerMethod: Marionette.triggerMethod,
            getOption: Marionette.proxyGetOption,
            bindEntityEvents: Marionette.proxyBindEntityEvents,
            unbindEntityEvents: Marionette.proxyUnbindEntityEvents
        });
        Behavior.extend = Marionette.extend;
        return Behavior;
    }(_, Backbone);
    Marionette.Behaviors = function (Marionette, _) {
        function Behaviors(view, behaviors) {
            behaviors = Behaviors.parseBehaviors(view, behaviors || _.result(view, 'behaviors'));
            Behaviors.wrap(view, behaviors, _.keys(methods));
        }
        var methods = {
            setElement: function (setElement, behaviors) {
                setElement.apply(this, _.tail(arguments, 2));
                _.each(behaviors, function (b) {
                    b.$el = this.$el;
                }, this);
            },
            destroy: function (destroy, behaviors) {
                var args = _.tail(arguments, 2);
                destroy.apply(this, args);
                _.invoke(behaviors, 'destroy', args);
            },
            bindUIElements: function (bindUIElements, behaviors) {
                bindUIElements.apply(this);
                _.invoke(behaviors, bindUIElements);
            },
            unbindUIElements: function (unbindUIElements, behaviors) {
                unbindUIElements.apply(this);
                _.invoke(behaviors, unbindUIElements);
            },
            triggerMethod: function (triggerMethod, behaviors) {
                var args = _.tail(arguments, 2);
                triggerMethod.apply(this, args);
                _.each(behaviors, function (b) {
                    triggerMethod.apply(b, args);
                });
            },
            delegateEvents: function (delegateEvents, behaviors) {
                var args = _.tail(arguments, 2);
                delegateEvents.apply(this, args);
                _.each(behaviors, function (b) {
                    Marionette.bindEntityEvents(b, this.model, Marionette.getOption(b, 'modelEvents'));
                    Marionette.bindEntityEvents(b, this.collection, Marionette.getOption(b, 'collectionEvents'));
                }, this);
            },
            undelegateEvents: function (undelegateEvents, behaviors) {
                var args = _.tail(arguments, 2);
                undelegateEvents.apply(this, args);
                _.each(behaviors, function (b) {
                    Marionette.unbindEntityEvents(b, this.model, Marionette.getOption(b, 'modelEvents'));
                    Marionette.unbindEntityEvents(b, this.collection, Marionette.getOption(b, 'collectionEvents'));
                }, this);
            },
            behaviorEvents: function (behaviorEvents, behaviors) {
                var _behaviorsEvents = {};
                var viewUI = _.result(this, 'ui');
                _.each(behaviors, function (b, i) {
                    var _events = {};
                    var behaviorEvents = _.clone(_.result(b, 'events')) || {};
                    var behaviorUI = _.result(b, 'ui');
                    var ui = _.extend({}, viewUI, behaviorUI);
                    behaviorEvents = Marionette.normalizeUIKeys(behaviorEvents, ui);
                    _.each(_.keys(behaviorEvents), function (key) {
                        var whitespace = new Array(i + 2).join(' ');
                        var eventKey = key + whitespace;
                        var handler = _.isFunction(behaviorEvents[key]) ? behaviorEvents[key] : b[behaviorEvents[key]];
                        _events[eventKey] = _.bind(handler, b);
                    });
                    _behaviorsEvents = _.extend(_behaviorsEvents, _events);
                });
                return _behaviorsEvents;
            }
        };
        _.extend(Behaviors, {
            behaviorsLookup: function () {
                throw new Error('You must define where your behaviors are stored.' + 'See https://github.com/marionettejs/backbone.marionette' + '/blob/master/docs/marionette.behaviors.md#behaviorslookup');
            },
            getBehaviorClass: function (options, key) {
                if (options.behaviorClass) {
                    return options.behaviorClass;
                }
                return _.isFunction(Behaviors.behaviorsLookup) ? Behaviors.behaviorsLookup.apply(this, arguments)[key] : Behaviors.behaviorsLookup[key];
            },
            parseBehaviors: function (view, behaviors) {
                return _.chain(behaviors).map(function (options, key) {
                    var BehaviorClass = Behaviors.getBehaviorClass(options, key);
                    var behavior = new BehaviorClass(options, view);
                    var nestedBehaviors = Behaviors.parseBehaviors(view, _.result(behavior, 'behaviors'));
                    return [behavior].concat(nestedBehaviors);
                }).flatten().value();
            },
            wrap: function (view, behaviors, methodNames) {
                _.each(methodNames, function (methodName) {
                    view[methodName] = _.partial(methods[methodName], view[methodName], behaviors);
                });
            }
        });
        return Behaviors;
    }(Marionette, _);
    Marionette.AppRouter = Backbone.Router.extend({
        constructor: function (options) {
            Backbone.Router.apply(this, arguments);
            this.options = options || {};
            var appRoutes = this.getOption('appRoutes');
            var controller = this._getController();
            this.processAppRoutes(controller, appRoutes);
            this.on('route', this._processOnRoute, this);
        },
        appRoute: function (route, methodName) {
            var controller = this._getController();
            this._addAppRoute(controller, route, methodName);
        },
        _processOnRoute: function (routeName, routeArgs) {
            var routePath = _.invert(this.appRoutes)[routeName];
            if (_.isFunction(this.onRoute)) {
                this.onRoute(routeName, routePath, routeArgs);
            }
        },
        processAppRoutes: function (controller, appRoutes) {
            if (!appRoutes) {
                return;
            }
            var routeNames = _.keys(appRoutes).reverse();
            _.each(routeNames, function (route) {
                this._addAppRoute(controller, route, appRoutes[route]);
            }, this);
        },
        _getController: function () {
            return this.getOption('controller');
        },
        _addAppRoute: function (controller, route, methodName) {
            var method = controller[methodName];
            if (!method) {
                throwError('Method "' + methodName + '" was not found on the controller');
            }
            this.route(route, methodName, _.bind(method, controller));
        },
        getOption: Marionette.proxyGetOption
    });
    Marionette.Application = function (options) {
        this._initRegionManager();
        this._initCallbacks = new Marionette.Callbacks();
        var globalCh = Backbone.Wreqr.radio.channel('global');
        this.vent = globalCh.vent;
        this.commands = globalCh.commands;
        this.reqres = globalCh.reqres;
        this.submodules = {};
        _.extend(this, options);
    };
    _.extend(Marionette.Application.prototype, Backbone.Events, {
        execute: function () {
            this.commands.execute.apply(this.commands, arguments);
        },
        request: function () {
            return this.reqres.request.apply(this.reqres, arguments);
        },
        addInitializer: function (initializer) {
            this._initCallbacks.add(initializer);
        },
        start: function (options) {
            this.triggerMethod('before:start', options);
            this._initCallbacks.run(options, this);
            this.triggerMethod('start', options);
        },
        addRegions: function (regions) {
            return this._regionManager.addRegions(regions);
        },
        emptyRegions: function () {
            this._regionManager.emptyRegions();
        },
        removeRegion: function (region) {
            this._regionManager.removeRegion(region);
        },
        getRegion: function (region) {
            return this._regionManager.get(region);
        },
        getRegions: function () {
            return this._regionManager.getRegions();
        },
        module: function (moduleNames, moduleDefinition) {
            var ModuleClass = Marionette.Module.getClass(moduleDefinition);
            var args = slice.call(arguments);
            args.unshift(this);
            return ModuleClass.create.apply(ModuleClass, args);
        },
        _initRegionManager: function () {
            this._regionManager = new Marionette.RegionManager();
            this.listenTo(this._regionManager, 'before:add:region', function (name) {
                this.triggerMethod('before:add:region', name);
            });
            this.listenTo(this._regionManager, 'add:region', function (name, region) {
                this[name] = region;
                this.triggerMethod('add:region', name, region);
            });
            this.listenTo(this._regionManager, 'before:remove:region', function (name) {
                this.triggerMethod('before:remove:region', name);
            });
            this.listenTo(this._regionManager, 'remove:region', function (name, region) {
                delete this[name];
                this.triggerMethod('remove:region', name, region);
            });
        },
        triggerMethod: Marionette.triggerMethod
    });
    Marionette.Application.extend = Marionette.extend;
    Marionette.Module = function (moduleName, app, options) {
        this.moduleName = moduleName;
        this.options = _.extend({}, this.options, options);
        this.initialize = options.initialize || this.initialize;
        this.submodules = {};
        this._setupInitializersAndFinalizers();
        this.app = app;
        this.startWithParent = true;
        if (_.isFunction(this.initialize)) {
            this.initialize(moduleName, app, this.options);
        }
    };
    Marionette.Module.extend = Marionette.extend;
    _.extend(Marionette.Module.prototype, Backbone.Events, {
        initialize: function () {
        },
        addInitializer: function (callback) {
            this._initializerCallbacks.add(callback);
        },
        addFinalizer: function (callback) {
            this._finalizerCallbacks.add(callback);
        },
        start: function (options) {
            if (this._isInitialized) {
                return;
            }
            _.each(this.submodules, function (mod) {
                if (mod.startWithParent) {
                    mod.start(options);
                }
            });
            this.triggerMethod('before:start', options);
            this._initializerCallbacks.run(options, this);
            this._isInitialized = true;
            this.triggerMethod('start', options);
        },
        stop: function () {
            if (!this._isInitialized) {
                return;
            }
            this._isInitialized = false;
            this.triggerMethod('before:stop');
            _.each(this.submodules, function (mod) {
                mod.stop();
            });
            this._finalizerCallbacks.run(undefined, this);
            this._initializerCallbacks.reset();
            this._finalizerCallbacks.reset();
            this.triggerMethod('stop');
        },
        addDefinition: function (moduleDefinition, customArgs) {
            this._runModuleDefinition(moduleDefinition, customArgs);
        },
        _runModuleDefinition: function (definition, customArgs) {
            if (!definition) {
                return;
            }
            var args = _.flatten([
                this,
                this.app,
                Backbone,
                Marionette,
                Backbone.$,
                _,
                customArgs
            ]);
            definition.apply(this, args);
        },
        _setupInitializersAndFinalizers: function () {
            this._initializerCallbacks = new Marionette.Callbacks();
            this._finalizerCallbacks = new Marionette.Callbacks();
        },
        triggerMethod: Marionette.triggerMethod
    });
    _.extend(Marionette.Module, {
        create: function (app, moduleNames, moduleDefinition) {
            var module = app;
            var customArgs = slice.call(arguments);
            customArgs.splice(0, 3);
            moduleNames = moduleNames.split('.');
            var length = moduleNames.length;
            var moduleDefinitions = [];
            moduleDefinitions[length - 1] = moduleDefinition;
            _.each(moduleNames, function (moduleName, i) {
                var parentModule = module;
                module = this._getModule(parentModule, moduleName, app, moduleDefinition);
                this._addModuleDefinition(parentModule, module, moduleDefinitions[i], customArgs);
            }, this);
            return module;
        },
        _getModule: function (parentModule, moduleName, app, def, args) {
            var options = _.extend({}, def);
            var ModuleClass = this.getClass(def);
            var module = parentModule[moduleName];
            if (!module) {
                module = new ModuleClass(moduleName, app, options);
                parentModule[moduleName] = module;
                parentModule.submodules[moduleName] = module;
            }
            return module;
        },
        getClass: function (moduleDefinition) {
            var ModuleClass = Marionette.Module;
            if (!moduleDefinition) {
                return ModuleClass;
            }
            if (moduleDefinition.prototype instanceof ModuleClass) {
                return moduleDefinition;
            }
            return moduleDefinition.moduleClass || ModuleClass;
        },
        _addModuleDefinition: function (parentModule, module, def, args) {
            var fn = this._getDefine(def);
            var startWithParent = this._getStartWithParent(def, module);
            if (fn) {
                module.addDefinition(fn, args);
            }
            this._addStartWithParent(parentModule, module, startWithParent);
        },
        _getStartWithParent: function (def, module) {
            var swp;
            if (_.isFunction(def) && def.prototype instanceof Marionette.Module) {
                swp = module.constructor.prototype.startWithParent;
                return _.isUndefined(swp) ? true : swp;
            }
            if (_.isObject(def)) {
                swp = def.startWithParent;
                return _.isUndefined(swp) ? true : swp;
            }
            return true;
        },
        _getDefine: function (def) {
            if (_.isFunction(def) && !(def.prototype instanceof Marionette.Module)) {
                return def;
            }
            if (_.isObject(def)) {
                return def.define;
            }
            return null;
        },
        _addStartWithParent: function (parentModule, module, startWithParent) {
            module.startWithParent = module.startWithParent && startWithParent;
            if (!module.startWithParent || !!module.startWithParentIsConfigured) {
                return;
            }
            module.startWithParentIsConfigured = true;
            parentModule.addInitializer(function (options) {
                if (module.startWithParent) {
                    module.start(options);
                }
            });
        }
    });
    return Marionette;
}));
(function () {
    var __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, __slice = [].slice;
    define('lib/uber_router', [
        'jquery',
        'backbone'
    ], function ($, Backbone) {
        var UberRouter;
        return UberRouter = function (_super) {
            __extends(UberRouter, _super);
            function UberRouter() {
                return UberRouter.__super__.constructor.apply(this, arguments);
            }
            UberRouter.prototype.whitelist = [];
            UberRouter.prototype.initialize = function () {
                this.$rootEl = $(this.rootSelector);
                this.$navbarEl = $(this.navbarSelector);
                this.activeViews = null;
                return this.handlePageLinks();
            };
            UberRouter.prototype.changeView = function () {
                var view, views, _i, _j, _len, _len1, _ref;
                views = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                if (this.activeViews) {
                    _ref = this.activeViews;
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        view = _ref[_i];
                        if (view.close) {
                            view.close();
                        } else {
                            view.remove();
                        }
                    }
                } else {
                    this.$rootEl.empty();
                }
                this.activeViews = views;
                for (_j = 0, _len1 = views.length; _j < _len1; _j++) {
                    view = views[_j];
                    this.$rootEl.append(view.render().el);
                }
            };
            UberRouter.prototype.changeTitle = function (title) {
                window.document.title = title;
            };
            UberRouter.prototype.changeActiveNavbarItem = function (url) {
                this.$navbarEl.find('.active').removeClass('active');
                if (url) {
                    this.$navbarEl.find('a[href="' + url + '"]').closest('li').addClass('active');
                }
            };
            UberRouter.prototype.handlePageLinks = function () {
                return $(document).on('click', 'a', function (_this) {
                    return function (evt) {
                        var regex, route, url, urlWithoutSlash;
                        url = $(evt.currentTarget).attr('href');
                        if (url === '#') {
                            return;
                        }
                        if (evt.metaKey) {
                            return;
                        }
                        if (evt.currentTarget.target !== '') {
                            return;
                        }
                        if (_.contains(_this.whitelist, url) || url.indexOf('http') === 0) {
                            return;
                        }
                        urlWithoutSlash = url.slice(1);
                        for (route in _this.routes) {
                            regex = _this._routeToRegExp(route);
                            if (regex.test(urlWithoutSlash)) {
                                evt.preventDefault();
                                _this.navigate(url, { trigger: true });
                                return;
                            }
                        }
                    };
                }(this));
            };
            return UberRouter;
        }(Backbone.Router);
    });
}.call(this));
(function () {
    var __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };
    define('router', [
        'jquery',
        'backbone',
        'lib/uber_router'
    ], function ($, Backbone, UberRouter) {
        var Router;
        return Router = function (_super) {
            __extends(Router, _super);
            function Router() {
                return Router.__super__.constructor.apply(this, arguments);
            }
            Router.prototype.rootSelector = '#main';
            Router.prototype.navbarSelector = '#navbar';
            Router.prototype.routes = {
                '': 'home',
                'panel/:panel_number': 'panel'
            };
            Router.prototype.whitelist = [];
            Router.prototype.panel = function (number) {
                return app.view.setActive(number);
            };
            return Router;
        }(UberRouter);
    });
}.call(this));
(function (window, document, exportName, undefined) {
    'use strict';
    var VENDOR_PREFIXES = [
        '',
        'webkit',
        'moz',
        'MS',
        'ms',
        'o'
    ];
    var TEST_ELEMENT = document.createElement('div');
    var TYPE_FUNCTION = 'function';
    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }
    function each(obj, iterator, context) {
        var i;
        if (!obj) {
            return;
        }
        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }
    function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || merge && dest[keys[i]] === undefined) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }
    function merge(dest, src) {
        return extend(dest, src, true);
    }
    function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
            extend(childP, properties);
        }
    }
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
        }
        return val;
    }
    function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
    }
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            target.addEventListener(type, handler, false);
        });
    }
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            target.removeEventListener(type, handler, false);
        });
    }
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }
        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }
        return results;
    }
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }
    var _uniqueId = 1;
    function uniqueId() {
        return _uniqueId++;
    }
    function getWindowForElement(element) {
        var doc = element.ownerDocument;
        return doc.defaultView || doc.parentWindow;
    }
    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
    var SUPPORT_TOUCH = 'ontouchstart' in window;
    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
    var INPUT_TYPE_TOUCH = 'touch';
    var INPUT_TYPE_PEN = 'pen';
    var INPUT_TYPE_MOUSE = 'mouse';
    var INPUT_TYPE_KINECT = 'kinect';
    var COMPUTE_INTERVAL = 25;
    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;
    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;
    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
    var PROPS_XY = [
        'x',
        'y'
    ];
    var PROPS_CLIENT_XY = [
        'clientX',
        'clientY'
    ];
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function (ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
                self.handler(ev);
            }
        };
        this.init();
    }
    Input.prototype = {
        handler: function () {
        },
        init: function () {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        destroy: function () {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
    };
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
    }
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
            manager.session = {};
        }
        input.eventType = eventType;
        computeInputData(manager, input);
        manager.emit('hammer.input', input);
        manager.recognize(input);
        manager.session.prevInput = input;
    }
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        computeIntervalInputData(session, input);
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }
    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = last.deltaX - input.deltaX;
            var deltaY = last.deltaY - input.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
        } else {
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }
    function simpleCloneInputData(input) {
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }
        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }
    function getCenter(pointers) {
        var pointersLength = pointers.length;
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }
        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }
        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
            return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
    }
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }
    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };
    var MOUSE_ELEMENT_EVENTS = 'mousedown';
    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.allow = true;
        this.pressed = false;
        Input.apply(this, arguments);
    }
    inherit(MouseInput, Input, {
        handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type];
            if (eventType & INPUT_START && ev.button === 0) {
                this.pressed = true;
            }
            if (eventType & INPUT_MOVE && ev.which !== 1) {
                eventType = INPUT_END;
            }
            if (!this.pressed || !this.allow) {
                return;
            }
            if (eventType & INPUT_END) {
                this.pressed = false;
            }
            this.callback(this.manager, eventType, {
                pointers: [ev],
                changedPointers: [ev],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            });
        }
    });
    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT
    };
    var POINTER_ELEMENT_EVENTS = 'pointerdown';
    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';
    if (window.MSPointerEvent) {
        POINTER_ELEMENT_EVENTS = 'MSPointerDown';
        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
    }
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
    }
    inherit(PointerEventInput, Input, {
        handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                store.push(ev);
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                removePointer = true;
            }
            var storeIndex = inArray(store, ev.pointerId, 'pointerId');
            if (storeIndex < 0) {
                return;
            }
            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
                pointers: store,
                changedPointers: [ev],
                pointerType: pointerType,
                srcEvent: ev
            });
            if (removePointer) {
                store.splice(storeIndex, 1);
            }
        }
    });
    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
    }
    inherit(TouchInput, Input, {
        handler: function TEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
                return;
            }
            this.callback(this.manager, type, {
                pointers: touches[0],
                changedPointers: touches[1],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            });
        }
    });
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [
                allTouches,
                allTouches
            ];
        }
        var i, targetTouches = toArray(ev.targetTouches), changedTouches = toArray(ev.changedTouches), changedTargetTouches = [];
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }
        if (!changedTargetTouches.length) {
            return;
        }
        return [
            uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
            changedTargetTouches
        ];
    }
    function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
    }
    inherit(TouchMouseInput, Input, {
        handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isTouch) {
                this.mouse.allow = false;
            } else if (isMouse && !this.mouse.allow) {
                return;
            }
            if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
                this.mouse.allow = true;
            }
            this.callback(manager, inputEvent, inputData);
        },
        destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    });
    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
    var TOUCH_ACTION_COMPUTE = 'compute';
    var TOUCH_ACTION_AUTO = 'auto';
    var TOUCH_ACTION_MANIPULATION = 'manipulation';
    var TOUCH_ACTION_NONE = 'none';
    var TOUCH_ACTION_PAN_X = 'pan-x';
    var TOUCH_ACTION_PAN_Y = 'pan-y';
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }
    TouchAction.prototype = {
        set: function (value) {
            if (value == TOUCH_ACTION_COMPUTE) {
                value = this.compute();
            }
            if (NATIVE_TOUCH_ACTION) {
                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
        },
        update: function () {
            this.set(this.manager.options.touchAction);
        },
        compute: function () {
            var actions = [];
            each(this.manager.recognizers, function (recognizer) {
                if (boolOrFn(recognizer.options.enable, [recognizer])) {
                    actions = actions.concat(recognizer.getTouchAction());
                }
            });
            return cleanTouchActions(actions.join(' '));
        },
        preventDefaults: function (input) {
            if (NATIVE_TOUCH_ACTION) {
                return;
            }
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            if (this.manager.session.prevented) {
                srcEvent.preventDefault();
                return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE);
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
                return this.preventSrc(srcEvent);
            }
        },
        preventSrc: function (srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
        }
    };
    function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
        }
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
    }
    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;
    function Recognizer(options) {
        this.id = uniqueId();
        this.manager = null;
        this.options = merge(options || {}, this.defaults);
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
    }
    Recognizer.prototype = {
        defaults: {},
        set: function (options) {
            extend(this.options, options);
            this.manager && this.manager.touchAction.update();
            return this;
        },
        recognizeWith: function (otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                return this;
            }
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
                simultaneous[otherRecognizer.id] = otherRecognizer;
                otherRecognizer.recognizeWith(this);
            }
            return this;
        },
        dropRecognizeWith: function (otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
        },
        requireFailure: function (otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                return this;
            }
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
                requireFail.push(otherRecognizer);
                otherRecognizer.requireFailure(this);
            }
            return this;
        },
        dropRequireFailure: function (otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) {
                this.requireFail.splice(index, 1);
            }
            return this;
        },
        hasRequireFailures: function () {
            return this.requireFail.length > 0;
        },
        canRecognizeWith: function (otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
        },
        emit: function (input) {
            var self = this;
            var state = this.state;
            function emit(withState) {
                self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
            }
            if (state < STATE_ENDED) {
                emit(true);
            }
            emit();
            if (state >= STATE_ENDED) {
                emit(true);
            }
        },
        tryEmit: function (input) {
            if (this.canEmit()) {
                return this.emit(input);
            }
            this.state = STATE_FAILED;
        },
        canEmit: function () {
            var i = 0;
            while (i < this.requireFail.length) {
                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                    return false;
                }
                i++;
            }
            return true;
        },
        recognize: function (inputData) {
            var inputDataClone = extend({}, inputData);
            if (!boolOrFn(this.options.enable, [
                    this,
                    inputDataClone
                ])) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                this.state = STATE_POSSIBLE;
            }
            this.state = this.process(inputDataClone);
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                this.tryEmit(inputDataClone);
            }
        },
        process: function (inputData) {
        },
        getTouchAction: function () {
        },
        reset: function () {
        }
    };
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return 'cancel';
        } else if (state & STATE_ENDED) {
            return 'end';
        } else if (state & STATE_CHANGED) {
            return 'move';
        } else if (state & STATE_BEGAN) {
            return 'start';
        }
        return '';
    }
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return 'down';
        } else if (direction == DIRECTION_UP) {
            return 'up';
        } else if (direction == DIRECTION_LEFT) {
            return 'left';
        } else if (direction == DIRECTION_RIGHT) {
            return 'right';
        }
        return '';
    }
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }
    inherit(AttrRecognizer, Recognizer, {
        defaults: { pointers: 1 },
        attrTest: function (input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        process: function (input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
                if (eventType & INPUT_END) {
                    return state | STATE_ENDED;
                } else if (!(state & STATE_BEGAN)) {
                    return STATE_BEGAN;
                }
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    });
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
    }
    inherit(PanRecognizer, AttrRecognizer, {
        defaults: {
            event: 'pan',
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },
        getTouchAction: function () {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
                actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
                actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
        },
        directionTest: function (input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;
            if (!(direction & options.direction)) {
                if (options.direction & DIRECTION_HORIZONTAL) {
                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs(input.deltaX);
                } else {
                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs(input.deltaY);
                }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function (input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function (input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) {
                this.manager.emit(this.options.event + direction, input);
            }
            this._super.emit.call(this, input);
        }
    });
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(PinchRecognizer, AttrRecognizer, {
        defaults: {
            event: 'pinch',
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function () {
            return [TOUCH_ACTION_NONE];
        },
        attrTest: function (input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function (input) {
            this._super.emit.call(this, input);
            if (input.scale !== 1) {
                var inOut = input.scale < 1 ? 'in' : 'out';
                this.manager.emit(this.options.event + inOut, input);
            }
        }
    });
    function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
    }
    inherit(PressRecognizer, Recognizer, {
        defaults: {
            event: 'press',
            pointers: 1,
            time: 500,
            threshold: 5
        },
        getTouchAction: function () {
            return [TOUCH_ACTION_AUTO];
        },
        process: function (input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
                this.reset();
            } else if (input.eventType & INPUT_START) {
                this.reset();
                this._timer = setTimeoutContext(function () {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this);
            } else if (input.eventType & INPUT_END) {
                return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
        },
        reset: function () {
            clearTimeout(this._timer);
        },
        emit: function (input) {
            if (this.state !== STATE_RECOGNIZED) {
                return;
            }
            if (input && input.eventType & INPUT_END) {
                this.manager.emit(this.options.event + 'up', input);
            } else {
                this._input.timeStamp = now();
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(RotateRecognizer, AttrRecognizer, {
        defaults: {
            event: 'rotate',
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function () {
            return [TOUCH_ACTION_NONE];
        },
        attrTest: function (input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
    });
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }
    inherit(SwipeRecognizer, AttrRecognizer, {
        defaults: {
            event: 'swipe',
            threshold: 10,
            velocity: 0.65,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },
        getTouchAction: function () {
            return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function (input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                velocity = input.velocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
                velocity = input.velocityX;
            } else if (direction & DIRECTION_VERTICAL) {
                velocity = input.velocityY;
            }
            return this._super.attrTest.call(this, input) && direction & input.direction && input.distance > this.options.threshold && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function (input) {
            var direction = directionStr(input.direction);
            if (direction) {
                this.manager.emit(this.options.event + direction, input);
            }
            this.manager.emit(this.options.event, input);
        }
    });
    function TapRecognizer() {
        Recognizer.apply(this, arguments);
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
    }
    inherit(TapRecognizer, Recognizer, {
        defaults: {
            event: 'tap',
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 2,
            posThreshold: 10
        },
        getTouchAction: function () {
            return [TOUCH_ACTION_MANIPULATION];
        },
        process: function (input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START && this.count === 0) {
                return this.failTimeout();
            }
            if (validMovement && validTouchTime && validPointers) {
                if (input.eventType != INPUT_END) {
                    return this.failTimeout();
                }
                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                this.pTime = input.timeStamp;
                this.pCenter = input.center;
                if (!validMultiTap || !validInterval) {
                    this.count = 1;
                } else {
                    this.count += 1;
                }
                this._input = input;
                var tapCount = this.count % options.taps;
                if (tapCount === 0) {
                    if (!this.hasRequireFailures()) {
                        return STATE_RECOGNIZED;
                    } else {
                        this._timer = setTimeoutContext(function () {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this);
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },
        failTimeout: function () {
            this._timer = setTimeoutContext(function () {
                this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
        },
        reset: function () {
            clearTimeout(this._timer);
        },
        emit: function () {
            if (this.state == STATE_RECOGNIZED) {
                this._input.tapCount = this.count;
                this.manager.emit(this.options.event, this._input);
            }
        }
    });
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }
    Hammer.VERSION = '2.0.3';
    Hammer.defaults = {
        domEvents: false,
        touchAction: TOUCH_ACTION_COMPUTE,
        enable: true,
        inputTarget: null,
        inputClass: null,
        preset: [
            [
                RotateRecognizer,
                { enable: false }
            ],
            [
                PinchRecognizer,
                { enable: false },
                ['rotate']
            ],
            [
                SwipeRecognizer,
                { direction: DIRECTION_HORIZONTAL }
            ],
            [
                PanRecognizer,
                { direction: DIRECTION_HORIZONTAL },
                ['swipe']
            ],
            [TapRecognizer],
            [
                TapRecognizer,
                {
                    event: 'doubletap',
                    taps: 2
                },
                ['tap']
            ],
            [PressRecognizer]
        ],
        cssProps: {
            userSelect: 'none',
            touchSelect: 'none',
            touchCallout: 'none',
            contentZooming: 'none',
            userDrag: 'none',
            tapHighlightColor: 'rgba(0,0,0,0)'
        }
    };
    var STOP = 1;
    var FORCED_STOP = 2;
    function Manager(element, options) {
        options = options || {};
        this.options = merge(options, Hammer.defaults);
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(options.recognizers, function (item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }
    Manager.prototype = {
        set: function (options) {
            extend(this.options, options);
            if (options.touchAction) {
                this.touchAction.update();
            }
            if (options.inputTarget) {
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },
        stop: function (force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },
        recognize: function (inputData) {
            var session = this.session;
            if (session.stopped) {
                return;
            }
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            var curRecognizer = session.curRecognizer;
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                curRecognizer = session.curRecognizer = null;
            }
            var i = 0;
            while (i < recognizers.length) {
                recognizer = recognizers[i];
                if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
                    recognizer.recognize(inputData);
                } else {
                    recognizer.reset();
                }
                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                    curRecognizer = session.curRecognizer = recognizer;
                }
                i++;
            }
        },
        get: function (recognizer) {
            if (recognizer instanceof Recognizer) {
                return recognizer;
            }
            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++) {
                if (recognizers[i].options.event == recognizer) {
                    return recognizers[i];
                }
            }
            return null;
        },
        add: function (recognizer) {
            if (invokeArrayArg(recognizer, 'add', this)) {
                return this;
            }
            var existing = this.get(recognizer.options.event);
            if (existing) {
                this.remove(existing);
            }
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
        },
        remove: function (recognizer) {
            if (invokeArrayArg(recognizer, 'remove', this)) {
                return this;
            }
            var recognizers = this.recognizers;
            recognizer = this.get(recognizer);
            recognizers.splice(inArray(recognizers, recognizer), 1);
            this.touchAction.update();
            return this;
        },
        on: function (events, handler) {
            var handlers = this.handlers;
            each(splitStr(events), function (event) {
                handlers[event] = handlers[event] || [];
                handlers[event].push(handler);
            });
            return this;
        },
        off: function (events, handler) {
            var handlers = this.handlers;
            each(splitStr(events), function (event) {
                if (!handler) {
                    delete handlers[event];
                } else {
                    handlers[event].splice(inArray(handlers[event], handler), 1);
                }
            });
            return this;
        },
        emit: function (event, data) {
            if (this.options.domEvents) {
                triggerDomEvent(event, data);
            }
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
                return;
            }
            data.type = event;
            data.preventDefault = function () {
                data.srcEvent.preventDefault();
            };
            var i = 0;
            while (i < handlers.length) {
                handlers[i](data);
                i++;
            }
        },
        destroy: function () {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };
    function toggleCssProps(manager, add) {
        var element = manager.element;
        each(manager.options.cssProps, function (value, name) {
            element.style[prefixed(element.style, name)] = add ? value : '';
        });
    }
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }
    extend(Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,
        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    });
    if (typeof define == TYPE_FUNCTION && define.amd) {
        define('hammer', [], function () {
            return Hammer;
        });
    } else if (typeof module != 'undefined' && module.exports) {
        module.exports = Hammer;
    } else {
        window[exportName] = Hammer;
    }
}(window, document, 'Hammer'));
(function (window, document, undefined) {
    var _MAP = {
            8: 'backspace',
            9: 'tab',
            13: 'enter',
            16: 'shift',
            17: 'ctrl',
            18: 'alt',
            20: 'capslock',
            27: 'esc',
            32: 'space',
            33: 'pageup',
            34: 'pagedown',
            35: 'end',
            36: 'home',
            37: 'left',
            38: 'up',
            39: 'right',
            40: 'down',
            45: 'ins',
            46: 'del',
            91: 'meta',
            93: 'meta',
            224: 'meta'
        }, _KEYCODE_MAP = {
            106: '*',
            107: '+',
            109: '-',
            110: '.',
            111: '/',
            186: ';',
            187: '=',
            188: ',',
            189: '-',
            190: '.',
            191: '/',
            192: '`',
            219: '[',
            220: '\\',
            221: ']',
            222: '\''
        }, _SHIFT_MAP = {
            '~': '`',
            '!': '1',
            '@': '2',
            '#': '3',
            '$': '4',
            '%': '5',
            '^': '6',
            '&': '7',
            '*': '8',
            '(': '9',
            ')': '0',
            '_': '-',
            '+': '=',
            ':': ';',
            '"': '\'',
            '<': ',',
            '>': '.',
            '?': '/',
            '|': '\\'
        }, _SPECIAL_ALIASES = {
            'option': 'alt',
            'command': 'meta',
            'return': 'enter',
            'escape': 'esc',
            'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
        }, _REVERSE_MAP, _callbacks = {}, _directMap = {}, _sequenceLevels = {}, _resetTimer, _ignoreNextKeyup = false, _ignoreNextKeypress = false, _nextExpectedAction = false;
    for (var i = 1; i < 20; ++i) {
        _MAP[111 + i] = 'f' + i;
    }
    for (i = 0; i <= 9; ++i) {
        _MAP[i + 96] = i;
    }
    function _addEvent(object, type, callback) {
        if (object.addEventListener) {
            object.addEventListener(type, callback, false);
            return;
        }
        object.attachEvent('on' + type, callback);
    }
    function _characterFromEvent(e) {
        if (e.type == 'keypress') {
            var character = String.fromCharCode(e.which);
            if (!e.shiftKey) {
                character = character.toLowerCase();
            }
            return character;
        }
        if (_MAP[e.which]) {
            return _MAP[e.which];
        }
        if (_KEYCODE_MAP[e.which]) {
            return _KEYCODE_MAP[e.which];
        }
        return String.fromCharCode(e.which).toLowerCase();
    }
    function _modifiersMatch(modifiers1, modifiers2) {
        return modifiers1.sort().join(',') === modifiers2.sort().join(',');
    }
    function _resetSequences(doNotReset) {
        doNotReset = doNotReset || {};
        var activeSequences = false, key;
        for (key in _sequenceLevels) {
            if (doNotReset[key]) {
                activeSequences = true;
                continue;
            }
            _sequenceLevels[key] = 0;
        }
        if (!activeSequences) {
            _nextExpectedAction = false;
        }
    }
    function _getMatches(character, modifiers, e, sequenceName, combination, level) {
        var i, callback, matches = [], action = e.type;
        if (!_callbacks[character]) {
            return [];
        }
        if (action == 'keyup' && _isModifier(character)) {
            modifiers = [character];
        }
        for (i = 0; i < _callbacks[character].length; ++i) {
            callback = _callbacks[character][i];
            if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
                continue;
            }
            if (action != callback.action) {
                continue;
            }
            if (action == 'keypress' && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {
                var deleteCombo = !sequenceName && callback.combo == combination;
                var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
                if (deleteCombo || deleteSequence) {
                    _callbacks[character].splice(i, 1);
                }
                matches.push(callback);
            }
        }
        return matches;
    }
    function _eventModifiers(e) {
        var modifiers = [];
        if (e.shiftKey) {
            modifiers.push('shift');
        }
        if (e.altKey) {
            modifiers.push('alt');
        }
        if (e.ctrlKey) {
            modifiers.push('ctrl');
        }
        if (e.metaKey) {
            modifiers.push('meta');
        }
        return modifiers;
    }
    function _preventDefault(e) {
        if (e.preventDefault) {
            e.preventDefault();
            return;
        }
        e.returnValue = false;
    }
    function _stopPropagation(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
            return;
        }
        e.cancelBubble = true;
    }
    function _fireCallback(callback, e, combo, sequence) {
        if (Mousetrap.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
            return;
        }
        if (callback(e, combo) === false) {
            _preventDefault(e);
            _stopPropagation(e);
        }
    }
    function _handleKey(character, modifiers, e) {
        var callbacks = _getMatches(character, modifiers, e), i, doNotReset = {}, maxLevel = 0, processedSequenceCallback = false;
        for (i = 0; i < callbacks.length; ++i) {
            if (callbacks[i].seq) {
                maxLevel = Math.max(maxLevel, callbacks[i].level);
            }
        }
        for (i = 0; i < callbacks.length; ++i) {
            if (callbacks[i].seq) {
                if (callbacks[i].level != maxLevel) {
                    continue;
                }
                processedSequenceCallback = true;
                doNotReset[callbacks[i].seq] = 1;
                _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);
                continue;
            }
            if (!processedSequenceCallback) {
                _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
            }
        }
        var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;
        if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
            _resetSequences(doNotReset);
        }
        _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
    }
    function _handleKeyEvent(e) {
        if (typeof e.which !== 'number') {
            e.which = e.keyCode;
        }
        var character = _characterFromEvent(e);
        if (!character) {
            return;
        }
        if (e.type == 'keyup' && _ignoreNextKeyup === character) {
            _ignoreNextKeyup = false;
            return;
        }
        Mousetrap.handleKey(character, _eventModifiers(e), e);
    }
    function _isModifier(key) {
        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
    }
    function _resetSequenceTimer() {
        clearTimeout(_resetTimer);
        _resetTimer = setTimeout(_resetSequences, 1000);
    }
    function _getReverseMap() {
        if (!_REVERSE_MAP) {
            _REVERSE_MAP = {};
            for (var key in _MAP) {
                if (key > 95 && key < 112) {
                    continue;
                }
                if (_MAP.hasOwnProperty(key)) {
                    _REVERSE_MAP[_MAP[key]] = key;
                }
            }
        }
        return _REVERSE_MAP;
    }
    function _pickBestAction(key, modifiers, action) {
        if (!action) {
            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
        }
        if (action == 'keypress' && modifiers.length) {
            action = 'keydown';
        }
        return action;
    }
    function _bindSequence(combo, keys, callback, action) {
        _sequenceLevels[combo] = 0;
        function _increaseSequence(nextAction) {
            return function () {
                _nextExpectedAction = nextAction;
                ++_sequenceLevels[combo];
                _resetSequenceTimer();
            };
        }
        function _callbackAndReset(e) {
            _fireCallback(callback, e, combo);
            if (action !== 'keyup') {
                _ignoreNextKeyup = _characterFromEvent(e);
            }
            setTimeout(_resetSequences, 10);
        }
        for (var i = 0; i < keys.length; ++i) {
            var isFinal = i + 1 === keys.length;
            var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
            _bindSingle(keys[i], wrappedCallback, action, combo, i);
        }
    }
    function _keysFromString(combination) {
        if (combination === '+') {
            return ['+'];
        }
        return combination.split('+');
    }
    function _getKeyInfo(combination, action) {
        var keys, key, i, modifiers = [];
        keys = _keysFromString(combination);
        for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (_SPECIAL_ALIASES[key]) {
                key = _SPECIAL_ALIASES[key];
            }
            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
                key = _SHIFT_MAP[key];
                modifiers.push('shift');
            }
            if (_isModifier(key)) {
                modifiers.push(key);
            }
        }
        action = _pickBestAction(key, modifiers, action);
        return {
            key: key,
            modifiers: modifiers,
            action: action
        };
    }
    function _bindSingle(combination, callback, action, sequenceName, level) {
        _directMap[combination + ':' + action] = callback;
        combination = combination.replace(/\s+/g, ' ');
        var sequence = combination.split(' '), info;
        if (sequence.length > 1) {
            _bindSequence(combination, sequence, callback, action);
            return;
        }
        info = _getKeyInfo(combination, action);
        _callbacks[info.key] = _callbacks[info.key] || [];
        _getMatches(info.key, info.modifiers, { type: info.action }, sequenceName, combination, level);
        _callbacks[info.key][sequenceName ? 'unshift' : 'push']({
            callback: callback,
            modifiers: info.modifiers,
            action: info.action,
            seq: sequenceName,
            level: level,
            combo: combination
        });
    }
    function _bindMultiple(combinations, callback, action) {
        for (var i = 0; i < combinations.length; ++i) {
            _bindSingle(combinations[i], callback, action);
        }
    }
    _addEvent(document, 'keypress', _handleKeyEvent);
    _addEvent(document, 'keydown', _handleKeyEvent);
    _addEvent(document, 'keyup', _handleKeyEvent);
    var Mousetrap = {
        bind: function (keys, callback, action) {
            keys = keys instanceof Array ? keys : [keys];
            _bindMultiple(keys, callback, action);
            return this;
        },
        unbind: function (keys, action) {
            return Mousetrap.bind(keys, function () {
            }, action);
        },
        trigger: function (keys, action) {
            if (_directMap[keys + ':' + action]) {
                _directMap[keys + ':' + action]({}, keys);
            }
            return this;
        },
        reset: function () {
            _callbacks = {};
            _directMap = {};
            return this;
        },
        stopCallback: function (e, element) {
            if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
                return false;
            }
            return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
        },
        handleKey: _handleKey
    };
    window.Mousetrap = Mousetrap;
    if (typeof define === 'function' && define.amd) {
        define('mousetrap', [], Mousetrap);
    }
}(window, document));
(function (mod) {
    if (typeof exports == 'object' && typeof module == 'object')
        module.exports = mod();
    if (typeof define == 'function' && define.amd)
        return define('lib/codemirror', [], mod);
    else
        this.CodeMirror = mod();
}(function () {
    'use strict';
    var gecko = /gecko\/\d/i.test(navigator.userAgent);
    var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
    var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    var ie = ie_upto10 || ie_11up;
    var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
    var webkit = /WebKit\//.test(navigator.userAgent);
    var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
    var chrome = /Chrome\//.test(navigator.userAgent);
    var presto = /Opera\//.test(navigator.userAgent);
    var safari = /Apple Computer/.test(navigator.vendor);
    var khtml = /KHTML\//.test(navigator.userAgent);
    var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
    var phantom = /PhantomJS/.test(navigator.userAgent);
    var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
    var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
    var mac = ios || /Mac/.test(navigator.platform);
    var windows = /win/i.test(navigator.platform);
    var presto_version = presto && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
    if (presto_version)
        presto_version = Number(presto_version[1]);
    if (presto_version && presto_version >= 15) {
        presto = false;
        webkit = true;
    }
    var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
    var captureRightClick = gecko || ie && ie_version >= 9;
    var sawReadOnlySpans = false, sawCollapsedSpans = false;
    function CodeMirror(place, options) {
        if (!(this instanceof CodeMirror))
            return new CodeMirror(place, options);
        this.options = options = options || {};
        copyObj(defaults, options, false);
        setGuttersForLineNumbers(options);
        var doc = options.value;
        if (typeof doc == 'string')
            doc = new Doc(doc, options.mode);
        this.doc = doc;
        var display = this.display = new Display(place, doc);
        display.wrapper.CodeMirror = this;
        updateGutters(this);
        themeChanged(this);
        if (options.lineWrapping)
            this.display.wrapper.className += ' CodeMirror-wrap';
        if (options.autofocus && !mobile)
            focusInput(this);
        this.state = {
            keyMaps: [],
            overlays: [],
            modeGen: 0,
            overwrite: false,
            focused: false,
            suppressEdits: false,
            pasteIncoming: false,
            cutIncoming: false,
            draggingText: false,
            highlight: new Delayed()
        };
        if (ie && ie_version < 11)
            setTimeout(bind(resetInput, this, true), 20);
        registerEventHandlers(this);
        ensureGlobalHandlers();
        var cm = this;
        runInOp(this, function () {
            cm.curOp.forceUpdate = true;
            attachDoc(cm, doc);
            if (options.autofocus && !mobile || activeElt() == display.input)
                setTimeout(bind(onFocus, cm), 20);
            else
                onBlur(cm);
            for (var opt in optionHandlers)
                if (optionHandlers.hasOwnProperty(opt))
                    optionHandlers[opt](cm, options[opt], Init);
            maybeUpdateLineNumberWidth(cm);
            for (var i = 0; i < initHooks.length; ++i)
                initHooks[i](cm);
        });
    }
    function Display(place, doc) {
        var d = this;
        var input = d.input = elt('textarea', null, null, 'position: absolute; padding: 0; width: 1px; height: 1em; outline: none');
        if (webkit)
            input.style.width = '1000px';
        else
            input.setAttribute('wrap', 'off');
        if (ios)
            input.style.border = '1px solid black';
        input.setAttribute('autocorrect', 'off');
        input.setAttribute('autocapitalize', 'off');
        input.setAttribute('spellcheck', 'false');
        d.inputDiv = elt('div', [input], null, 'overflow: hidden; position: relative; width: 3px; height: 0px;');
        d.scrollbarH = elt('div', [elt('div', null, null, 'height: 100%; min-height: 1px')], 'CodeMirror-hscrollbar');
        d.scrollbarV = elt('div', [elt('div', null, null, 'min-width: 1px')], 'CodeMirror-vscrollbar');
        d.scrollbarFiller = elt('div', null, 'CodeMirror-scrollbar-filler');
        d.gutterFiller = elt('div', null, 'CodeMirror-gutter-filler');
        d.lineDiv = elt('div', null, 'CodeMirror-code');
        d.selectionDiv = elt('div', null, null, 'position: relative; z-index: 1');
        d.cursorDiv = elt('div', null, 'CodeMirror-cursors');
        d.measure = elt('div', null, 'CodeMirror-measure');
        d.lineMeasure = elt('div', null, 'CodeMirror-measure');
        d.lineSpace = elt('div', [
            d.measure,
            d.lineMeasure,
            d.selectionDiv,
            d.cursorDiv,
            d.lineDiv
        ], null, 'position: relative; outline: none');
        d.mover = elt('div', [elt('div', [d.lineSpace], 'CodeMirror-lines')], null, 'position: relative');
        d.sizer = elt('div', [d.mover], 'CodeMirror-sizer');
        d.heightForcer = elt('div', null, null, 'position: absolute; height: ' + scrollerCutOff + 'px; width: 1px;');
        d.gutters = elt('div', null, 'CodeMirror-gutters');
        d.lineGutter = null;
        d.scroller = elt('div', [
            d.sizer,
            d.heightForcer,
            d.gutters
        ], 'CodeMirror-scroll');
        d.scroller.setAttribute('tabIndex', '-1');
        d.wrapper = elt('div', [
            d.inputDiv,
            d.scrollbarH,
            d.scrollbarV,
            d.scrollbarFiller,
            d.gutterFiller,
            d.scroller
        ], 'CodeMirror');
        if (ie && ie_version < 8) {
            d.gutters.style.zIndex = -1;
            d.scroller.style.paddingRight = 0;
        }
        if (ios)
            input.style.width = '0px';
        if (!webkit)
            d.scroller.draggable = true;
        if (khtml) {
            d.inputDiv.style.height = '1px';
            d.inputDiv.style.position = 'absolute';
        }
        if (ie && ie_version < 8)
            d.scrollbarH.style.minHeight = d.scrollbarV.style.minWidth = '18px';
        if (place.appendChild)
            place.appendChild(d.wrapper);
        else
            place(d.wrapper);
        d.viewFrom = d.viewTo = doc.first;
        d.view = [];
        d.externalMeasured = null;
        d.viewOffset = 0;
        d.lastSizeC = 0;
        d.updateLineNumbers = null;
        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
        d.prevInput = '';
        d.alignWidgets = false;
        d.pollingFast = false;
        d.poll = new Delayed();
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.inaccurateSelection = false;
        d.maxLine = null;
        d.maxLineLength = 0;
        d.maxLineChanged = false;
        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
        d.shift = false;
        d.selForContextMenu = null;
    }
    function loadMode(cm) {
        cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
        resetModeState(cm);
    }
    function resetModeState(cm) {
        cm.doc.iter(function (line) {
            if (line.stateAfter)
                line.stateAfter = null;
            if (line.styles)
                line.styles = null;
        });
        cm.doc.frontier = cm.doc.first;
        startWorker(cm, 100);
        cm.state.modeGen++;
        if (cm.curOp)
            regChange(cm);
    }
    function wrappingChanged(cm) {
        if (cm.options.lineWrapping) {
            addClass(cm.display.wrapper, 'CodeMirror-wrap');
            cm.display.sizer.style.minWidth = '';
        } else {
            rmClass(cm.display.wrapper, 'CodeMirror-wrap');
            findMaxLine(cm);
        }
        estimateLineHeights(cm);
        regChange(cm);
        clearCaches(cm);
        setTimeout(function () {
            updateScrollbars(cm);
        }, 100);
    }
    function estimateHeight(cm) {
        var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function (line) {
            if (lineIsHidden(cm.doc, line))
                return 0;
            var widgetsHeight = 0;
            if (line.widgets)
                for (var i = 0; i < line.widgets.length; i++) {
                    if (line.widgets[i].height)
                        widgetsHeight += line.widgets[i].height;
                }
            if (wrapping)
                return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
            else
                return widgetsHeight + th;
        };
    }
    function estimateLineHeights(cm) {
        var doc = cm.doc, est = estimateHeight(cm);
        doc.iter(function (line) {
            var estHeight = est(line);
            if (estHeight != line.height)
                updateLineHeight(line, estHeight);
        });
    }
    function keyMapChanged(cm) {
        var map = keyMap[cm.options.keyMap], style = map.style;
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, '') + (style ? ' cm-keymap-' + style : '');
    }
    function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, '') + cm.options.theme.replace(/(^|\s)\s*/g, ' cm-s-');
        clearCaches(cm);
    }
    function guttersChanged(cm) {
        updateGutters(cm);
        regChange(cm);
        setTimeout(function () {
            alignHorizontally(cm);
        }, 20);
    }
    function updateGutters(cm) {
        var gutters = cm.display.gutters, specs = cm.options.gutters;
        removeChildren(gutters);
        for (var i = 0; i < specs.length; ++i) {
            var gutterClass = specs[i];
            var gElt = gutters.appendChild(elt('div', null, 'CodeMirror-gutter ' + gutterClass));
            if (gutterClass == 'CodeMirror-linenumbers') {
                cm.display.lineGutter = gElt;
                gElt.style.width = (cm.display.lineNumWidth || 1) + 'px';
            }
        }
        gutters.style.display = i ? '' : 'none';
        updateGutterSpace(cm);
    }
    function updateGutterSpace(cm) {
        var width = cm.display.gutters.offsetWidth;
        cm.display.sizer.style.marginLeft = width + 'px';
        cm.display.scrollbarH.style.left = cm.options.fixedGutter ? width + 'px' : 0;
    }
    function lineLength(line) {
        if (line.height == 0)
            return 0;
        var len = line.text.length, merged, cur = line;
        while (merged = collapsedSpanAtStart(cur)) {
            var found = merged.find(0, true);
            cur = found.from.line;
            len += found.from.ch - found.to.ch;
        }
        cur = line;
        while (merged = collapsedSpanAtEnd(cur)) {
            var found = merged.find(0, true);
            len -= cur.text.length - found.from.ch;
            cur = found.to.line;
            len += cur.text.length - found.to.ch;
        }
        return len;
    }
    function findMaxLine(cm) {
        var d = cm.display, doc = cm.doc;
        d.maxLine = getLine(doc, doc.first);
        d.maxLineLength = lineLength(d.maxLine);
        d.maxLineChanged = true;
        doc.iter(function (line) {
            var len = lineLength(line);
            if (len > d.maxLineLength) {
                d.maxLineLength = len;
                d.maxLine = line;
            }
        });
    }
    function setGuttersForLineNumbers(options) {
        var found = indexOf(options.gutters, 'CodeMirror-linenumbers');
        if (found == -1 && options.lineNumbers) {
            options.gutters = options.gutters.concat(['CodeMirror-linenumbers']);
        } else if (found > -1 && !options.lineNumbers) {
            options.gutters = options.gutters.slice(0);
            options.gutters.splice(found, 1);
        }
    }
    function hScrollbarTakesSpace(cm) {
        return cm.display.scroller.clientHeight - cm.display.wrapper.clientHeight < scrollerCutOff - 3;
    }
    function measureForScrollbars(cm) {
        var scroll = cm.display.scroller;
        return {
            clientHeight: scroll.clientHeight,
            barHeight: cm.display.scrollbarV.clientHeight,
            scrollWidth: scroll.scrollWidth,
            clientWidth: scroll.clientWidth,
            hScrollbarTakesSpace: hScrollbarTakesSpace(cm),
            barWidth: cm.display.scrollbarH.clientWidth,
            docHeight: Math.round(cm.doc.height + paddingVert(cm.display))
        };
    }
    function updateScrollbars(cm, measure) {
        if (!measure)
            measure = measureForScrollbars(cm);
        var d = cm.display, sWidth = scrollbarWidth(d.measure);
        var scrollHeight = measure.docHeight + scrollerCutOff;
        var needsH = measure.scrollWidth > measure.clientWidth;
        if (needsH && measure.scrollWidth <= measure.clientWidth + 1 && sWidth > 0 && !measure.hScrollbarTakesSpace)
            needsH = false;
        var needsV = scrollHeight > measure.clientHeight;
        if (needsV) {
            d.scrollbarV.style.display = 'block';
            d.scrollbarV.style.bottom = needsH ? sWidth + 'px' : '0';
            d.scrollbarV.firstChild.style.height = Math.max(0, scrollHeight - measure.clientHeight + (measure.barHeight || d.scrollbarV.clientHeight)) + 'px';
        } else {
            d.scrollbarV.style.display = '';
            d.scrollbarV.firstChild.style.height = '0';
        }
        if (needsH) {
            d.scrollbarH.style.display = 'block';
            d.scrollbarH.style.right = needsV ? sWidth + 'px' : '0';
            d.scrollbarH.firstChild.style.width = measure.scrollWidth - measure.clientWidth + (measure.barWidth || d.scrollbarH.clientWidth) + 'px';
        } else {
            d.scrollbarH.style.display = '';
            d.scrollbarH.firstChild.style.width = '0';
        }
        if (needsH && needsV) {
            d.scrollbarFiller.style.display = 'block';
            d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = sWidth + 'px';
        } else
            d.scrollbarFiller.style.display = '';
        if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
            d.gutterFiller.style.display = 'block';
            d.gutterFiller.style.height = sWidth + 'px';
            d.gutterFiller.style.width = d.gutters.offsetWidth + 'px';
        } else
            d.gutterFiller.style.display = '';
        if (!cm.state.checkedOverlayScrollbar && measure.clientHeight > 0) {
            if (sWidth === 0) {
                var w = mac && !mac_geMountainLion ? '12px' : '18px';
                d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = w;
                var barMouseDown = function (e) {
                    if (e_target(e) != d.scrollbarV && e_target(e) != d.scrollbarH)
                        operation(cm, onMouseDown)(e);
                };
                on(d.scrollbarV, 'mousedown', barMouseDown);
                on(d.scrollbarH, 'mousedown', barMouseDown);
            }
            cm.state.checkedOverlayScrollbar = true;
        }
    }
    function visibleLines(display, doc, viewport) {
        var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - paddingTop(display));
        var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
        var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
        if (viewport && viewport.ensure) {
            var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
            if (ensureFrom < from)
                return {
                    from: ensureFrom,
                    to: lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)
                };
            if (Math.min(ensureTo, doc.lastLine()) >= to)
                return {
                    from: lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight),
                    to: ensureTo
                };
        }
        return {
            from: from,
            to: Math.max(to, from + 1)
        };
    }
    function alignHorizontally(cm) {
        var display = cm.display, view = display.view;
        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter))
            return;
        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
        var gutterW = display.gutters.offsetWidth, left = comp + 'px';
        for (var i = 0; i < view.length; i++)
            if (!view[i].hidden) {
                if (cm.options.fixedGutter && view[i].gutter)
                    view[i].gutter.style.left = left;
                var align = view[i].alignable;
                if (align)
                    for (var j = 0; j < align.length; j++)
                        align[j].style.left = left;
            }
        if (cm.options.fixedGutter)
            display.gutters.style.left = comp + gutterW + 'px';
    }
    function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers)
            return false;
        var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
        if (last.length != display.lineNumChars) {
            var test = display.measure.appendChild(elt('div', [elt('div', last)], 'CodeMirror-linenumber CodeMirror-gutter-elt'));
            var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
            display.lineGutter.style.width = '';
            display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
            display.lineNumWidth = display.lineNumInnerWidth + padding;
            display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
            display.lineGutter.style.width = display.lineNumWidth + 'px';
            updateGutterSpace(cm);
            return true;
        }
        return false;
    }
    function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber));
    }
    function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
    }
    function DisplayUpdate(cm, viewport, force) {
        var display = cm.display;
        this.viewport = viewport;
        this.visible = visibleLines(display, cm.doc, viewport);
        this.editorIsHidden = !display.wrapper.offsetWidth;
        this.wrapperHeight = display.wrapper.clientHeight;
        this.oldViewFrom = display.viewFrom;
        this.oldViewTo = display.viewTo;
        this.oldScrollerWidth = display.scroller.clientWidth;
        this.force = force;
        this.dims = getDimensions(cm);
    }
    function updateDisplayIfNeeded(cm, update) {
        var display = cm.display, doc = cm.doc;
        if (update.editorIsHidden) {
            resetView(cm);
            return false;
        }
        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && countDirtyView(cm) == 0)
            return false;
        if (maybeUpdateLineNumberWidth(cm)) {
            resetView(cm);
            update.dims = getDimensions(cm);
        }
        var end = doc.first + doc.size;
        var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
        var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
        if (display.viewFrom < from && from - display.viewFrom < 20)
            from = Math.max(doc.first, display.viewFrom);
        if (display.viewTo > to && display.viewTo - to < 20)
            to = Math.min(end, display.viewTo);
        if (sawCollapsedSpans) {
            from = visualLineNo(cm.doc, from);
            to = visualLineEndNo(cm.doc, to);
        }
        var different = from != display.viewFrom || to != display.viewTo || display.lastSizeC != update.wrapperHeight;
        adjustView(cm, from, to);
        display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
        cm.display.mover.style.top = display.viewOffset + 'px';
        var toUpdate = countDirtyView(cm);
        if (!different && toUpdate == 0 && !update.force && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
            return false;
        var focused = activeElt();
        if (toUpdate > 4)
            display.lineDiv.style.display = 'none';
        patchDisplay(cm, display.updateLineNumbers, update.dims);
        if (toUpdate > 4)
            display.lineDiv.style.display = '';
        if (focused && activeElt() != focused && focused.offsetHeight)
            focused.focus();
        removeChildren(display.cursorDiv);
        removeChildren(display.selectionDiv);
        if (different) {
            display.lastSizeC = update.wrapperHeight;
            startWorker(cm, 400);
        }
        display.updateLineNumbers = null;
        return true;
    }
    function postUpdateDisplay(cm, update) {
        var force = update.force, viewport = update.viewport;
        for (var first = true;; first = false) {
            if (first && cm.options.lineWrapping && update.oldScrollerWidth != cm.display.scroller.clientWidth) {
                force = true;
            } else {
                force = false;
                if (viewport && viewport.top != null)
                    viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - scrollerCutOff - cm.display.scroller.clientHeight, viewport.top) };
                update.visible = visibleLines(cm.display, cm.doc, viewport);
                if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
                    break;
            }
            if (!updateDisplayIfNeeded(cm, update))
                break;
            updateHeightsInViewport(cm);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            setDocumentHeight(cm, barMeasure);
            updateScrollbars(cm, barMeasure);
        }
        signalLater(cm, 'update', cm);
        if (cm.display.viewFrom != update.oldViewFrom || cm.display.viewTo != update.oldViewTo)
            signalLater(cm, 'viewportChange', cm, cm.display.viewFrom, cm.display.viewTo);
    }
    function updateDisplaySimple(cm, viewport) {
        var update = new DisplayUpdate(cm, viewport);
        if (updateDisplayIfNeeded(cm, update)) {
            updateHeightsInViewport(cm);
            postUpdateDisplay(cm, update);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            setDocumentHeight(cm, barMeasure);
            updateScrollbars(cm, barMeasure);
        }
    }
    function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = measure.docHeight + 'px';
        cm.display.gutters.style.height = Math.max(measure.docHeight, measure.clientHeight - scrollerCutOff) + 'px';
    }
    function checkForWebkitWidthBug(cm, measure) {
        if (cm.display.sizer.offsetWidth + cm.display.gutters.offsetWidth < cm.display.scroller.clientWidth - 1) {
            cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = '0px';
            cm.display.gutters.style.height = measure.docHeight + 'px';
        }
    }
    function updateHeightsInViewport(cm) {
        var display = cm.display;
        var prevBottom = display.lineDiv.offsetTop;
        for (var i = 0; i < display.view.length; i++) {
            var cur = display.view[i], height;
            if (cur.hidden)
                continue;
            if (ie && ie_version < 8) {
                var bot = cur.node.offsetTop + cur.node.offsetHeight;
                height = bot - prevBottom;
                prevBottom = bot;
            } else {
                var box = cur.node.getBoundingClientRect();
                height = box.bottom - box.top;
            }
            var diff = cur.line.height - height;
            if (height < 2)
                height = textHeight(display);
            if (diff > 0.001 || diff < -0.001) {
                updateLineHeight(cur.line, height);
                updateWidgetHeight(cur.line);
                if (cur.rest)
                    for (var j = 0; j < cur.rest.length; j++)
                        updateWidgetHeight(cur.rest[j]);
            }
        }
    }
    function updateWidgetHeight(line) {
        if (line.widgets)
            for (var i = 0; i < line.widgets.length; ++i)
                line.widgets[i].height = line.widgets[i].node.offsetHeight;
    }
    function getDimensions(cm) {
        var d = cm.display, left = {}, width = {};
        for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
            left[cm.options.gutters[i]] = n.offsetLeft;
            width[cm.options.gutters[i]] = n.offsetWidth;
        }
        return {
            fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth
        };
    }
    function patchDisplay(cm, updateNumbersFrom, dims) {
        var display = cm.display, lineNumbers = cm.options.lineNumbers;
        var container = display.lineDiv, cur = container.firstChild;
        function rm(node) {
            var next = node.nextSibling;
            if (webkit && mac && cm.display.currentWheelTarget == node)
                node.style.display = 'none';
            else
                node.parentNode.removeChild(node);
            return next;
        }
        var view = display.view, lineN = display.viewFrom;
        for (var i = 0; i < view.length; i++) {
            var lineView = view[i];
            if (lineView.hidden) {
            } else if (!lineView.node) {
                var node = buildLineElement(cm, lineView, lineN, dims);
                container.insertBefore(node, cur);
            } else {
                while (cur != lineView.node)
                    cur = rm(cur);
                var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
                if (lineView.changes) {
                    if (indexOf(lineView.changes, 'gutter') > -1)
                        updateNumber = false;
                    updateLineForChanges(cm, lineView, lineN, dims);
                }
                if (updateNumber) {
                    removeChildren(lineView.lineNumber);
                    lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
                }
                cur = lineView.node.nextSibling;
            }
            lineN += lineView.size;
        }
        while (cur)
            cur = rm(cur);
    }
    function updateLineForChanges(cm, lineView, lineN, dims) {
        for (var j = 0; j < lineView.changes.length; j++) {
            var type = lineView.changes[j];
            if (type == 'text')
                updateLineText(cm, lineView);
            else if (type == 'gutter')
                updateLineGutter(cm, lineView, lineN, dims);
            else if (type == 'class')
                updateLineClasses(lineView);
            else if (type == 'widget')
                updateLineWidgets(lineView, dims);
        }
        lineView.changes = null;
    }
    function ensureLineWrapped(lineView) {
        if (lineView.node == lineView.text) {
            lineView.node = elt('div', null, null, 'position: relative');
            if (lineView.text.parentNode)
                lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
            lineView.node.appendChild(lineView.text);
            if (ie && ie_version < 8)
                lineView.node.style.zIndex = 2;
        }
        return lineView.node;
    }
    function updateLineBackground(lineView) {
        var cls = lineView.bgClass ? lineView.bgClass + ' ' + (lineView.line.bgClass || '') : lineView.line.bgClass;
        if (cls)
            cls += ' CodeMirror-linebackground';
        if (lineView.background) {
            if (cls)
                lineView.background.className = cls;
            else {
                lineView.background.parentNode.removeChild(lineView.background);
                lineView.background = null;
            }
        } else if (cls) {
            var wrap = ensureLineWrapped(lineView);
            lineView.background = wrap.insertBefore(elt('div', null, cls), wrap.firstChild);
        }
    }
    function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;
        if (ext && ext.line == lineView.line) {
            cm.display.externalMeasured = null;
            lineView.measure = ext.measure;
            return ext.built;
        }
        return buildLineContent(cm, lineView);
    }
    function updateLineText(cm, lineView) {
        var cls = lineView.text.className;
        var built = getLineContent(cm, lineView);
        if (lineView.text == lineView.node)
            lineView.node = built.pre;
        lineView.text.parentNode.replaceChild(built.pre, lineView.text);
        lineView.text = built.pre;
        if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
            lineView.bgClass = built.bgClass;
            lineView.textClass = built.textClass;
            updateLineClasses(lineView);
        } else if (cls) {
            lineView.text.className = cls;
        }
    }
    function updateLineClasses(lineView) {
        updateLineBackground(lineView);
        if (lineView.line.wrapClass)
            ensureLineWrapped(lineView).className = lineView.line.wrapClass;
        else if (lineView.node != lineView.text)
            lineView.node.className = '';
        var textClass = lineView.textClass ? lineView.textClass + ' ' + (lineView.line.textClass || '') : lineView.line.textClass;
        lineView.text.className = textClass || '';
    }
    function updateLineGutter(cm, lineView, lineN, dims) {
        if (lineView.gutter) {
            lineView.node.removeChild(lineView.gutter);
            lineView.gutter = null;
        }
        var markers = lineView.line.gutterMarkers;
        if (cm.options.lineNumbers || markers) {
            var wrap = ensureLineWrapped(lineView);
            var gutterWrap = lineView.gutter = wrap.insertBefore(elt('div', null, 'CodeMirror-gutter-wrapper', 'position: absolute; left: ' + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + 'px'), lineView.text);
            if (cm.options.lineNumbers && (!markers || !markers['CodeMirror-linenumbers']))
                lineView.lineNumber = gutterWrap.appendChild(elt('div', lineNumberFor(cm.options, lineN), 'CodeMirror-linenumber CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft['CodeMirror-linenumbers'] + 'px; width: ' + cm.display.lineNumInnerWidth + 'px'));
            if (markers)
                for (var k = 0; k < cm.options.gutters.length; ++k) {
                    var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
                    if (found)
                        gutterWrap.appendChild(elt('div', [found], 'CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft[id] + 'px; width: ' + dims.gutterWidth[id] + 'px'));
                }
        }
    }
    function updateLineWidgets(lineView, dims) {
        if (lineView.alignable)
            lineView.alignable = null;
        for (var node = lineView.node.firstChild, next; node; node = next) {
            var next = node.nextSibling;
            if (node.className == 'CodeMirror-linewidget')
                lineView.node.removeChild(node);
        }
        insertLineWidgets(lineView, dims);
    }
    function buildLineElement(cm, lineView, lineN, dims) {
        var built = getLineContent(cm, lineView);
        lineView.text = lineView.node = built.pre;
        if (built.bgClass)
            lineView.bgClass = built.bgClass;
        if (built.textClass)
            lineView.textClass = built.textClass;
        updateLineClasses(lineView);
        updateLineGutter(cm, lineView, lineN, dims);
        insertLineWidgets(lineView, dims);
        return lineView.node;
    }
    function insertLineWidgets(lineView, dims) {
        insertLineWidgetsFor(lineView.line, lineView, dims, true);
        if (lineView.rest)
            for (var i = 0; i < lineView.rest.length; i++)
                insertLineWidgetsFor(lineView.rest[i], lineView, dims, false);
    }
    function insertLineWidgetsFor(line, lineView, dims, allowAbove) {
        if (!line.widgets)
            return;
        var wrap = ensureLineWrapped(lineView);
        for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
            var widget = ws[i], node = elt('div', [widget.node], 'CodeMirror-linewidget');
            if (!widget.handleMouseEvents)
                node.ignoreEvents = true;
            positionLineWidget(widget, node, lineView, dims);
            if (allowAbove && widget.above)
                wrap.insertBefore(node, lineView.gutter || lineView.text);
            else
                wrap.appendChild(node);
            signalLater(widget, 'redraw');
        }
    }
    function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
            (lineView.alignable || (lineView.alignable = [])).push(node);
            var width = dims.wrapperWidth;
            node.style.left = dims.fixedPos + 'px';
            if (!widget.coverGutter) {
                width -= dims.gutterTotalWidth;
                node.style.paddingLeft = dims.gutterTotalWidth + 'px';
            }
            node.style.width = width + 'px';
        }
        if (widget.coverGutter) {
            node.style.zIndex = 5;
            node.style.position = 'relative';
            if (!widget.noHScroll)
                node.style.marginLeft = -dims.gutterTotalWidth + 'px';
        }
    }
    var Pos = CodeMirror.Pos = function (line, ch) {
        if (!(this instanceof Pos))
            return new Pos(line, ch);
        this.line = line;
        this.ch = ch;
    };
    var cmp = CodeMirror.cmpPos = function (a, b) {
        return a.line - b.line || a.ch - b.ch;
    };
    function copyPos(x) {
        return Pos(x.line, x.ch);
    }
    function maxPos(a, b) {
        return cmp(a, b) < 0 ? b : a;
    }
    function minPos(a, b) {
        return cmp(a, b) < 0 ? a : b;
    }
    function Selection(ranges, primIndex) {
        this.ranges = ranges;
        this.primIndex = primIndex;
    }
    Selection.prototype = {
        primary: function () {
            return this.ranges[this.primIndex];
        },
        equals: function (other) {
            if (other == this)
                return true;
            if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length)
                return false;
            for (var i = 0; i < this.ranges.length; i++) {
                var here = this.ranges[i], there = other.ranges[i];
                if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0)
                    return false;
            }
            return true;
        },
        deepCopy: function () {
            for (var out = [], i = 0; i < this.ranges.length; i++)
                out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
            return new Selection(out, this.primIndex);
        },
        somethingSelected: function () {
            for (var i = 0; i < this.ranges.length; i++)
                if (!this.ranges[i].empty())
                    return true;
            return false;
        },
        contains: function (pos, end) {
            if (!end)
                end = pos;
            for (var i = 0; i < this.ranges.length; i++) {
                var range = this.ranges[i];
                if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
                    return i;
            }
            return -1;
        }
    };
    function Range(anchor, head) {
        this.anchor = anchor;
        this.head = head;
    }
    Range.prototype = {
        from: function () {
            return minPos(this.anchor, this.head);
        },
        to: function () {
            return maxPos(this.anchor, this.head);
        },
        empty: function () {
            return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
        }
    };
    function normalizeSelection(ranges, primIndex) {
        var prim = ranges[primIndex];
        ranges.sort(function (a, b) {
            return cmp(a.from(), b.from());
        });
        primIndex = indexOf(ranges, prim);
        for (var i = 1; i < ranges.length; i++) {
            var cur = ranges[i], prev = ranges[i - 1];
            if (cmp(prev.to(), cur.from()) >= 0) {
                var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
                var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
                if (i <= primIndex)
                    --primIndex;
                ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
            }
        }
        return new Selection(ranges, primIndex);
    }
    function simpleSelection(anchor, head) {
        return new Selection([new Range(anchor, head || anchor)], 0);
    }
    function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
    }
    function clipPos(doc, pos) {
        if (pos.line < doc.first)
            return Pos(doc.first, 0);
        var last = doc.first + doc.size - 1;
        if (pos.line > last)
            return Pos(last, getLine(doc, last).text.length);
        return clipToLen(pos, getLine(doc, pos.line).text.length);
    }
    function clipToLen(pos, linelen) {
        var ch = pos.ch;
        if (ch == null || ch > linelen)
            return Pos(pos.line, linelen);
        else if (ch < 0)
            return Pos(pos.line, 0);
        else
            return pos;
    }
    function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size;
    }
    function clipPosArray(doc, array) {
        for (var out = [], i = 0; i < array.length; i++)
            out[i] = clipPos(doc, array[i]);
        return out;
    }
    function extendRange(doc, range, head, other) {
        if (doc.cm && doc.cm.display.shift || doc.extend) {
            var anchor = range.anchor;
            if (other) {
                var posBefore = cmp(head, anchor) < 0;
                if (posBefore != cmp(other, anchor) < 0) {
                    anchor = head;
                    head = other;
                } else if (posBefore != cmp(head, other) < 0) {
                    head = other;
                }
            }
            return new Range(anchor, head);
        } else {
            return new Range(other || head, head);
        }
    }
    function extendSelection(doc, head, other, options) {
        setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
    }
    function extendSelections(doc, heads, options) {
        for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
            out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
        var newSel = normalizeSelection(out, doc.sel.primIndex);
        setSelection(doc, newSel, options);
    }
    function replaceOneSelection(doc, i, range, options) {
        var ranges = doc.sel.ranges.slice(0);
        ranges[i] = range;
        setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
    }
    function setSimpleSelection(doc, anchor, head, options) {
        setSelection(doc, simpleSelection(anchor, head), options);
    }
    function filterSelectionChange(doc, sel) {
        var obj = {
            ranges: sel.ranges,
            update: function (ranges) {
                this.ranges = [];
                for (var i = 0; i < ranges.length; i++)
                    this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
            }
        };
        signal(doc, 'beforeSelectionChange', doc, obj);
        if (doc.cm)
            signal(doc.cm, 'beforeSelectionChange', doc.cm, obj);
        if (obj.ranges != sel.ranges)
            return normalizeSelection(obj.ranges, obj.ranges.length - 1);
        else
            return sel;
    }
    function setSelectionReplaceHistory(doc, sel, options) {
        var done = doc.history.done, last = lst(done);
        if (last && last.ranges) {
            done[done.length - 1] = sel;
            setSelectionNoUndo(doc, sel, options);
        } else {
            setSelection(doc, sel, options);
        }
    }
    function setSelection(doc, sel, options) {
        setSelectionNoUndo(doc, sel, options);
        addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
    }
    function setSelectionNoUndo(doc, sel, options) {
        if (hasHandler(doc, 'beforeSelectionChange') || doc.cm && hasHandler(doc.cm, 'beforeSelectionChange'))
            sel = filterSelectionChange(doc, sel);
        var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
        setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
        if (!(options && options.scroll === false) && doc.cm)
            ensureCursorVisible(doc.cm);
    }
    function setSelectionInner(doc, sel) {
        if (sel.equals(doc.sel))
            return;
        doc.sel = sel;
        if (doc.cm) {
            doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
            signalCursorActivity(doc.cm);
        }
        signalLater(doc, 'cursorActivity', doc);
    }
    function reCheckSelection(doc) {
        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
    }
    function skipAtomicInSelection(doc, sel, bias, mayClear) {
        var out;
        for (var i = 0; i < sel.ranges.length; i++) {
            var range = sel.ranges[i];
            var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);
            var newHead = skipAtomic(doc, range.head, bias, mayClear);
            if (out || newAnchor != range.anchor || newHead != range.head) {
                if (!out)
                    out = sel.ranges.slice(0, i);
                out[i] = new Range(newAnchor, newHead);
            }
        }
        return out ? normalizeSelection(out, sel.primIndex) : sel;
    }
    function skipAtomic(doc, pos, bias, mayClear) {
        var flipped = false, curPos = pos;
        var dir = bias || 1;
        doc.cantEdit = false;
        search:
            for (;;) {
                var line = getLine(doc, curPos.line);
                if (line.markedSpans) {
                    for (var i = 0; i < line.markedSpans.length; ++i) {
                        var sp = line.markedSpans[i], m = sp.marker;
                        if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
                            if (mayClear) {
                                signal(m, 'beforeCursorEnter');
                                if (m.explicitlyCleared) {
                                    if (!line.markedSpans)
                                        break;
                                    else {
                                        --i;
                                        continue;
                                    }
                                }
                            }
                            if (!m.atomic)
                                continue;
                            var newPos = m.find(dir < 0 ? -1 : 1);
                            if (cmp(newPos, curPos) == 0) {
                                newPos.ch += dir;
                                if (newPos.ch < 0) {
                                    if (newPos.line > doc.first)
                                        newPos = clipPos(doc, Pos(newPos.line - 1));
                                    else
                                        newPos = null;
                                } else if (newPos.ch > line.text.length) {
                                    if (newPos.line < doc.first + doc.size - 1)
                                        newPos = Pos(newPos.line + 1, 0);
                                    else
                                        newPos = null;
                                }
                                if (!newPos) {
                                    if (flipped) {
                                        if (!mayClear)
                                            return skipAtomic(doc, pos, bias, true);
                                        doc.cantEdit = true;
                                        return Pos(doc.first, 0);
                                    }
                                    flipped = true;
                                    newPos = pos;
                                    dir = -dir;
                                }
                            }
                            curPos = newPos;
                            continue search;
                        }
                    }
                }
                return curPos;
            }
    }
    function drawSelection(cm) {
        var display = cm.display, doc = cm.doc, result = {};
        var curFragment = result.cursors = document.createDocumentFragment();
        var selFragment = result.selection = document.createDocumentFragment();
        for (var i = 0; i < doc.sel.ranges.length; i++) {
            var range = doc.sel.ranges[i];
            var collapsed = range.empty();
            if (collapsed || cm.options.showCursorWhenSelecting)
                drawSelectionCursor(cm, range, curFragment);
            if (!collapsed)
                drawSelectionRange(cm, range, selFragment);
        }
        if (cm.options.moveInputWithCursor) {
            var headPos = cursorCoords(cm, doc.sel.primary().head, 'div');
            var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
            result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
            result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
        }
        return result;
    }
    function showSelection(cm, drawn) {
        removeChildrenAndAdd(cm.display.cursorDiv, drawn.cursors);
        removeChildrenAndAdd(cm.display.selectionDiv, drawn.selection);
        if (drawn.teTop != null) {
            cm.display.inputDiv.style.top = drawn.teTop + 'px';
            cm.display.inputDiv.style.left = drawn.teLeft + 'px';
        }
    }
    function updateSelection(cm) {
        showSelection(cm, drawSelection(cm));
    }
    function drawSelectionCursor(cm, range, output) {
        var pos = cursorCoords(cm, range.head, 'div', null, null, !cm.options.singleCursorHeightPerLine);
        var cursor = output.appendChild(elt('div', '\xA0', 'CodeMirror-cursor'));
        cursor.style.left = pos.left + 'px';
        cursor.style.top = pos.top + 'px';
        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + 'px';
        if (pos.other) {
            var otherCursor = output.appendChild(elt('div', '\xA0', 'CodeMirror-cursor CodeMirror-secondarycursor'));
            otherCursor.style.display = '';
            otherCursor.style.left = pos.other.left + 'px';
            otherCursor.style.top = pos.other.top + 'px';
            otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + 'px';
        }
    }
    function drawSelectionRange(cm, range, output) {
        var display = cm.display, doc = cm.doc;
        var fragment = document.createDocumentFragment();
        var padding = paddingH(cm.display), leftSide = padding.left, rightSide = display.lineSpace.offsetWidth - padding.right;
        function add(left, top, width, bottom) {
            if (top < 0)
                top = 0;
            top = Math.round(top);
            bottom = Math.round(bottom);
            fragment.appendChild(elt('div', null, 'CodeMirror-selected', 'position: absolute; left: ' + left + 'px; top: ' + top + 'px; width: ' + (width == null ? rightSide - left : width) + 'px; height: ' + (bottom - top) + 'px'));
        }
        function drawForLine(line, fromArg, toArg) {
            var lineObj = getLine(doc, line);
            var lineLen = lineObj.text.length;
            var start, end;
            function coords(ch, bias) {
                return charCoords(cm, Pos(line, ch), 'div', lineObj, bias);
            }
            iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
                var leftPos = coords(from, 'left'), rightPos, left, right;
                if (from == to) {
                    rightPos = leftPos;
                    left = right = leftPos.left;
                } else {
                    rightPos = coords(to - 1, 'right');
                    if (dir == 'rtl') {
                        var tmp = leftPos;
                        leftPos = rightPos;
                        rightPos = tmp;
                    }
                    left = leftPos.left;
                    right = rightPos.right;
                }
                if (fromArg == null && from == 0)
                    left = leftSide;
                if (rightPos.top - leftPos.top > 3) {
                    add(left, leftPos.top, null, leftPos.bottom);
                    left = leftSide;
                    if (leftPos.bottom < rightPos.top)
                        add(left, leftPos.bottom, null, rightPos.top);
                }
                if (toArg == null && to == lineLen)
                    right = rightSide;
                if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
                    start = leftPos;
                if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
                    end = rightPos;
                if (left < leftSide + 1)
                    left = leftSide;
                add(left, rightPos.top, right - left, rightPos.bottom);
            });
            return {
                start: start,
                end: end
            };
        }
        var sFrom = range.from(), sTo = range.to();
        if (sFrom.line == sTo.line) {
            drawForLine(sFrom.line, sFrom.ch, sTo.ch);
        } else {
            var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
            var singleVLine = visualLine(fromLine) == visualLine(toLine);
            var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
            var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
            if (singleVLine) {
                if (leftEnd.top < rightStart.top - 2) {
                    add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
                    add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
                } else {
                    add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
                }
            }
            if (leftEnd.bottom < rightStart.top)
                add(leftSide, leftEnd.bottom, null, rightStart.top);
        }
        output.appendChild(fragment);
    }
    function restartBlink(cm) {
        if (!cm.state.focused)
            return;
        var display = cm.display;
        clearInterval(display.blinker);
        var on = true;
        display.cursorDiv.style.visibility = '';
        if (cm.options.cursorBlinkRate > 0)
            display.blinker = setInterval(function () {
                display.cursorDiv.style.visibility = (on = !on) ? '' : 'hidden';
            }, cm.options.cursorBlinkRate);
        else if (cm.options.cursorBlinkRate < 0)
            display.cursorDiv.style.visibility = 'hidden';
    }
    function startWorker(cm, time) {
        if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
            cm.state.highlight.set(time, bind(highlightWorker, cm));
    }
    function highlightWorker(cm) {
        var doc = cm.doc;
        if (doc.frontier < doc.first)
            doc.frontier = doc.first;
        if (doc.frontier >= cm.display.viewTo)
            return;
        var end = +new Date() + cm.options.workTime;
        var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
        var changedLines = [];
        doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
            if (doc.frontier >= cm.display.viewFrom) {
                var oldStyles = line.styles;
                var highlighted = highlightLine(cm, line, state, true);
                line.styles = highlighted.styles;
                var oldCls = line.styleClasses, newCls = highlighted.classes;
                if (newCls)
                    line.styleClasses = newCls;
                else if (oldCls)
                    line.styleClasses = null;
                var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
                for (var i = 0; !ischange && i < oldStyles.length; ++i)
                    ischange = oldStyles[i] != line.styles[i];
                if (ischange)
                    changedLines.push(doc.frontier);
                line.stateAfter = copyState(doc.mode, state);
            } else {
                processLine(cm, line.text, state);
                line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
            }
            ++doc.frontier;
            if (+new Date() > end) {
                startWorker(cm, cm.options.workDelay);
                return true;
            }
        });
        if (changedLines.length)
            runInOp(cm, function () {
                for (var i = 0; i < changedLines.length; i++)
                    regLineChange(cm, changedLines[i], 'text');
            });
    }
    function findStartLine(cm, n, precise) {
        var minindent, minline, doc = cm.doc;
        var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
        for (var search = n; search > lim; --search) {
            if (search <= doc.first)
                return doc.first;
            var line = getLine(doc, search - 1);
            if (line.stateAfter && (!precise || search <= doc.frontier))
                return search;
            var indented = countColumn(line.text, null, cm.options.tabSize);
            if (minline == null || minindent > indented) {
                minline = search - 1;
                minindent = indented;
            }
        }
        return minline;
    }
    function getStateBefore(cm, n, precise) {
        var doc = cm.doc, display = cm.display;
        if (!doc.mode.startState)
            return true;
        var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
        if (!state)
            state = startState(doc.mode);
        else
            state = copyState(doc.mode, state);
        doc.iter(pos, n, function (line) {
            processLine(cm, line.text, state);
            var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
            line.stateAfter = save ? copyState(doc.mode, state) : null;
            ++pos;
        });
        if (precise)
            doc.frontier = pos;
        return state;
    }
    function paddingTop(display) {
        return display.lineSpace.offsetTop;
    }
    function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
    }
    function paddingH(display) {
        if (display.cachedPaddingH)
            return display.cachedPaddingH;
        var e = removeChildrenAndAdd(display.measure, elt('pre', 'x'));
        var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
        var data = {
            left: parseInt(style.paddingLeft),
            right: parseInt(style.paddingRight)
        };
        if (!isNaN(data.left) && !isNaN(data.right))
            display.cachedPaddingH = data;
        return data;
    }
    function ensureLineHeights(cm, lineView, rect) {
        var wrapping = cm.options.lineWrapping;
        var curWidth = wrapping && cm.display.scroller.clientWidth;
        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
            var heights = lineView.measure.heights = [];
            if (wrapping) {
                lineView.measure.width = curWidth;
                var rects = lineView.text.firstChild.getClientRects();
                for (var i = 0; i < rects.length - 1; i++) {
                    var cur = rects[i], next = rects[i + 1];
                    if (Math.abs(cur.bottom - next.bottom) > 2)
                        heights.push((cur.bottom + next.top) / 2 - rect.top);
                }
            }
            heights.push(rect.bottom - rect.top);
        }
    }
    function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line)
            return {
                map: lineView.measure.map,
                cache: lineView.measure.cache
            };
        for (var i = 0; i < lineView.rest.length; i++)
            if (lineView.rest[i] == line)
                return {
                    map: lineView.measure.maps[i],
                    cache: lineView.measure.caches[i]
                };
        for (var i = 0; i < lineView.rest.length; i++)
            if (lineNo(lineView.rest[i]) > lineN)
                return {
                    map: lineView.measure.maps[i],
                    cache: lineView.measure.caches[i],
                    before: true
                };
    }
    function updateExternalMeasurement(cm, line) {
        line = visualLine(line);
        var lineN = lineNo(line);
        var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
        view.lineN = lineN;
        var built = view.built = buildLineContent(cm, view);
        view.text = built.pre;
        removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
        return view;
    }
    function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
    }
    function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
            return cm.display.view[findViewIndex(cm, lineN)];
        var ext = cm.display.externalMeasured;
        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
            return ext;
    }
    function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line);
        var view = findViewForLine(cm, lineN);
        if (view && !view.text)
            view = null;
        else if (view && view.changes)
            updateLineForChanges(cm, view, lineN, getDimensions(cm));
        if (!view)
            view = updateExternalMeasurement(cm, line);
        var info = mapFromLineView(view, line, lineN);
        return {
            line: line,
            view: view,
            rect: null,
            map: info.map,
            cache: info.cache,
            before: info.before,
            hasHeights: false
        };
    }
    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        if (prepared.before)
            ch = -1;
        var key = ch + (bias || ''), found;
        if (prepared.cache.hasOwnProperty(key)) {
            found = prepared.cache[key];
        } else {
            if (!prepared.rect)
                prepared.rect = prepared.view.text.getBoundingClientRect();
            if (!prepared.hasHeights) {
                ensureLineHeights(cm, prepared.view, prepared.rect);
                prepared.hasHeights = true;
            }
            found = measureCharInner(cm, prepared, ch, bias);
            if (!found.bogus)
                prepared.cache[key] = found;
        }
        return {
            left: found.left,
            right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom
        };
    }
    var nullRect = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    };
    function measureCharInner(cm, prepared, ch, bias) {
        var map = prepared.map;
        var node, start, end, collapse;
        for (var i = 0; i < map.length; i += 3) {
            var mStart = map[i], mEnd = map[i + 1];
            if (ch < mStart) {
                start = 0;
                end = 1;
                collapse = 'left';
            } else if (ch < mEnd) {
                start = ch - mStart;
                end = start + 1;
            } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
                end = mEnd - mStart;
                start = end - 1;
                if (ch >= mEnd)
                    collapse = 'right';
            }
            if (start != null) {
                node = map[i + 2];
                if (mStart == mEnd && bias == (node.insertLeft ? 'left' : 'right'))
                    collapse = bias;
                if (bias == 'left' && start == 0)
                    while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
                        node = map[(i -= 3) + 2];
                        collapse = 'left';
                    }
                if (bias == 'right' && start == mEnd - mStart)
                    while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
                        node = map[(i += 3) + 2];
                        collapse = 'right';
                    }
                break;
            }
        }
        var rect;
        if (node.nodeType == 3) {
            for (;;) {
                while (start && isExtendingChar(prepared.line.text.charAt(mStart + start)))
                    --start;
                while (mStart + end < mEnd && isExtendingChar(prepared.line.text.charAt(mStart + end)))
                    ++end;
                if (ie && ie_version < 9 && start == 0 && end == mEnd - mStart) {
                    rect = node.parentNode.getBoundingClientRect();
                } else if (ie && cm.options.lineWrapping) {
                    var rects = range(node, start, end).getClientRects();
                    if (rects.length)
                        rect = rects[bias == 'right' ? rects.length - 1 : 0];
                    else
                        rect = nullRect;
                } else {
                    rect = range(node, start, end).getBoundingClientRect() || nullRect;
                }
                if (rect.left || rect.right || start == 0)
                    break;
                end = start;
                start = start - 1;
                collapse = 'right';
            }
        } else {
            if (start > 0)
                collapse = bias = 'right';
            var rects;
            if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
                rect = rects[bias == 'right' ? rects.length - 1 : 0];
            else
                rect = node.getBoundingClientRect();
        }
        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
            var rSpan = node.parentNode.getClientRects()[0];
            if (rSpan)
                rect = {
                    left: rSpan.left,
                    right: rSpan.left + charWidth(cm.display),
                    top: rSpan.top,
                    bottom: rSpan.bottom
                };
            else
                rect = nullRect;
        }
        if (ie && ie_version < 11)
            rect = maybeUpdateRectForZooming(cm.display.measure, rect);
        var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
        var mid = (rtop + rbot) / 2;
        var heights = prepared.view.measure.heights;
        for (var i = 0; i < heights.length - 1; i++)
            if (mid < heights[i])
                break;
        var top = i ? heights[i - 1] : 0, bot = heights[i];
        var result = {
            left: (collapse == 'right' ? rect.right : rect.left) - prepared.rect.left,
            right: (collapse == 'left' ? rect.left : rect.right) - prepared.rect.left,
            top: top,
            bottom: bot
        };
        if (!rect.left && !rect.right)
            result.bogus = true;
        if (!cm.options.singleCursorHeightPerLine) {
            result.rtop = rtop;
            result.rbottom = rbot;
        }
        return result;
    }
    function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
            return rect;
        var scaleX = screen.logicalXDPI / screen.deviceXDPI;
        var scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return {
            left: rect.left * scaleX,
            right: rect.right * scaleX,
            top: rect.top * scaleY,
            bottom: rect.bottom * scaleY
        };
    }
    function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure) {
            lineView.measure.cache = {};
            lineView.measure.heights = null;
            if (lineView.rest)
                for (var i = 0; i < lineView.rest.length; i++)
                    lineView.measure.caches[i] = {};
        }
    }
    function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null;
        removeChildren(cm.display.lineMeasure);
        for (var i = 0; i < cm.display.view.length; i++)
            clearLineMeasurementCacheFor(cm.display.view[i]);
    }
    function clearCaches(cm) {
        clearLineMeasurementCache(cm);
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
        if (!cm.options.lineWrapping)
            cm.display.maxLineChanged = true;
        cm.display.lineNumChars = null;
    }
    function pageScrollX() {
        return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
    }
    function pageScrollY() {
        return window.pageYOffset || (document.documentElement || document.body).scrollTop;
    }
    function intoCoordSystem(cm, lineObj, rect, context) {
        if (lineObj.widgets)
            for (var i = 0; i < lineObj.widgets.length; ++i)
                if (lineObj.widgets[i].above) {
                    var size = widgetHeight(lineObj.widgets[i]);
                    rect.top += size;
                    rect.bottom += size;
                }
        if (context == 'line')
            return rect;
        if (!context)
            context = 'local';
        var yOff = heightAtLine(lineObj);
        if (context == 'local')
            yOff += paddingTop(cm.display);
        else
            yOff -= cm.display.viewOffset;
        if (context == 'page' || context == 'window') {
            var lOff = cm.display.lineSpace.getBoundingClientRect();
            yOff += lOff.top + (context == 'window' ? 0 : pageScrollY());
            var xOff = lOff.left + (context == 'window' ? 0 : pageScrollX());
            rect.left += xOff;
            rect.right += xOff;
        }
        rect.top += yOff;
        rect.bottom += yOff;
        return rect;
    }
    function fromCoordSystem(cm, coords, context) {
        if (context == 'div')
            return coords;
        var left = coords.left, top = coords.top;
        if (context == 'page') {
            left -= pageScrollX();
            top -= pageScrollY();
        } else if (context == 'local' || !context) {
            var localBox = cm.display.sizer.getBoundingClientRect();
            left += localBox.left;
            top += localBox.top;
        }
        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return {
            left: left - lineSpaceBox.left,
            top: top - lineSpaceBox.top
        };
    }
    function charCoords(cm, pos, context, lineObj, bias) {
        if (!lineObj)
            lineObj = getLine(cm.doc, pos.line);
        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
    }
    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        lineObj = lineObj || getLine(cm.doc, pos.line);
        if (!preparedMeasure)
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
        function get(ch, right) {
            var m = measureCharPrepared(cm, preparedMeasure, ch, right ? 'right' : 'left', varHeight);
            if (right)
                m.left = m.right;
            else
                m.right = m.left;
            return intoCoordSystem(cm, lineObj, m, context);
        }
        function getBidi(ch, partPos) {
            var part = order[partPos], right = part.level % 2;
            if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
                part = order[--partPos];
                ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
                right = true;
            } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
                part = order[++partPos];
                ch = bidiLeft(part) - part.level % 2;
                right = false;
            }
            if (right && ch == part.to && ch > part.from)
                return get(ch - 1);
            return get(ch, right);
        }
        var order = getOrder(lineObj), ch = pos.ch;
        if (!order)
            return get(ch);
        var partPos = getBidiPartAt(order, ch);
        var val = getBidi(ch, partPos);
        if (bidiOther != null)
            val.other = getBidi(ch, bidiOther);
        return val;
    }
    function estimateCoords(cm, pos) {
        var left = 0, pos = clipPos(cm.doc, pos);
        if (!cm.options.lineWrapping)
            left = charWidth(cm.display) * pos.ch;
        var lineObj = getLine(cm.doc, pos.line);
        var top = heightAtLine(lineObj) + paddingTop(cm.display);
        return {
            left: left,
            right: left,
            top: top,
            bottom: top + lineObj.height
        };
    }
    function PosWithInfo(line, ch, outside, xRel) {
        var pos = Pos(line, ch);
        pos.xRel = xRel;
        if (outside)
            pos.outside = true;
        return pos;
    }
    function coordsChar(cm, x, y) {
        var doc = cm.doc;
        y += cm.display.viewOffset;
        if (y < 0)
            return PosWithInfo(doc.first, 0, true, -1);
        var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
        if (lineN > last)
            return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
        if (x < 0)
            x = 0;
        var lineObj = getLine(doc, lineN);
        for (;;) {
            var found = coordsCharInner(cm, lineObj, lineN, x, y);
            var merged = collapsedSpanAtEnd(lineObj);
            var mergedPos = merged && merged.find(0, true);
            if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
                lineN = lineNo(lineObj = mergedPos.to.line);
            else
                return found;
        }
    }
    function coordsCharInner(cm, lineObj, lineNo, x, y) {
        var innerOff = y - heightAtLine(lineObj);
        var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
        var preparedMeasure = prepareMeasureForLine(cm, lineObj);
        function getX(ch) {
            var sp = cursorCoords(cm, Pos(lineNo, ch), 'line', lineObj, preparedMeasure);
            wrongLine = true;
            if (innerOff > sp.bottom)
                return sp.left - adjust;
            else if (innerOff < sp.top)
                return sp.left + adjust;
            else
                wrongLine = false;
            return sp.left;
        }
        var bidi = getOrder(lineObj), dist = lineObj.text.length;
        var from = lineLeft(lineObj), to = lineRight(lineObj);
        var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;
        if (x > toX)
            return PosWithInfo(lineNo, to, toOutside, 1);
        for (;;) {
            if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
                var ch = x < fromX || x - fromX <= toX - x ? from : to;
                var xDiff = x - (ch == from ? fromX : toX);
                while (isExtendingChar(lineObj.text.charAt(ch)))
                    ++ch;
                var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
                return pos;
            }
            var step = Math.ceil(dist / 2), middle = from + step;
            if (bidi) {
                middle = from;
                for (var i = 0; i < step; ++i)
                    middle = moveVisually(lineObj, middle, 1);
            }
            var middleX = getX(middle);
            if (middleX > x) {
                to = middle;
                toX = middleX;
                if (toOutside = wrongLine)
                    toX += 1000;
                dist = step;
            } else {
                from = middle;
                fromX = middleX;
                fromOutside = wrongLine;
                dist -= step;
            }
        }
    }
    var measureText;
    function textHeight(display) {
        if (display.cachedTextHeight != null)
            return display.cachedTextHeight;
        if (measureText == null) {
            measureText = elt('pre');
            for (var i = 0; i < 49; ++i) {
                measureText.appendChild(document.createTextNode('x'));
                measureText.appendChild(elt('br'));
            }
            measureText.appendChild(document.createTextNode('x'));
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        if (height > 3)
            display.cachedTextHeight = height;
        removeChildren(display.measure);
        return height || 1;
    }
    function charWidth(display) {
        if (display.cachedCharWidth != null)
            return display.cachedCharWidth;
        var anchor = elt('span', 'xxxxxxxxxx');
        var pre = elt('pre', [anchor]);
        removeChildrenAndAdd(display.measure, pre);
        var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
        if (width > 2)
            display.cachedCharWidth = width;
        return width || 10;
    }
    var operationGroup = null;
    var nextOpId = 0;
    function startOperation(cm) {
        cm.curOp = {
            cm: cm,
            viewChanged: false,
            startHeight: cm.doc.height,
            forceUpdate: false,
            updateInput: null,
            typing: false,
            changeObjs: null,
            cursorActivityHandlers: null,
            cursorActivityCalled: 0,
            selectionChanged: false,
            updateMaxLine: false,
            scrollLeft: null,
            scrollTop: null,
            scrollToPos: null,
            id: ++nextOpId
        };
        if (operationGroup) {
            operationGroup.ops.push(cm.curOp);
        } else {
            cm.curOp.ownsGroup = operationGroup = {
                ops: [cm.curOp],
                delayedCallbacks: []
            };
        }
    }
    function fireCallbacksForOps(group) {
        var callbacks = group.delayedCallbacks, i = 0;
        do {
            for (; i < callbacks.length; i++)
                callbacks[i]();
            for (var j = 0; j < group.ops.length; j++) {
                var op = group.ops[j];
                if (op.cursorActivityHandlers)
                    while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
                        op.cursorActivityHandlers[op.cursorActivityCalled++](op.cm);
            }
        } while (i < callbacks.length);
    }
    function endOperation(cm) {
        var op = cm.curOp, group = op.ownsGroup;
        if (!group)
            return;
        try {
            fireCallbacksForOps(group);
        } finally {
            operationGroup = null;
            for (var i = 0; i < group.ops.length; i++)
                group.ops[i].cm.curOp = null;
            endOperations(group);
        }
    }
    function endOperations(group) {
        var ops = group.ops;
        for (var i = 0; i < ops.length; i++)
            endOperation_R1(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_W1(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_R2(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_W2(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_finish(ops[i]);
    }
    function endOperation_R1(op) {
        var cm = op.cm, display = cm.display;
        if (op.updateMaxLine)
            findMaxLine(cm);
        op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
        op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
            top: op.scrollTop,
            ensure: op.scrollToPos
        }, op.forceUpdate);
    }
    function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
    }
    function endOperation_R2(op) {
        var cm = op.cm, display = cm.display;
        if (op.updatedDisplay)
            updateHeightsInViewport(cm);
        op.barMeasure = measureForScrollbars(cm);
        if (display.maxLineChanged && !cm.options.lineWrapping) {
            op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
            op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo + scrollerCutOff - display.scroller.clientWidth);
        }
        if (op.updatedDisplay || op.selectionChanged)
            op.newSelectionNodes = drawSelection(cm);
    }
    function endOperation_W2(op) {
        var cm = op.cm;
        if (op.adjustWidthTo != null) {
            cm.display.sizer.style.minWidth = op.adjustWidthTo + 'px';
            if (op.maxScrollLeft < cm.doc.scrollLeft)
                setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
            cm.display.maxLineChanged = false;
        }
        if (op.newSelectionNodes)
            showSelection(cm, op.newSelectionNodes);
        if (op.updatedDisplay)
            setDocumentHeight(cm, op.barMeasure);
        if (op.updatedDisplay || op.startHeight != cm.doc.height)
            updateScrollbars(cm, op.barMeasure);
        if (op.selectionChanged)
            restartBlink(cm);
        if (cm.state.focused && op.updateInput)
            resetInput(cm, op.typing);
    }
    function endOperation_finish(op) {
        var cm = op.cm, display = cm.display, doc = cm.doc;
        if (op.adjustWidthTo != null && Math.abs(op.barMeasure.scrollWidth - cm.display.scroller.scrollWidth) > 1)
            updateScrollbars(cm);
        if (op.updatedDisplay)
            postUpdateDisplay(cm, op.update);
        if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
            display.wheelStartX = display.wheelStartY = null;
        if (op.scrollTop != null && display.scroller.scrollTop != op.scrollTop) {
            var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
            display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;
        }
        if (op.scrollLeft != null && display.scroller.scrollLeft != op.scrollLeft) {
            var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
            display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;
            alignHorizontally(cm);
        }
        if (op.scrollToPos) {
            var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
            if (op.scrollToPos.isCursor && cm.state.focused)
                maybeScrollWindow(cm, coords);
        }
        var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
        if (hidden)
            for (var i = 0; i < hidden.length; ++i)
                if (!hidden[i].lines.length)
                    signal(hidden[i], 'hide');
        if (unhidden)
            for (var i = 0; i < unhidden.length; ++i)
                if (unhidden[i].lines.length)
                    signal(unhidden[i], 'unhide');
        if (display.wrapper.offsetHeight)
            doc.scrollTop = cm.display.scroller.scrollTop;
        if (op.updatedDisplay && webkit) {
            if (cm.options.lineWrapping)
                checkForWebkitWidthBug(cm, op.barMeasure);
            if (op.barMeasure.scrollWidth > op.barMeasure.clientWidth && op.barMeasure.scrollWidth < op.barMeasure.clientWidth + 1 && !hScrollbarTakesSpace(cm))
                updateScrollbars(cm);
        }
        if (op.changeObjs)
            signal(cm, 'changes', cm, op.changeObjs);
    }
    function runInOp(cm, f) {
        if (cm.curOp)
            return f();
        startOperation(cm);
        try {
            return f();
        } finally {
            endOperation(cm);
        }
    }
    function operation(cm, f) {
        return function () {
            if (cm.curOp)
                return f.apply(cm, arguments);
            startOperation(cm);
            try {
                return f.apply(cm, arguments);
            } finally {
                endOperation(cm);
            }
        };
    }
    function methodOp(f) {
        return function () {
            if (this.curOp)
                return f.apply(this, arguments);
            startOperation(this);
            try {
                return f.apply(this, arguments);
            } finally {
                endOperation(this);
            }
        };
    }
    function docMethodOp(f) {
        return function () {
            var cm = this.cm;
            if (!cm || cm.curOp)
                return f.apply(this, arguments);
            startOperation(cm);
            try {
                return f.apply(this, arguments);
            } finally {
                endOperation(cm);
            }
        };
    }
    function LineView(doc, line, lineN) {
        this.line = line;
        this.rest = visualLineContinued(line);
        this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
        this.node = this.text = null;
        this.hidden = lineIsHidden(doc, line);
    }
    function buildViewArray(cm, from, to) {
        var array = [], nextPos;
        for (var pos = from; pos < to; pos = nextPos) {
            var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
            nextPos = pos + view.size;
            array.push(view);
        }
        return array;
    }
    function regChange(cm, from, to, lendiff) {
        if (from == null)
            from = cm.doc.first;
        if (to == null)
            to = cm.doc.first + cm.doc.size;
        if (!lendiff)
            lendiff = 0;
        var display = cm.display;
        if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from))
            display.updateLineNumbers = from;
        cm.curOp.viewChanged = true;
        if (from >= display.viewTo) {
            if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
                resetView(cm);
        } else if (to <= display.viewFrom) {
            if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
                resetView(cm);
            } else {
                display.viewFrom += lendiff;
                display.viewTo += lendiff;
            }
        } else if (from <= display.viewFrom && to >= display.viewTo) {
            resetView(cm);
        } else if (from <= display.viewFrom) {
            var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cut) {
                display.view = display.view.slice(cut.index);
                display.viewFrom = cut.lineN;
                display.viewTo += lendiff;
            } else {
                resetView(cm);
            }
        } else if (to >= display.viewTo) {
            var cut = viewCuttingPoint(cm, from, from, -1);
            if (cut) {
                display.view = display.view.slice(0, cut.index);
                display.viewTo = cut.lineN;
            } else {
                resetView(cm);
            }
        } else {
            var cutTop = viewCuttingPoint(cm, from, from, -1);
            var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cutTop && cutBot) {
                display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
                display.viewTo += lendiff;
            } else {
                resetView(cm);
            }
        }
        var ext = display.externalMeasured;
        if (ext) {
            if (to < ext.lineN)
                ext.lineN += lendiff;
            else if (from < ext.lineN + ext.size)
                display.externalMeasured = null;
        }
    }
    function regLineChange(cm, line, type) {
        cm.curOp.viewChanged = true;
        var display = cm.display, ext = cm.display.externalMeasured;
        if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
            display.externalMeasured = null;
        if (line < display.viewFrom || line >= display.viewTo)
            return;
        var lineView = display.view[findViewIndex(cm, line)];
        if (lineView.node == null)
            return;
        var arr = lineView.changes || (lineView.changes = []);
        if (indexOf(arr, type) == -1)
            arr.push(type);
    }
    function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
        cm.display.view = [];
        cm.display.viewOffset = 0;
    }
    function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo)
            return null;
        n -= cm.display.viewFrom;
        if (n < 0)
            return null;
        var view = cm.display.view;
        for (var i = 0; i < view.length; i++) {
            n -= view[i].size;
            if (n < 0)
                return i;
        }
    }
    function viewCuttingPoint(cm, oldN, newN, dir) {
        var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
            return {
                index: index,
                lineN: newN
            };
        for (var i = 0, n = cm.display.viewFrom; i < index; i++)
            n += view[i].size;
        if (n != oldN) {
            if (dir > 0) {
                if (index == view.length - 1)
                    return null;
                diff = n + view[index].size - oldN;
                index++;
            } else {
                diff = n - oldN;
            }
            oldN += diff;
            newN += diff;
        }
        while (visualLineNo(cm.doc, newN) != newN) {
            if (index == (dir < 0 ? 0 : view.length - 1))
                return null;
            newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
            index += dir;
        }
        return {
            index: index,
            lineN: newN
        };
    }
    function adjustView(cm, from, to) {
        var display = cm.display, view = display.view;
        if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
            display.view = buildViewArray(cm, from, to);
            display.viewFrom = from;
        } else {
            if (display.viewFrom > from)
                display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
            else if (display.viewFrom < from)
                display.view = display.view.slice(findViewIndex(cm, from));
            display.viewFrom = from;
            if (display.viewTo < to)
                display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
            else if (display.viewTo > to)
                display.view = display.view.slice(0, findViewIndex(cm, to));
        }
        display.viewTo = to;
    }
    function countDirtyView(cm) {
        var view = cm.display.view, dirty = 0;
        for (var i = 0; i < view.length; i++) {
            var lineView = view[i];
            if (!lineView.hidden && (!lineView.node || lineView.changes))
                ++dirty;
        }
        return dirty;
    }
    function slowPoll(cm) {
        if (cm.display.pollingFast)
            return;
        cm.display.poll.set(cm.options.pollInterval, function () {
            readInput(cm);
            if (cm.state.focused)
                slowPoll(cm);
        });
    }
    function fastPoll(cm) {
        var missed = false;
        cm.display.pollingFast = true;
        function p() {
            var changed = readInput(cm);
            if (!changed && !missed) {
                missed = true;
                cm.display.poll.set(60, p);
            } else {
                cm.display.pollingFast = false;
                slowPoll(cm);
            }
        }
        cm.display.poll.set(20, p);
    }
    var lastCopied = null;
    function readInput(cm) {
        var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc;
        if (!cm.state.focused || hasSelection(input) && !prevInput || isReadOnly(cm) || cm.options.disableInput)
            return false;
        if (cm.state.pasteIncoming && cm.state.fakedLastChar) {
            input.value = input.value.substring(0, input.value.length - 1);
            cm.state.fakedLastChar = false;
        }
        var text = input.value;
        if (text == prevInput && !cm.somethingSelected())
            return false;
        if (ie && ie_version >= 9 && cm.display.inputHasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
            resetInput(cm);
            return false;
        }
        var withOp = !cm.curOp;
        if (withOp)
            startOperation(cm);
        cm.display.shift = false;
        if (text.charCodeAt(0) == 8203 && doc.sel == cm.display.selForContextMenu && !prevInput)
            prevInput = '\u200B';
        var same = 0, l = Math.min(prevInput.length, text.length);
        while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same))
            ++same;
        var inserted = text.slice(same), textLines = splitLines(inserted);
        var multiPaste = null;
        if (cm.state.pasteIncoming && doc.sel.ranges.length > 1) {
            if (lastCopied && lastCopied.join('\n') == inserted)
                multiPaste = doc.sel.ranges.length % lastCopied.length == 0 && map(lastCopied, splitLines);
            else if (textLines.length == doc.sel.ranges.length)
                multiPaste = map(textLines, function (l) {
                    return [l];
                });
        }
        for (var i = doc.sel.ranges.length - 1; i >= 0; i--) {
            var range = doc.sel.ranges[i];
            var from = range.from(), to = range.to();
            if (same < prevInput.length)
                from = Pos(from.line, from.ch - (prevInput.length - same));
            else if (cm.state.overwrite && range.empty() && !cm.state.pasteIncoming)
                to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
            var updateInput = cm.curOp.updateInput;
            var changeEvent = {
                from: from,
                to: to,
                text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
                origin: cm.state.pasteIncoming ? 'paste' : cm.state.cutIncoming ? 'cut' : '+input'
            };
            makeChange(cm.doc, changeEvent);
            signalLater(cm, 'inputRead', cm, changeEvent);
            if (inserted && !cm.state.pasteIncoming && cm.options.electricChars && cm.options.smartIndent && range.head.ch < 100 && (!i || doc.sel.ranges[i - 1].head.line != range.head.line)) {
                var mode = cm.getModeAt(range.head);
                if (mode.electricChars) {
                    for (var j = 0; j < mode.electricChars.length; j++)
                        if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                            indentLine(cm, range.head.line, 'smart');
                            break;
                        }
                } else if (mode.electricInput) {
                    var end = changeEnd(changeEvent);
                    if (mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)))
                        indentLine(cm, range.head.line, 'smart');
                }
            }
        }
        ensureCursorVisible(cm);
        cm.curOp.updateInput = updateInput;
        cm.curOp.typing = true;
        if (text.length > 1000 || text.indexOf('\n') > -1)
            input.value = cm.display.prevInput = '';
        else
            cm.display.prevInput = text;
        if (withOp)
            endOperation(cm);
        cm.state.pasteIncoming = cm.state.cutIncoming = false;
        return true;
    }
    function resetInput(cm, typing) {
        var minimal, selected, doc = cm.doc;
        if (cm.somethingSelected()) {
            cm.display.prevInput = '';
            var range = doc.sel.primary();
            minimal = hasCopyEvent && (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
            var content = minimal ? '-' : selected || cm.getSelection();
            cm.display.input.value = content;
            if (cm.state.focused)
                selectInput(cm.display.input);
            if (ie && ie_version >= 9)
                cm.display.inputHasSelection = content;
        } else if (!typing) {
            cm.display.prevInput = cm.display.input.value = '';
            if (ie && ie_version >= 9)
                cm.display.inputHasSelection = null;
        }
        cm.display.inaccurateSelection = minimal;
    }
    function focusInput(cm) {
        if (cm.options.readOnly != 'nocursor' && (!mobile || activeElt() != cm.display.input))
            cm.display.input.focus();
    }
    function ensureFocus(cm) {
        if (!cm.state.focused) {
            focusInput(cm);
            onFocus(cm);
        }
    }
    function isReadOnly(cm) {
        return cm.options.readOnly || cm.doc.cantEdit;
    }
    function registerEventHandlers(cm) {
        var d = cm.display;
        on(d.scroller, 'mousedown', operation(cm, onMouseDown));
        if (ie && ie_version < 11)
            on(d.scroller, 'dblclick', operation(cm, function (e) {
                if (signalDOMEvent(cm, e))
                    return;
                var pos = posFromMouse(cm, e);
                if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e))
                    return;
                e_preventDefault(e);
                var word = findWordAt(cm, pos);
                extendSelection(cm.doc, word.anchor, word.head);
            }));
        else
            on(d.scroller, 'dblclick', function (e) {
                signalDOMEvent(cm, e) || e_preventDefault(e);
            });
        on(d.lineSpace, 'selectstart', function (e) {
            if (!eventInWidget(d, e))
                e_preventDefault(e);
        });
        if (!captureRightClick)
            on(d.scroller, 'contextmenu', function (e) {
                onContextMenu(cm, e);
            });
        on(d.scroller, 'scroll', function () {
            if (d.scroller.clientHeight) {
                setScrollTop(cm, d.scroller.scrollTop);
                setScrollLeft(cm, d.scroller.scrollLeft, true);
                signal(cm, 'scroll', cm);
            }
        });
        on(d.scrollbarV, 'scroll', function () {
            if (d.scroller.clientHeight)
                setScrollTop(cm, d.scrollbarV.scrollTop);
        });
        on(d.scrollbarH, 'scroll', function () {
            if (d.scroller.clientHeight)
                setScrollLeft(cm, d.scrollbarH.scrollLeft);
        });
        on(d.scroller, 'mousewheel', function (e) {
            onScrollWheel(cm, e);
        });
        on(d.scroller, 'DOMMouseScroll', function (e) {
            onScrollWheel(cm, e);
        });
        function reFocus() {
            if (cm.state.focused)
                setTimeout(bind(focusInput, cm), 0);
        }
        on(d.scrollbarH, 'mousedown', reFocus);
        on(d.scrollbarV, 'mousedown', reFocus);
        on(d.wrapper, 'scroll', function () {
            d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
        });
        on(d.input, 'keyup', function (e) {
            onKeyUp.call(cm, e);
        });
        on(d.input, 'input', function () {
            if (ie && ie_version >= 9 && cm.display.inputHasSelection)
                cm.display.inputHasSelection = null;
            fastPoll(cm);
        });
        on(d.input, 'keydown', operation(cm, onKeyDown));
        on(d.input, 'keypress', operation(cm, onKeyPress));
        on(d.input, 'focus', bind(onFocus, cm));
        on(d.input, 'blur', bind(onBlur, cm));
        function drag_(e) {
            if (!signalDOMEvent(cm, e))
                e_stop(e);
        }
        if (cm.options.dragDrop) {
            on(d.scroller, 'dragstart', function (e) {
                onDragStart(cm, e);
            });
            on(d.scroller, 'dragenter', drag_);
            on(d.scroller, 'dragover', drag_);
            on(d.scroller, 'drop', operation(cm, onDrop));
        }
        on(d.scroller, 'paste', function (e) {
            if (eventInWidget(d, e))
                return;
            cm.state.pasteIncoming = true;
            focusInput(cm);
            fastPoll(cm);
        });
        on(d.input, 'paste', function () {
            if (webkit && !cm.state.fakedLastChar && !(new Date() - cm.state.lastMiddleDown < 200)) {
                var start = d.input.selectionStart, end = d.input.selectionEnd;
                d.input.value += '$';
                d.input.selectionEnd = end;
                d.input.selectionStart = start;
                cm.state.fakedLastChar = true;
            }
            cm.state.pasteIncoming = true;
            fastPoll(cm);
        });
        function prepareCopyCut(e) {
            if (cm.somethingSelected()) {
                lastCopied = cm.getSelections();
                if (d.inaccurateSelection) {
                    d.prevInput = '';
                    d.inaccurateSelection = false;
                    d.input.value = lastCopied.join('\n');
                    selectInput(d.input);
                }
            } else {
                var text = [], ranges = [];
                for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
                    var line = cm.doc.sel.ranges[i].head.line;
                    var lineRange = {
                        anchor: Pos(line, 0),
                        head: Pos(line + 1, 0)
                    };
                    ranges.push(lineRange);
                    text.push(cm.getRange(lineRange.anchor, lineRange.head));
                }
                if (e.type == 'cut') {
                    cm.setSelections(ranges, null, sel_dontScroll);
                } else {
                    d.prevInput = '';
                    d.input.value = text.join('\n');
                    selectInput(d.input);
                }
                lastCopied = text;
            }
            if (e.type == 'cut')
                cm.state.cutIncoming = true;
        }
        on(d.input, 'cut', prepareCopyCut);
        on(d.input, 'copy', prepareCopyCut);
        if (khtml)
            on(d.sizer, 'mouseup', function () {
                if (activeElt() == d.input)
                    d.input.blur();
                focusInput(cm);
            });
    }
    function onResize(cm) {
        var d = cm.display;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        cm.setSize();
    }
    function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
            if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover)
                return true;
        }
    }
    function posFromMouse(cm, e, liberal, forRect) {
        var display = cm.display;
        if (!liberal) {
            var target = e_target(e);
            if (target == display.scrollbarH || target == display.scrollbarV || target == display.scrollbarFiller || target == display.gutterFiller)
                return null;
        }
        var x, y, space = display.lineSpace.getBoundingClientRect();
        try {
            x = e.clientX - space.left - pageScrollX();
            y = e.clientY - space.top - pageScrollY();
        } catch (e) {
            return null;
        }
        var coords = coordsChar(cm, x, y), line;
        if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
            var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
            coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
        }
        return coords;
    }
    function onMouseDown(e) {
        if (signalDOMEvent(this, e))
            return;
        var cm = this, display = cm.display;
        display.shift = e.shiftKey;
        if (eventInWidget(display, e)) {
            if (!webkit) {
                display.scroller.draggable = false;
                setTimeout(function () {
                    display.scroller.draggable = true;
                }, 100);
            }
            return;
        }
        if (clickInGutter(cm, e))
            return;
        var start = posFromMouse(cm, e);
        window.focus();
        switch (e_button(e)) {
        case 1:
            if (start)
                leftButtonDown(cm, e, start);
            else if (e_target(e) == display.scroller)
                e_preventDefault(e);
            break;
        case 2:
            if (webkit)
                cm.state.lastMiddleDown = +new Date();
            if (start)
                extendSelection(cm.doc, start);
            setTimeout(bind(focusInput, cm), 20);
            e_preventDefault(e);
            break;
        case 3:
            if (captureRightClick)
                onContextMenu(cm, e);
            break;
        }
    }
    var lastClick, lastDoubleClick;
    function leftButtonDown(cm, e, start) {
        setTimeout(bind(ensureFocus, cm), 0);
        var now = +new Date(), type;
        if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
            type = 'triple';
        } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
            type = 'double';
            lastDoubleClick = {
                time: now,
                pos: start
            };
        } else {
            type = 'single';
            lastClick = {
                time: now,
                pos: start
            };
        }
        var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey;
        if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && type == 'single' && sel.contains(start) > -1 && sel.somethingSelected())
            leftButtonStartDrag(cm, e, start, modifier);
        else
            leftButtonSelect(cm, e, start, type, modifier);
    }
    function leftButtonStartDrag(cm, e, start, modifier) {
        var display = cm.display;
        var dragEnd = operation(cm, function (e2) {
            if (webkit)
                display.scroller.draggable = false;
            cm.state.draggingText = false;
            off(document, 'mouseup', dragEnd);
            off(display.scroller, 'drop', dragEnd);
            if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
                e_preventDefault(e2);
                if (!modifier)
                    extendSelection(cm.doc, start);
                focusInput(cm);
                if (ie && ie_version == 9)
                    setTimeout(function () {
                        document.body.focus();
                        focusInput(cm);
                    }, 20);
            }
        });
        if (webkit)
            display.scroller.draggable = true;
        cm.state.draggingText = dragEnd;
        if (display.scroller.dragDrop)
            display.scroller.dragDrop();
        on(document, 'mouseup', dragEnd);
        on(display.scroller, 'drop', dragEnd);
    }
    function leftButtonSelect(cm, e, start, type, addNew) {
        var display = cm.display, doc = cm.doc;
        e_preventDefault(e);
        var ourRange, ourIndex, startSel = doc.sel;
        if (addNew && !e.shiftKey) {
            ourIndex = doc.sel.contains(start);
            if (ourIndex > -1)
                ourRange = doc.sel.ranges[ourIndex];
            else
                ourRange = new Range(start, start);
        } else {
            ourRange = doc.sel.primary();
        }
        if (e.altKey) {
            type = 'rect';
            if (!addNew)
                ourRange = new Range(start, start);
            start = posFromMouse(cm, e, true, true);
            ourIndex = -1;
        } else if (type == 'double') {
            var word = findWordAt(cm, start);
            if (cm.display.shift || doc.extend)
                ourRange = extendRange(doc, ourRange, word.anchor, word.head);
            else
                ourRange = word;
        } else if (type == 'triple') {
            var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
            if (cm.display.shift || doc.extend)
                ourRange = extendRange(doc, ourRange, line.anchor, line.head);
            else
                ourRange = line;
        } else {
            ourRange = extendRange(doc, ourRange, start);
        }
        if (!addNew) {
            ourIndex = 0;
            setSelection(doc, new Selection([ourRange], 0), sel_mouse);
            startSel = doc.sel;
        } else if (ourIndex > -1) {
            replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
        } else {
            ourIndex = doc.sel.ranges.length;
            setSelection(doc, normalizeSelection(doc.sel.ranges.concat([ourRange]), ourIndex), {
                scroll: false,
                origin: '*mouse'
            });
        }
        var lastPos = start;
        function extendTo(pos) {
            if (cmp(lastPos, pos) == 0)
                return;
            lastPos = pos;
            if (type == 'rect') {
                var ranges = [], tabSize = cm.options.tabSize;
                var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
                var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
                var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
                for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
                    var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
                    if (left == right)
                        ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
                    else if (text.length > leftPos)
                        ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
                }
                if (!ranges.length)
                    ranges.push(new Range(start, start));
                setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
                    origin: '*mouse',
                    scroll: false
                });
                cm.scrollIntoView(pos);
            } else {
                var oldRange = ourRange;
                var anchor = oldRange.anchor, head = pos;
                if (type != 'single') {
                    if (type == 'double')
                        var range = findWordAt(cm, pos);
                    else
                        var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
                    if (cmp(range.anchor, anchor) > 0) {
                        head = range.head;
                        anchor = minPos(oldRange.from(), range.anchor);
                    } else {
                        head = range.anchor;
                        anchor = maxPos(oldRange.to(), range.head);
                    }
                }
                var ranges = startSel.ranges.slice(0);
                ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
                setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
            }
        }
        var editorSize = display.wrapper.getBoundingClientRect();
        var counter = 0;
        function extend(e) {
            var curCount = ++counter;
            var cur = posFromMouse(cm, e, true, type == 'rect');
            if (!cur)
                return;
            if (cmp(cur, lastPos) != 0) {
                ensureFocus(cm);
                extendTo(cur);
                var visible = visibleLines(display, doc);
                if (cur.line >= visible.to || cur.line < visible.from)
                    setTimeout(operation(cm, function () {
                        if (counter == curCount)
                            extend(e);
                    }), 150);
            } else {
                var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
                if (outside)
                    setTimeout(operation(cm, function () {
                        if (counter != curCount)
                            return;
                        display.scroller.scrollTop += outside;
                        extend(e);
                    }), 50);
            }
        }
        function done(e) {
            counter = Infinity;
            e_preventDefault(e);
            focusInput(cm);
            off(document, 'mousemove', move);
            off(document, 'mouseup', up);
            doc.history.lastSelOrigin = null;
        }
        var move = operation(cm, function (e) {
            if (!e_button(e))
                done(e);
            else
                extend(e);
        });
        var up = operation(cm, done);
        on(document, 'mousemove', move);
        on(document, 'mouseup', up);
    }
    function gutterEvent(cm, e, type, prevent, signalfn) {
        try {
            var mX = e.clientX, mY = e.clientY;
        } catch (e) {
            return false;
        }
        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right))
            return false;
        if (prevent)
            e_preventDefault(e);
        var display = cm.display;
        var lineBox = display.lineDiv.getBoundingClientRect();
        if (mY > lineBox.bottom || !hasHandler(cm, type))
            return e_defaultPrevented(e);
        mY -= lineBox.top - display.viewOffset;
        for (var i = 0; i < cm.options.gutters.length; ++i) {
            var g = display.gutters.childNodes[i];
            if (g && g.getBoundingClientRect().right >= mX) {
                var line = lineAtHeight(cm.doc, mY);
                var gutter = cm.options.gutters[i];
                signalfn(cm, type, cm, line, gutter, e);
                return e_defaultPrevented(e);
            }
        }
    }
    function clickInGutter(cm, e) {
        return gutterEvent(cm, e, 'gutterClick', true, signalLater);
    }
    var lastDrop = 0;
    function onDrop(e) {
        var cm = this;
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
            return;
        e_preventDefault(e);
        if (ie)
            lastDrop = +new Date();
        var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
        if (!pos || isReadOnly(cm))
            return;
        if (files && files.length && window.FileReader && window.File) {
            var n = files.length, text = Array(n), read = 0;
            var loadFile = function (file, i) {
                var reader = new FileReader();
                reader.onload = operation(cm, function () {
                    text[i] = reader.result;
                    if (++read == n) {
                        pos = clipPos(cm.doc, pos);
                        var change = {
                            from: pos,
                            to: pos,
                            text: splitLines(text.join('\n')),
                            origin: 'paste'
                        };
                        makeChange(cm.doc, change);
                        setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
                    }
                });
                reader.readAsText(file);
            };
            for (var i = 0; i < n; ++i)
                loadFile(files[i], i);
        } else {
            if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
                cm.state.draggingText(e);
                setTimeout(bind(focusInput, cm), 20);
                return;
            }
            try {
                var text = e.dataTransfer.getData('Text');
                if (text) {
                    if (cm.state.draggingText && !(mac ? e.metaKey : e.ctrlKey))
                        var selected = cm.listSelections();
                    setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
                    if (selected)
                        for (var i = 0; i < selected.length; ++i)
                            replaceRange(cm.doc, '', selected[i].anchor, selected[i].head, 'drag');
                    cm.replaceSelection(text, 'around', 'paste');
                    focusInput(cm);
                }
            } catch (e) {
            }
        }
    }
    function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
            e_stop(e);
            return;
        }
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
            return;
        e.dataTransfer.setData('Text', cm.getSelection());
        if (e.dataTransfer.setDragImage && !safari) {
            var img = elt('img', null, null, 'position: fixed; left: 0; top: 0;');
            img.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
            if (presto) {
                img.width = img.height = 1;
                cm.display.wrapper.appendChild(img);
                img._top = img.offsetTop;
            }
            e.dataTransfer.setDragImage(img, 0, 0);
            if (presto)
                img.parentNode.removeChild(img);
        }
    }
    function setScrollTop(cm, val) {
        if (Math.abs(cm.doc.scrollTop - val) < 2)
            return;
        cm.doc.scrollTop = val;
        if (!gecko)
            updateDisplaySimple(cm, { top: val });
        if (cm.display.scroller.scrollTop != val)
            cm.display.scroller.scrollTop = val;
        if (cm.display.scrollbarV.scrollTop != val)
            cm.display.scrollbarV.scrollTop = val;
        if (gecko)
            updateDisplaySimple(cm);
        startWorker(cm, 100);
    }
    function setScrollLeft(cm, val, isScroller) {
        if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2)
            return;
        val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
        cm.doc.scrollLeft = val;
        alignHorizontally(cm);
        if (cm.display.scroller.scrollLeft != val)
            cm.display.scroller.scrollLeft = val;
        if (cm.display.scrollbarH.scrollLeft != val)
            cm.display.scrollbarH.scrollLeft = val;
    }
    var wheelSamples = 0, wheelPixelsPerUnit = null;
    if (ie)
        wheelPixelsPerUnit = -0.53;
    else if (gecko)
        wheelPixelsPerUnit = 15;
    else if (chrome)
        wheelPixelsPerUnit = -0.7;
    else if (safari)
        wheelPixelsPerUnit = -1 / 3;
    function onScrollWheel(cm, e) {
        var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS)
            dx = e.detail;
        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS)
            dy = e.detail;
        else if (dy == null)
            dy = e.wheelDelta;
        var display = cm.display, scroll = display.scroller;
        if (!(dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight))
            return;
        if (dy && mac && webkit) {
            outer:
                for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
                    for (var i = 0; i < view.length; i++) {
                        if (view[i].node == cur) {
                            cm.display.currentWheelTarget = cur;
                            break outer;
                        }
                    }
                }
        }
        if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
            if (dy)
                setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
            setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
            e_preventDefault(e);
            display.wheelStartX = null;
            return;
        }
        if (dy && wheelPixelsPerUnit != null) {
            var pixels = dy * wheelPixelsPerUnit;
            var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
            if (pixels < 0)
                top = Math.max(0, top + pixels - 50);
            else
                bot = Math.min(cm.doc.height, bot + pixels + 50);
            updateDisplaySimple(cm, {
                top: top,
                bottom: bot
            });
        }
        if (wheelSamples < 20) {
            if (display.wheelStartX == null) {
                display.wheelStartX = scroll.scrollLeft;
                display.wheelStartY = scroll.scrollTop;
                display.wheelDX = dx;
                display.wheelDY = dy;
                setTimeout(function () {
                    if (display.wheelStartX == null)
                        return;
                    var movedX = scroll.scrollLeft - display.wheelStartX;
                    var movedY = scroll.scrollTop - display.wheelStartY;
                    var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                    display.wheelStartX = display.wheelStartY = null;
                    if (!sample)
                        return;
                    wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
                    ++wheelSamples;
                }, 200);
            } else {
                display.wheelDX += dx;
                display.wheelDY += dy;
            }
        }
    }
    function doHandleBinding(cm, bound, dropShift) {
        if (typeof bound == 'string') {
            bound = commands[bound];
            if (!bound)
                return false;
        }
        if (cm.display.pollingFast && readInput(cm))
            cm.display.pollingFast = false;
        var prevShift = cm.display.shift, done = false;
        try {
            if (isReadOnly(cm))
                cm.state.suppressEdits = true;
            if (dropShift)
                cm.display.shift = false;
            done = bound(cm) != Pass;
        } finally {
            cm.display.shift = prevShift;
            cm.state.suppressEdits = false;
        }
        return done;
    }
    function allKeyMaps(cm) {
        var maps = cm.state.keyMaps.slice(0);
        if (cm.options.extraKeys)
            maps.push(cm.options.extraKeys);
        maps.push(cm.options.keyMap);
        return maps;
    }
    var maybeTransition;
    function handleKeyBinding(cm, e) {
        var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
        clearTimeout(maybeTransition);
        if (next && !isModifierKey(e))
            maybeTransition = setTimeout(function () {
                if (getKeyMap(cm.options.keyMap) == startMap) {
                    cm.options.keyMap = next.call ? next.call(null, cm) : next;
                    keyMapChanged(cm);
                }
            }, 50);
        var name = keyName(e, true), handled = false;
        if (!name)
            return false;
        var keymaps = allKeyMaps(cm);
        if (e.shiftKey) {
            handled = lookupKey('Shift-' + name, keymaps, function (b) {
                return doHandleBinding(cm, b, true);
            }) || lookupKey(name, keymaps, function (b) {
                if (typeof b == 'string' ? /^go[A-Z]/.test(b) : b.motion)
                    return doHandleBinding(cm, b);
            });
        } else {
            handled = lookupKey(name, keymaps, function (b) {
                return doHandleBinding(cm, b);
            });
        }
        if (handled) {
            e_preventDefault(e);
            restartBlink(cm);
            signalLater(cm, 'keyHandled', cm, name, e);
        }
        return handled;
    }
    function handleCharBinding(cm, e, ch) {
        var handled = lookupKey('\'' + ch + '\'', allKeyMaps(cm), function (b) {
            return doHandleBinding(cm, b, true);
        });
        if (handled) {
            e_preventDefault(e);
            restartBlink(cm);
            signalLater(cm, 'keyHandled', cm, '\'' + ch + '\'', e);
        }
        return handled;
    }
    var lastStoppedKey = null;
    function onKeyDown(e) {
        var cm = this;
        ensureFocus(cm);
        if (signalDOMEvent(cm, e))
            return;
        if (ie && ie_version < 11 && e.keyCode == 27)
            e.returnValue = false;
        var code = e.keyCode;
        cm.display.shift = code == 16 || e.shiftKey;
        var handled = handleKeyBinding(cm, e);
        if (presto) {
            lastStoppedKey = handled ? code : null;
            if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
                cm.replaceSelection('', null, 'cut');
        }
        if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
            showCrossHair(cm);
    }
    function showCrossHair(cm) {
        var lineDiv = cm.display.lineDiv;
        addClass(lineDiv, 'CodeMirror-crosshair');
        function up(e) {
            if (e.keyCode == 18 || !e.altKey) {
                rmClass(lineDiv, 'CodeMirror-crosshair');
                off(document, 'keyup', up);
                off(document, 'mouseover', up);
            }
        }
        on(document, 'keyup', up);
        on(document, 'mouseover', up);
    }
    function onKeyUp(e) {
        if (e.keyCode == 16)
            this.doc.sel.shift = false;
        signalDOMEvent(this, e);
    }
    function onKeyPress(e) {
        var cm = this;
        if (signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey)
            return;
        var keyCode = e.keyCode, charCode = e.charCode;
        if (presto && keyCode == lastStoppedKey) {
            lastStoppedKey = null;
            e_preventDefault(e);
            return;
        }
        if ((presto && (!e.which || e.which < 10) || khtml) && handleKeyBinding(cm, e))
            return;
        var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
        if (handleCharBinding(cm, e, ch))
            return;
        if (ie && ie_version >= 9)
            cm.display.inputHasSelection = null;
        fastPoll(cm);
    }
    function onFocus(cm) {
        if (cm.options.readOnly == 'nocursor')
            return;
        if (!cm.state.focused) {
            signal(cm, 'focus', cm);
            cm.state.focused = true;
            addClass(cm.display.wrapper, 'CodeMirror-focused');
            if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
                resetInput(cm);
                if (webkit)
                    setTimeout(bind(resetInput, cm, true), 0);
            }
        }
        slowPoll(cm);
        restartBlink(cm);
    }
    function onBlur(cm) {
        if (cm.state.focused) {
            signal(cm, 'blur', cm);
            cm.state.focused = false;
            rmClass(cm.display.wrapper, 'CodeMirror-focused');
        }
        clearInterval(cm.display.blinker);
        setTimeout(function () {
            if (!cm.state.focused)
                cm.display.shift = false;
        }, 150);
    }
    function onContextMenu(cm, e) {
        if (signalDOMEvent(cm, e, 'contextmenu'))
            return;
        var display = cm.display;
        if (eventInWidget(display, e) || contextMenuInGutter(cm, e))
            return;
        var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
        if (!pos || presto)
            return;
        var reset = cm.options.resetSelectionOnContextMenu;
        if (reset && cm.doc.sel.contains(pos) == -1)
            operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
        var oldCSS = display.input.style.cssText;
        display.inputDiv.style.position = 'absolute';
        display.input.style.cssText = 'position: fixed; width: 30px; height: 30px; top: ' + (e.clientY - 5) + 'px; left: ' + (e.clientX - 5) + 'px; z-index: 1000; background: ' + (ie ? 'rgba(255, 255, 255, .05)' : 'transparent') + '; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);';
        if (webkit)
            var oldScrollY = window.scrollY;
        focusInput(cm);
        if (webkit)
            window.scrollTo(null, oldScrollY);
        resetInput(cm);
        if (!cm.somethingSelected())
            display.input.value = display.prevInput = ' ';
        display.selForContextMenu = cm.doc.sel;
        clearTimeout(display.detectingSelectAll);
        function prepareSelectAllHack() {
            if (display.input.selectionStart != null) {
                var selected = cm.somethingSelected();
                var extval = display.input.value = '\u200B' + (selected ? display.input.value : '');
                display.prevInput = selected ? '' : '\u200B';
                display.input.selectionStart = 1;
                display.input.selectionEnd = extval.length;
                display.selForContextMenu = cm.doc.sel;
            }
        }
        function rehide() {
            display.inputDiv.style.position = 'relative';
            display.input.style.cssText = oldCSS;
            if (ie && ie_version < 9)
                display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
            slowPoll(cm);
            if (display.input.selectionStart != null) {
                if (!ie || ie && ie_version < 9)
                    prepareSelectAllHack();
                var i = 0, poll = function () {
                        if (display.selForContextMenu == cm.doc.sel && display.input.selectionStart == 0)
                            operation(cm, commands.selectAll)(cm);
                        else if (i++ < 10)
                            display.detectingSelectAll = setTimeout(poll, 500);
                        else
                            resetInput(cm);
                    };
                display.detectingSelectAll = setTimeout(poll, 200);
            }
        }
        if (ie && ie_version >= 9)
            prepareSelectAllHack();
        if (captureRightClick) {
            e_stop(e);
            var mouseup = function () {
                off(window, 'mouseup', mouseup);
                setTimeout(rehide, 20);
            };
            on(window, 'mouseup', mouseup);
        } else {
            setTimeout(rehide, 50);
        }
    }
    function contextMenuInGutter(cm, e) {
        if (!hasHandler(cm, 'gutterContextMenu'))
            return false;
        return gutterEvent(cm, e, 'gutterContextMenu', false, signal);
    }
    var changeEnd = CodeMirror.changeEnd = function (change) {
        if (!change.text)
            return change.to;
        return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
    };
    function adjustForChange(pos, change) {
        if (cmp(pos, change.from) < 0)
            return pos;
        if (cmp(pos, change.to) <= 0)
            return changeEnd(change);
        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
        if (pos.line == change.to.line)
            ch += changeEnd(change).ch - change.to.ch;
        return Pos(line, ch);
    }
    function computeSelAfterChange(doc, change) {
        var out = [];
        for (var i = 0; i < doc.sel.ranges.length; i++) {
            var range = doc.sel.ranges[i];
            out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
        }
        return normalizeSelection(out, doc.sel.primIndex);
    }
    function offsetPos(pos, old, nw) {
        if (pos.line == old.line)
            return Pos(nw.line, pos.ch - old.ch + nw.ch);
        else
            return Pos(nw.line + (pos.line - old.line), pos.ch);
    }
    function computeReplacedSel(doc, changes, hint) {
        var out = [];
        var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
        for (var i = 0; i < changes.length; i++) {
            var change = changes[i];
            var from = offsetPos(change.from, oldPrev, newPrev);
            var to = offsetPos(changeEnd(change), oldPrev, newPrev);
            oldPrev = change.to;
            newPrev = to;
            if (hint == 'around') {
                var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
                out[i] = new Range(inv ? to : from, inv ? from : to);
            } else {
                out[i] = new Range(from, from);
            }
        }
        return new Selection(out, doc.sel.primIndex);
    }
    function filterChange(doc, change, update) {
        var obj = {
            canceled: false,
            from: change.from,
            to: change.to,
            text: change.text,
            origin: change.origin,
            cancel: function () {
                this.canceled = true;
            }
        };
        if (update)
            obj.update = function (from, to, text, origin) {
                if (from)
                    this.from = clipPos(doc, from);
                if (to)
                    this.to = clipPos(doc, to);
                if (text)
                    this.text = text;
                if (origin !== undefined)
                    this.origin = origin;
            };
        signal(doc, 'beforeChange', doc, obj);
        if (doc.cm)
            signal(doc.cm, 'beforeChange', doc.cm, obj);
        if (obj.canceled)
            return null;
        return {
            from: obj.from,
            to: obj.to,
            text: obj.text,
            origin: obj.origin
        };
    }
    function makeChange(doc, change, ignoreReadOnly) {
        if (doc.cm) {
            if (!doc.cm.curOp)
                return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
            if (doc.cm.state.suppressEdits)
                return;
        }
        if (hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange')) {
            change = filterChange(doc, change, true);
            if (!change)
                return;
        }
        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
        if (split) {
            for (var i = split.length - 1; i >= 0; --i)
                makeChangeInner(doc, {
                    from: split[i].from,
                    to: split[i].to,
                    text: i ? [''] : change.text
                });
        } else {
            makeChangeInner(doc, change);
        }
    }
    function makeChangeInner(doc, change) {
        if (change.text.length == 1 && change.text[0] == '' && cmp(change.from, change.to) == 0)
            return;
        var selAfter = computeSelAfterChange(doc, change);
        addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
        makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
        var rebased = [];
        linkedDocs(doc, function (doc, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc.history) == -1) {
                rebaseHist(doc.history, change);
                rebased.push(doc.history);
            }
            makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
        });
    }
    function makeChangeFromHistory(doc, type, allowSelectionOnly) {
        if (doc.cm && doc.cm.state.suppressEdits)
            return;
        var hist = doc.history, event, selAfter = doc.sel;
        var source = type == 'undo' ? hist.done : hist.undone, dest = type == 'undo' ? hist.undone : hist.done;
        for (var i = 0; i < source.length; i++) {
            event = source[i];
            if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
                break;
        }
        if (i == source.length)
            return;
        hist.lastOrigin = hist.lastSelOrigin = null;
        for (;;) {
            event = source.pop();
            if (event.ranges) {
                pushSelectionToHistory(event, dest);
                if (allowSelectionOnly && !event.equals(doc.sel)) {
                    setSelection(doc, event, { clearRedo: false });
                    return;
                }
                selAfter = event;
            } else
                break;
        }
        var antiChanges = [];
        pushSelectionToHistory(selAfter, dest);
        dest.push({
            changes: antiChanges,
            generation: hist.generation
        });
        hist.generation = event.generation || ++hist.maxGeneration;
        var filter = hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange');
        for (var i = event.changes.length - 1; i >= 0; --i) {
            var change = event.changes[i];
            change.origin = type;
            if (filter && !filterChange(doc, change, false)) {
                source.length = 0;
                return;
            }
            antiChanges.push(historyChangeFromChange(doc, change));
            var after = i ? computeSelAfterChange(doc, change) : lst(source);
            makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
            if (!i && doc.cm)
                doc.cm.scrollIntoView({
                    from: change.from,
                    to: changeEnd(change)
                });
            var rebased = [];
            linkedDocs(doc, function (doc, sharedHist) {
                if (!sharedHist && indexOf(rebased, doc.history) == -1) {
                    rebaseHist(doc.history, change);
                    rebased.push(doc.history);
                }
                makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
            });
        }
    }
    function shiftDoc(doc, distance) {
        if (distance == 0)
            return;
        doc.first += distance;
        doc.sel = new Selection(map(doc.sel.ranges, function (range) {
            return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
        }), doc.sel.primIndex);
        if (doc.cm) {
            regChange(doc.cm, doc.first, doc.first - distance, distance);
            for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
                regLineChange(doc.cm, l, 'gutter');
        }
    }
    function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp)
            return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
        if (change.to.line < doc.first) {
            shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
            return;
        }
        if (change.from.line > doc.lastLine())
            return;
        if (change.from.line < doc.first) {
            var shift = change.text.length - 1 - (doc.first - change.from.line);
            shiftDoc(doc, shift);
            change = {
                from: Pos(doc.first, 0),
                to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)],
                origin: change.origin
            };
        }
        var last = doc.lastLine();
        if (change.to.line > last) {
            change = {
                from: change.from,
                to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]],
                origin: change.origin
            };
        }
        change.removed = getBetween(doc, change.from, change.to);
        if (!selAfter)
            selAfter = computeSelAfterChange(doc, change);
        if (doc.cm)
            makeChangeSingleDocInEditor(doc.cm, change, spans);
        else
            updateDoc(doc, change, spans);
        setSelectionNoUndo(doc, selAfter, sel_dontScroll);
    }
    function makeChangeSingleDocInEditor(cm, change, spans) {
        var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
        var recomputeMaxLength = false, checkWidthStart = from.line;
        if (!cm.options.lineWrapping) {
            checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
            doc.iter(checkWidthStart, to.line + 1, function (line) {
                if (line == display.maxLine) {
                    recomputeMaxLength = true;
                    return true;
                }
            });
        }
        if (doc.sel.contains(change.from, change.to) > -1)
            signalCursorActivity(cm);
        updateDoc(doc, change, spans, estimateHeight(cm));
        if (!cm.options.lineWrapping) {
            doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
                var len = lineLength(line);
                if (len > display.maxLineLength) {
                    display.maxLine = line;
                    display.maxLineLength = len;
                    display.maxLineChanged = true;
                    recomputeMaxLength = false;
                }
            });
            if (recomputeMaxLength)
                cm.curOp.updateMaxLine = true;
        }
        doc.frontier = Math.min(doc.frontier, from.line);
        startWorker(cm, 400);
        var lendiff = change.text.length - (to.line - from.line) - 1;
        if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
            regLineChange(cm, from.line, 'text');
        else
            regChange(cm, from.line, to.line + 1, lendiff);
        var changesHandler = hasHandler(cm, 'changes'), changeHandler = hasHandler(cm, 'change');
        if (changeHandler || changesHandler) {
            var obj = {
                from: from,
                to: to,
                text: change.text,
                removed: change.removed,
                origin: change.origin
            };
            if (changeHandler)
                signalLater(cm, 'change', cm, obj);
            if (changesHandler)
                (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
        }
        cm.display.selForContextMenu = null;
    }
    function replaceRange(doc, code, from, to, origin) {
        if (!to)
            to = from;
        if (cmp(to, from) < 0) {
            var tmp = to;
            to = from;
            from = tmp;
        }
        if (typeof code == 'string')
            code = splitLines(code);
        makeChange(doc, {
            from: from,
            to: to,
            text: code,
            origin: origin
        });
    }
    function maybeScrollWindow(cm, coords) {
        var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
        if (coords.top + box.top < 0)
            doScroll = true;
        else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight))
            doScroll = false;
        if (doScroll != null && !phantom) {
            var scrollNode = elt('div', '\u200B', null, 'position: absolute; top: ' + (coords.top - display.viewOffset - paddingTop(cm.display)) + 'px; height: ' + (coords.bottom - coords.top + scrollerCutOff) + 'px; left: ' + coords.left + 'px; width: 2px;');
            cm.display.lineSpace.appendChild(scrollNode);
            scrollNode.scrollIntoView(doScroll);
            cm.display.lineSpace.removeChild(scrollNode);
        }
    }
    function scrollPosIntoView(cm, pos, end, margin) {
        if (margin == null)
            margin = 0;
        for (;;) {
            var changed = false, coords = cursorCoords(cm, pos);
            var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
            var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left), Math.min(coords.top, endCoords.top) - margin, Math.max(coords.left, endCoords.left), Math.max(coords.bottom, endCoords.bottom) + margin);
            var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
            if (scrollPos.scrollTop != null) {
                setScrollTop(cm, scrollPos.scrollTop);
                if (Math.abs(cm.doc.scrollTop - startTop) > 1)
                    changed = true;
            }
            if (scrollPos.scrollLeft != null) {
                setScrollLeft(cm, scrollPos.scrollLeft);
                if (Math.abs(cm.doc.scrollLeft - startLeft) > 1)
                    changed = true;
            }
            if (!changed)
                return coords;
        }
    }
    function scrollIntoView(cm, x1, y1, x2, y2) {
        var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
        if (scrollPos.scrollTop != null)
            setScrollTop(cm, scrollPos.scrollTop);
        if (scrollPos.scrollLeft != null)
            setScrollLeft(cm, scrollPos.scrollLeft);
    }
    function calculateScrollPos(cm, x1, y1, x2, y2) {
        var display = cm.display, snapMargin = textHeight(cm.display);
        if (y1 < 0)
            y1 = 0;
        var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
        var screen = display.scroller.clientHeight - scrollerCutOff, result = {};
        if (y2 - y1 > screen)
            y2 = y1 + screen;
        var docBottom = cm.doc.height + paddingVert(display);
        var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
        if (y1 < screentop) {
            result.scrollTop = atTop ? 0 : y1;
        } else if (y2 > screentop + screen) {
            var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
            if (newTop != screentop)
                result.scrollTop = newTop;
        }
        var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
        var screenw = display.scroller.clientWidth - scrollerCutOff - display.gutters.offsetWidth;
        var tooWide = x2 - x1 > screenw;
        if (tooWide)
            x2 = y1 + screen;
        if (x1 < 10)
            result.scrollLeft = 0;
        else if (x1 < screenleft)
            result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
        else if (x2 > screenw + screenleft - 3)
            result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
        return result;
    }
    function addToScrollPos(cm, left, top) {
        if (left != null || top != null)
            resolveScrollToPos(cm);
        if (left != null)
            cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
        if (top != null)
            cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
    }
    function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor(), from = cur, to = cur;
        if (!cm.options.lineWrapping) {
            from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
            to = Pos(cur.line, cur.ch + 1);
        }
        cm.curOp.scrollToPos = {
            from: from,
            to: to,
            margin: cm.options.cursorScrollMargin,
            isCursor: true
        };
    }
    function resolveScrollToPos(cm) {
        var range = cm.curOp.scrollToPos;
        if (range) {
            cm.curOp.scrollToPos = null;
            var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
            var sPos = calculateScrollPos(cm, Math.min(from.left, to.left), Math.min(from.top, to.top) - range.margin, Math.max(from.right, to.right), Math.max(from.bottom, to.bottom) + range.margin);
            cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
        }
    }
    function indentLine(cm, n, how, aggressive) {
        var doc = cm.doc, state;
        if (how == null)
            how = 'add';
        if (how == 'smart') {
            if (!doc.mode.indent)
                how = 'prev';
            else
                state = getStateBefore(cm, n);
        }
        var tabSize = cm.options.tabSize;
        var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
        if (line.stateAfter)
            line.stateAfter = null;
        var curSpaceString = line.text.match(/^\s*/)[0], indentation;
        if (!aggressive && !/\S/.test(line.text)) {
            indentation = 0;
            how = 'not';
        } else if (how == 'smart') {
            indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
            if (indentation == Pass || indentation > 150) {
                if (!aggressive)
                    return;
                how = 'prev';
            }
        }
        if (how == 'prev') {
            if (n > doc.first)
                indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
            else
                indentation = 0;
        } else if (how == 'add') {
            indentation = curSpace + cm.options.indentUnit;
        } else if (how == 'subtract') {
            indentation = curSpace - cm.options.indentUnit;
        } else if (typeof how == 'number') {
            indentation = curSpace + how;
        }
        indentation = Math.max(0, indentation);
        var indentString = '', pos = 0;
        if (cm.options.indentWithTabs)
            for (var i = Math.floor(indentation / tabSize); i; --i) {
                pos += tabSize;
                indentString += '\t';
            }
        if (pos < indentation)
            indentString += spaceStr(indentation - pos);
        if (indentString != curSpaceString) {
            replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), '+input');
        } else {
            for (var i = 0; i < doc.sel.ranges.length; i++) {
                var range = doc.sel.ranges[i];
                if (range.head.line == n && range.head.ch < curSpaceString.length) {
                    var pos = Pos(n, curSpaceString.length);
                    replaceOneSelection(doc, i, new Range(pos, pos));
                    break;
                }
            }
        }
        line.stateAfter = null;
    }
    function changeLine(doc, handle, changeType, op) {
        var no = handle, line = handle;
        if (typeof handle == 'number')
            line = getLine(doc, clipLine(doc, handle));
        else
            no = lineNo(handle);
        if (no == null)
            return null;
        if (op(line, no) && doc.cm)
            regLineChange(doc.cm, no, changeType);
        return line;
    }
    function deleteNearSelection(cm, compute) {
        var ranges = cm.doc.sel.ranges, kill = [];
        for (var i = 0; i < ranges.length; i++) {
            var toKill = compute(ranges[i]);
            while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
                var replaced = kill.pop();
                if (cmp(replaced.from, toKill.from) < 0) {
                    toKill.from = replaced.from;
                    break;
                }
            }
            kill.push(toKill);
        }
        runInOp(cm, function () {
            for (var i = kill.length - 1; i >= 0; i--)
                replaceRange(cm.doc, '', kill[i].from, kill[i].to, '+delete');
            ensureCursorVisible(cm);
        });
    }
    function findPosH(doc, pos, dir, unit, visually) {
        var line = pos.line, ch = pos.ch, origDir = dir;
        var lineObj = getLine(doc, line);
        var possible = true;
        function findNextLine() {
            var l = line + dir;
            if (l < doc.first || l >= doc.first + doc.size)
                return possible = false;
            line = l;
            return lineObj = getLine(doc, l);
        }
        function moveOnce(boundToLine) {
            var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
            if (next == null) {
                if (!boundToLine && findNextLine()) {
                    if (visually)
                        ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
                    else
                        ch = dir < 0 ? lineObj.text.length : 0;
                } else
                    return possible = false;
            } else
                ch = next;
            return true;
        }
        if (unit == 'char')
            moveOnce();
        else if (unit == 'column')
            moveOnce(true);
        else if (unit == 'word' || unit == 'group') {
            var sawType = null, group = unit == 'group';
            var helper = doc.cm && doc.cm.getHelper(pos, 'wordChars');
            for (var first = true;; first = false) {
                if (dir < 0 && !moveOnce(!first))
                    break;
                var cur = lineObj.text.charAt(ch) || '\n';
                var type = isWordChar(cur, helper) ? 'w' : group && cur == '\n' ? 'n' : !group || /\s/.test(cur) ? null : 'p';
                if (group && !first && !type)
                    type = 's';
                if (sawType && sawType != type) {
                    if (dir < 0) {
                        dir = 1;
                        moveOnce();
                    }
                    break;
                }
                if (type)
                    sawType = type;
                if (dir > 0 && !moveOnce(!first))
                    break;
            }
        }
        var result = skipAtomic(doc, Pos(line, ch), origDir, true);
        if (!possible)
            result.hitSide = true;
        return result;
    }
    function findPosV(cm, pos, dir, unit) {
        var doc = cm.doc, x = pos.left, y;
        if (unit == 'page') {
            var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
            y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : 0.5) * textHeight(cm.display));
        } else if (unit == 'line') {
            y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
        }
        for (;;) {
            var target = coordsChar(cm, x, y);
            if (!target.outside)
                break;
            if (dir < 0 ? y <= 0 : y >= doc.height) {
                target.hitSide = true;
                break;
            }
            y += dir * 5;
        }
        return target;
    }
    function findWordAt(cm, pos) {
        var doc = cm.doc, line = getLine(doc, pos.line).text;
        var start = pos.ch, end = pos.ch;
        if (line) {
            var helper = cm.getHelper(pos, 'wordChars');
            if ((pos.xRel < 0 || end == line.length) && start)
                --start;
            else
                ++end;
            var startChar = line.charAt(start);
            var check = isWordChar(startChar, helper) ? function (ch) {
                return isWordChar(ch, helper);
            } : /\s/.test(startChar) ? function (ch) {
                return /\s/.test(ch);
            } : function (ch) {
                return !/\s/.test(ch) && !isWordChar(ch);
            };
            while (start > 0 && check(line.charAt(start - 1)))
                --start;
            while (end < line.length && check(line.charAt(end)))
                ++end;
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end));
    }
    CodeMirror.prototype = {
        constructor: CodeMirror,
        focus: function () {
            window.focus();
            focusInput(this);
            fastPoll(this);
        },
        setOption: function (option, value) {
            var options = this.options, old = options[option];
            if (options[option] == value && option != 'mode')
                return;
            options[option] = value;
            if (optionHandlers.hasOwnProperty(option))
                operation(this, optionHandlers[option])(this, value, old);
        },
        getOption: function (option) {
            return this.options[option];
        },
        getDoc: function () {
            return this.doc;
        },
        addKeyMap: function (map, bottom) {
            this.state.keyMaps[bottom ? 'push' : 'unshift'](map);
        },
        removeKeyMap: function (map) {
            var maps = this.state.keyMaps;
            for (var i = 0; i < maps.length; ++i)
                if (maps[i] == map || typeof maps[i] != 'string' && maps[i].name == map) {
                    maps.splice(i, 1);
                    return true;
                }
        },
        addOverlay: methodOp(function (spec, options) {
            var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
            if (mode.startState)
                throw new Error('Overlays may not be stateful.');
            this.state.overlays.push({
                mode: mode,
                modeSpec: spec,
                opaque: options && options.opaque
            });
            this.state.modeGen++;
            regChange(this);
        }),
        removeOverlay: methodOp(function (spec) {
            var overlays = this.state.overlays;
            for (var i = 0; i < overlays.length; ++i) {
                var cur = overlays[i].modeSpec;
                if (cur == spec || typeof spec == 'string' && cur.name == spec) {
                    overlays.splice(i, 1);
                    this.state.modeGen++;
                    regChange(this);
                    return;
                }
            }
        }),
        indentLine: methodOp(function (n, dir, aggressive) {
            if (typeof dir != 'string' && typeof dir != 'number') {
                if (dir == null)
                    dir = this.options.smartIndent ? 'smart' : 'prev';
                else
                    dir = dir ? 'add' : 'subtract';
            }
            if (isLine(this.doc, n))
                indentLine(this, n, dir, aggressive);
        }),
        indentSelection: methodOp(function (how) {
            var ranges = this.doc.sel.ranges, end = -1;
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                if (!range.empty()) {
                    var from = range.from(), to = range.to();
                    var start = Math.max(end, from.line);
                    end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                    for (var j = start; j < end; ++j)
                        indentLine(this, j, how);
                    var newRanges = this.doc.sel.ranges;
                    if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
                        replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
                } else if (range.head.line > end) {
                    indentLine(this, range.head.line, how, true);
                    end = range.head.line;
                    if (i == this.doc.sel.primIndex)
                        ensureCursorVisible(this);
                }
            }
        }),
        getTokenAt: function (pos, precise) {
            var doc = this.doc;
            pos = clipPos(doc, pos);
            var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;
            var line = getLine(doc, pos.line);
            var stream = new StringStream(line.text, this.options.tabSize);
            while (stream.pos < pos.ch && !stream.eol()) {
                stream.start = stream.pos;
                var style = readToken(mode, stream, state);
            }
            return {
                start: stream.start,
                end: stream.pos,
                string: stream.current(),
                type: style || null,
                state: state
            };
        },
        getTokenTypeAt: function (pos) {
            pos = clipPos(this.doc, pos);
            var styles = getLineStyles(this, getLine(this.doc, pos.line));
            var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
            var type;
            if (ch == 0)
                type = styles[2];
            else
                for (;;) {
                    var mid = before + after >> 1;
                    if ((mid ? styles[mid * 2 - 1] : 0) >= ch)
                        after = mid;
                    else if (styles[mid * 2 + 1] < ch)
                        before = mid + 1;
                    else {
                        type = styles[mid * 2 + 2];
                        break;
                    }
                }
            var cut = type ? type.indexOf('cm-overlay ') : -1;
            return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
        },
        getModeAt: function (pos) {
            var mode = this.doc.mode;
            if (!mode.innerMode)
                return mode;
            return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
        },
        getHelper: function (pos, type) {
            return this.getHelpers(pos, type)[0];
        },
        getHelpers: function (pos, type) {
            var found = [];
            if (!helpers.hasOwnProperty(type))
                return helpers;
            var help = helpers[type], mode = this.getModeAt(pos);
            if (typeof mode[type] == 'string') {
                if (help[mode[type]])
                    found.push(help[mode[type]]);
            } else if (mode[type]) {
                for (var i = 0; i < mode[type].length; i++) {
                    var val = help[mode[type][i]];
                    if (val)
                        found.push(val);
                }
            } else if (mode.helperType && help[mode.helperType]) {
                found.push(help[mode.helperType]);
            } else if (help[mode.name]) {
                found.push(help[mode.name]);
            }
            for (var i = 0; i < help._global.length; i++) {
                var cur = help._global[i];
                if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
                    found.push(cur.val);
            }
            return found;
        },
        getStateAfter: function (line, precise) {
            var doc = this.doc;
            line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
            return getStateBefore(this, line + 1, precise);
        },
        cursorCoords: function (start, mode) {
            var pos, range = this.doc.sel.primary();
            if (start == null)
                pos = range.head;
            else if (typeof start == 'object')
                pos = clipPos(this.doc, start);
            else
                pos = start ? range.from() : range.to();
            return cursorCoords(this, pos, mode || 'page');
        },
        charCoords: function (pos, mode) {
            return charCoords(this, clipPos(this.doc, pos), mode || 'page');
        },
        coordsChar: function (coords, mode) {
            coords = fromCoordSystem(this, coords, mode || 'page');
            return coordsChar(this, coords.left, coords.top);
        },
        lineAtHeight: function (height, mode) {
            height = fromCoordSystem(this, {
                top: height,
                left: 0
            }, mode || 'page').top;
            return lineAtHeight(this.doc, height + this.display.viewOffset);
        },
        heightAtLine: function (line, mode) {
            var end = false, last = this.doc.first + this.doc.size - 1;
            if (line < this.doc.first)
                line = this.doc.first;
            else if (line > last) {
                line = last;
                end = true;
            }
            var lineObj = getLine(this.doc, line);
            return intoCoordSystem(this, lineObj, {
                top: 0,
                left: 0
            }, mode || 'page').top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
        },
        defaultTextHeight: function () {
            return textHeight(this.display);
        },
        defaultCharWidth: function () {
            return charWidth(this.display);
        },
        setGutterMarker: methodOp(function (line, gutterID, value) {
            return changeLine(this.doc, line, 'gutter', function (line) {
                var markers = line.gutterMarkers || (line.gutterMarkers = {});
                markers[gutterID] = value;
                if (!value && isEmpty(markers))
                    line.gutterMarkers = null;
                return true;
            });
        }),
        clearGutter: methodOp(function (gutterID) {
            var cm = this, doc = cm.doc, i = doc.first;
            doc.iter(function (line) {
                if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
                    line.gutterMarkers[gutterID] = null;
                    regLineChange(cm, i, 'gutter');
                    if (isEmpty(line.gutterMarkers))
                        line.gutterMarkers = null;
                }
                ++i;
            });
        }),
        addLineWidget: methodOp(function (handle, node, options) {
            return addLineWidget(this, handle, node, options);
        }),
        removeLineWidget: function (widget) {
            widget.clear();
        },
        lineInfo: function (line) {
            if (typeof line == 'number') {
                if (!isLine(this.doc, line))
                    return null;
                var n = line;
                line = getLine(this.doc, line);
                if (!line)
                    return null;
            } else {
                var n = lineNo(line);
                if (n == null)
                    return null;
            }
            return {
                line: n,
                handle: line,
                text: line.text,
                gutterMarkers: line.gutterMarkers,
                textClass: line.textClass,
                bgClass: line.bgClass,
                wrapClass: line.wrapClass,
                widgets: line.widgets
            };
        },
        getViewport: function () {
            return {
                from: this.display.viewFrom,
                to: this.display.viewTo
            };
        },
        addWidget: function (pos, node, scroll, vert, horiz) {
            var display = this.display;
            pos = cursorCoords(this, clipPos(this.doc, pos));
            var top = pos.bottom, left = pos.left;
            node.style.position = 'absolute';
            display.sizer.appendChild(node);
            if (vert == 'over') {
                top = pos.top;
            } else if (vert == 'above' || vert == 'near') {
                var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
                    top = pos.top - node.offsetHeight;
                else if (pos.bottom + node.offsetHeight <= vspace)
                    top = pos.bottom;
                if (left + node.offsetWidth > hspace)
                    left = hspace - node.offsetWidth;
            }
            node.style.top = top + 'px';
            node.style.left = node.style.right = '';
            if (horiz == 'right') {
                left = display.sizer.clientWidth - node.offsetWidth;
                node.style.right = '0px';
            } else {
                if (horiz == 'left')
                    left = 0;
                else if (horiz == 'middle')
                    left = (display.sizer.clientWidth - node.offsetWidth) / 2;
                node.style.left = left + 'px';
            }
            if (scroll)
                scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
        },
        triggerOnKeyDown: methodOp(onKeyDown),
        triggerOnKeyPress: methodOp(onKeyPress),
        triggerOnKeyUp: onKeyUp,
        execCommand: function (cmd) {
            if (commands.hasOwnProperty(cmd))
                return commands[cmd](this);
        },
        findPosH: function (from, amount, unit, visually) {
            var dir = 1;
            if (amount < 0) {
                dir = -1;
                amount = -amount;
            }
            for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
                cur = findPosH(this.doc, cur, dir, unit, visually);
                if (cur.hitSide)
                    break;
            }
            return cur;
        },
        moveH: methodOp(function (dir, unit) {
            var cm = this;
            cm.extendSelectionsBy(function (range) {
                if (cm.display.shift || cm.doc.extend || range.empty())
                    return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
                else
                    return dir < 0 ? range.from() : range.to();
            }, sel_move);
        }),
        deleteH: methodOp(function (dir, unit) {
            var sel = this.doc.sel, doc = this.doc;
            if (sel.somethingSelected())
                doc.replaceSelection('', null, '+delete');
            else
                deleteNearSelection(this, function (range) {
                    var other = findPosH(doc, range.head, dir, unit, false);
                    return dir < 0 ? {
                        from: other,
                        to: range.head
                    } : {
                        from: range.head,
                        to: other
                    };
                });
        }),
        findPosV: function (from, amount, unit, goalColumn) {
            var dir = 1, x = goalColumn;
            if (amount < 0) {
                dir = -1;
                amount = -amount;
            }
            for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
                var coords = cursorCoords(this, cur, 'div');
                if (x == null)
                    x = coords.left;
                else
                    coords.left = x;
                cur = findPosV(this, coords, dir, unit);
                if (cur.hitSide)
                    break;
            }
            return cur;
        },
        moveV: methodOp(function (dir, unit) {
            var cm = this, doc = this.doc, goals = [];
            var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
            doc.extendSelectionsBy(function (range) {
                if (collapse)
                    return dir < 0 ? range.from() : range.to();
                var headPos = cursorCoords(cm, range.head, 'div');
                if (range.goalColumn != null)
                    headPos.left = range.goalColumn;
                goals.push(headPos.left);
                var pos = findPosV(cm, headPos, dir, unit);
                if (unit == 'page' && range == doc.sel.primary())
                    addToScrollPos(cm, null, charCoords(cm, pos, 'div').top - headPos.top);
                return pos;
            }, sel_move);
            if (goals.length)
                for (var i = 0; i < doc.sel.ranges.length; i++)
                    doc.sel.ranges[i].goalColumn = goals[i];
        }),
        toggleOverwrite: function (value) {
            if (value != null && value == this.state.overwrite)
                return;
            if (this.state.overwrite = !this.state.overwrite)
                addClass(this.display.cursorDiv, 'CodeMirror-overwrite');
            else
                rmClass(this.display.cursorDiv, 'CodeMirror-overwrite');
            signal(this, 'overwriteToggle', this, this.state.overwrite);
        },
        hasFocus: function () {
            return activeElt() == this.display.input;
        },
        scrollTo: methodOp(function (x, y) {
            if (x != null || y != null)
                resolveScrollToPos(this);
            if (x != null)
                this.curOp.scrollLeft = x;
            if (y != null)
                this.curOp.scrollTop = y;
        }),
        getScrollInfo: function () {
            var scroller = this.display.scroller, co = scrollerCutOff;
            return {
                left: scroller.scrollLeft,
                top: scroller.scrollTop,
                height: scroller.scrollHeight - co,
                width: scroller.scrollWidth - co,
                clientHeight: scroller.clientHeight - co,
                clientWidth: scroller.clientWidth - co
            };
        },
        scrollIntoView: methodOp(function (range, margin) {
            if (range == null) {
                range = {
                    from: this.doc.sel.primary().head,
                    to: null
                };
                if (margin == null)
                    margin = this.options.cursorScrollMargin;
            } else if (typeof range == 'number') {
                range = {
                    from: Pos(range, 0),
                    to: null
                };
            } else if (range.from == null) {
                range = {
                    from: range,
                    to: null
                };
            }
            if (!range.to)
                range.to = range.from;
            range.margin = margin || 0;
            if (range.from.line != null) {
                resolveScrollToPos(this);
                this.curOp.scrollToPos = range;
            } else {
                var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left), Math.min(range.from.top, range.to.top) - range.margin, Math.max(range.from.right, range.to.right), Math.max(range.from.bottom, range.to.bottom) + range.margin);
                this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
            }
        }),
        setSize: methodOp(function (width, height) {
            var cm = this;
            function interpret(val) {
                return typeof val == 'number' || /^\d+$/.test(String(val)) ? val + 'px' : val;
            }
            if (width != null)
                cm.display.wrapper.style.width = interpret(width);
            if (height != null)
                cm.display.wrapper.style.height = interpret(height);
            if (cm.options.lineWrapping)
                clearLineMeasurementCache(this);
            var lineNo = cm.display.viewFrom;
            cm.doc.iter(lineNo, cm.display.viewTo, function (line) {
                if (line.widgets)
                    for (var i = 0; i < line.widgets.length; i++)
                        if (line.widgets[i].noHScroll) {
                            regLineChange(cm, lineNo, 'widget');
                            break;
                        }
                ++lineNo;
            });
            cm.curOp.forceUpdate = true;
            signal(cm, 'refresh', this);
        }),
        operation: function (f) {
            return runInOp(this, f);
        },
        refresh: methodOp(function () {
            var oldHeight = this.display.cachedTextHeight;
            regChange(this);
            this.curOp.forceUpdate = true;
            clearCaches(this);
            this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
            updateGutterSpace(this);
            if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5)
                estimateLineHeights(this);
            signal(this, 'refresh', this);
        }),
        swapDoc: methodOp(function (doc) {
            var old = this.doc;
            old.cm = null;
            attachDoc(this, doc);
            clearCaches(this);
            resetInput(this);
            this.scrollTo(doc.scrollLeft, doc.scrollTop);
            signalLater(this, 'swapDoc', this, old);
            return old;
        }),
        getInputField: function () {
            return this.display.input;
        },
        getWrapperElement: function () {
            return this.display.wrapper;
        },
        getScrollerElement: function () {
            return this.display.scroller;
        },
        getGutterElement: function () {
            return this.display.gutters;
        }
    };
    eventMixin(CodeMirror);
    var defaults = CodeMirror.defaults = {};
    var optionHandlers = CodeMirror.optionHandlers = {};
    function option(name, deflt, handle, notOnInit) {
        CodeMirror.defaults[name] = deflt;
        if (handle)
            optionHandlers[name] = notOnInit ? function (cm, val, old) {
                if (old != Init)
                    handle(cm, val, old);
            } : handle;
    }
    var Init = CodeMirror.Init = {
        toString: function () {
            return 'CodeMirror.Init';
        }
    };
    option('value', '', function (cm, val) {
        cm.setValue(val);
    }, true);
    option('mode', null, function (cm, val) {
        cm.doc.modeOption = val;
        loadMode(cm);
    }, true);
    option('indentUnit', 2, loadMode, true);
    option('indentWithTabs', false);
    option('smartIndent', true);
    option('tabSize', 4, function (cm) {
        resetModeState(cm);
        clearCaches(cm);
        regChange(cm);
    }, true);
    option('specialChars', /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val) {
        cm.options.specialChars = new RegExp(val.source + (val.test('\t') ? '' : '|\t'), 'g');
        cm.refresh();
    }, true);
    option('specialCharPlaceholder', defaultSpecialCharPlaceholder, function (cm) {
        cm.refresh();
    }, true);
    option('electricChars', true);
    option('rtlMoveVisually', !windows);
    option('wholeLineUpdateBefore', true);
    option('theme', 'default', function (cm) {
        themeChanged(cm);
        guttersChanged(cm);
    }, true);
    option('keyMap', 'default', keyMapChanged);
    option('extraKeys', null);
    option('lineWrapping', false, wrappingChanged, true);
    option('gutters', [], function (cm) {
        setGuttersForLineNumbers(cm.options);
        guttersChanged(cm);
    }, true);
    option('fixedGutter', true, function (cm, val) {
        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + 'px' : '0';
        cm.refresh();
    }, true);
    option('coverGutterNextToScrollbar', false, updateScrollbars, true);
    option('lineNumbers', false, function (cm) {
        setGuttersForLineNumbers(cm.options);
        guttersChanged(cm);
    }, true);
    option('firstLineNumber', 1, guttersChanged, true);
    option('lineNumberFormatter', function (integer) {
        return integer;
    }, guttersChanged, true);
    option('showCursorWhenSelecting', false, updateSelection, true);
    option('resetSelectionOnContextMenu', true);
    option('readOnly', false, function (cm, val) {
        if (val == 'nocursor') {
            onBlur(cm);
            cm.display.input.blur();
            cm.display.disabled = true;
        } else {
            cm.display.disabled = false;
            if (!val)
                resetInput(cm);
        }
    });
    option('disableInput', false, function (cm, val) {
        if (!val)
            resetInput(cm);
    }, true);
    option('dragDrop', true);
    option('cursorBlinkRate', 530);
    option('cursorScrollMargin', 0);
    option('cursorHeight', 1, updateSelection, true);
    option('singleCursorHeightPerLine', true, updateSelection, true);
    option('workTime', 100);
    option('workDelay', 100);
    option('flattenSpans', true, resetModeState, true);
    option('addModeClass', false, resetModeState, true);
    option('pollInterval', 100);
    option('undoDepth', 200, function (cm, val) {
        cm.doc.history.undoDepth = val;
    });
    option('historyEventDelay', 1250);
    option('viewportMargin', 10, function (cm) {
        cm.refresh();
    }, true);
    option('maxHighlightLength', 10000, resetModeState, true);
    option('moveInputWithCursor', true, function (cm, val) {
        if (!val)
            cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
    });
    option('tabindex', null, function (cm, val) {
        cm.display.input.tabIndex = val || '';
    });
    option('autofocus', null);
    var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};
    CodeMirror.defineMode = function (name, mode) {
        if (!CodeMirror.defaults.mode && name != 'null')
            CodeMirror.defaults.mode = name;
        if (arguments.length > 2) {
            mode.dependencies = [];
            for (var i = 2; i < arguments.length; ++i)
                mode.dependencies.push(arguments[i]);
        }
        modes[name] = mode;
    };
    CodeMirror.defineMIME = function (mime, spec) {
        mimeModes[mime] = spec;
    };
    CodeMirror.resolveMode = function (spec) {
        if (typeof spec == 'string' && mimeModes.hasOwnProperty(spec)) {
            spec = mimeModes[spec];
        } else if (spec && typeof spec.name == 'string' && mimeModes.hasOwnProperty(spec.name)) {
            var found = mimeModes[spec.name];
            if (typeof found == 'string')
                found = { name: found };
            spec = createObj(found, spec);
            spec.name = found.name;
        } else if (typeof spec == 'string' && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
            return CodeMirror.resolveMode('application/xml');
        }
        if (typeof spec == 'string')
            return { name: spec };
        else
            return spec || { name: 'null' };
    };
    CodeMirror.getMode = function (options, spec) {
        var spec = CodeMirror.resolveMode(spec);
        var mfactory = modes[spec.name];
        if (!mfactory)
            return CodeMirror.getMode(options, 'text/plain');
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
            var exts = modeExtensions[spec.name];
            for (var prop in exts) {
                if (!exts.hasOwnProperty(prop))
                    continue;
                if (modeObj.hasOwnProperty(prop))
                    modeObj['_' + prop] = modeObj[prop];
                modeObj[prop] = exts[prop];
            }
        }
        modeObj.name = spec.name;
        if (spec.helperType)
            modeObj.helperType = spec.helperType;
        if (spec.modeProps)
            for (var prop in spec.modeProps)
                modeObj[prop] = spec.modeProps[prop];
        return modeObj;
    };
    CodeMirror.defineMode('null', function () {
        return {
            token: function (stream) {
                stream.skipToEnd();
            }
        };
    });
    CodeMirror.defineMIME('text/plain', 'null');
    var modeExtensions = CodeMirror.modeExtensions = {};
    CodeMirror.extendMode = function (mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
        copyObj(properties, exts);
    };
    CodeMirror.defineExtension = function (name, func) {
        CodeMirror.prototype[name] = func;
    };
    CodeMirror.defineDocExtension = function (name, func) {
        Doc.prototype[name] = func;
    };
    CodeMirror.defineOption = option;
    var initHooks = [];
    CodeMirror.defineInitHook = function (f) {
        initHooks.push(f);
    };
    var helpers = CodeMirror.helpers = {};
    CodeMirror.registerHelper = function (type, name, value) {
        if (!helpers.hasOwnProperty(type))
            helpers[type] = CodeMirror[type] = { _global: [] };
        helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
        CodeMirror.registerHelper(type, name, value);
        helpers[type]._global.push({
            pred: predicate,
            val: value
        });
    };
    var copyState = CodeMirror.copyState = function (mode, state) {
        if (state === true)
            return state;
        if (mode.copyState)
            return mode.copyState(state);
        var nstate = {};
        for (var n in state) {
            var val = state[n];
            if (val instanceof Array)
                val = val.concat([]);
            nstate[n] = val;
        }
        return nstate;
    };
    var startState = CodeMirror.startState = function (mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true;
    };
    CodeMirror.innerMode = function (mode, state) {
        while (mode.innerMode) {
            var info = mode.innerMode(state);
            if (!info || info.mode == mode)
                break;
            state = info.state;
            mode = info.mode;
        }
        return info || {
            mode: mode,
            state: state
        };
    };
    var commands = CodeMirror.commands = {
        selectAll: function (cm) {
            cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
        },
        singleSelection: function (cm) {
            cm.setSelection(cm.getCursor('anchor'), cm.getCursor('head'), sel_dontScroll);
        },
        killLine: function (cm) {
            deleteNearSelection(cm, function (range) {
                if (range.empty()) {
                    var len = getLine(cm.doc, range.head.line).text.length;
                    if (range.head.ch == len && range.head.line < cm.lastLine())
                        return {
                            from: range.head,
                            to: Pos(range.head.line + 1, 0)
                        };
                    else
                        return {
                            from: range.head,
                            to: Pos(range.head.line, len)
                        };
                } else {
                    return {
                        from: range.from(),
                        to: range.to()
                    };
                }
            });
        },
        deleteLine: function (cm) {
            deleteNearSelection(cm, function (range) {
                return {
                    from: Pos(range.from().line, 0),
                    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
                };
            });
        },
        delLineLeft: function (cm) {
            deleteNearSelection(cm, function (range) {
                return {
                    from: Pos(range.from().line, 0),
                    to: range.from()
                };
            });
        },
        delWrappedLineLeft: function (cm) {
            deleteNearSelection(cm, function (range) {
                var top = cm.charCoords(range.head, 'div').top + 5;
                var leftPos = cm.coordsChar({
                    left: 0,
                    top: top
                }, 'div');
                return {
                    from: leftPos,
                    to: range.from()
                };
            });
        },
        delWrappedLineRight: function (cm) {
            deleteNearSelection(cm, function (range) {
                var top = cm.charCoords(range.head, 'div').top + 5;
                var rightPos = cm.coordsChar({
                    left: cm.display.lineDiv.offsetWidth + 100,
                    top: top
                }, 'div');
                return {
                    from: range.from(),
                    to: rightPos
                };
            });
        },
        undo: function (cm) {
            cm.undo();
        },
        redo: function (cm) {
            cm.redo();
        },
        undoSelection: function (cm) {
            cm.undoSelection();
        },
        redoSelection: function (cm) {
            cm.redoSelection();
        },
        goDocStart: function (cm) {
            cm.extendSelection(Pos(cm.firstLine(), 0));
        },
        goDocEnd: function (cm) {
            cm.extendSelection(Pos(cm.lastLine()));
        },
        goLineStart: function (cm) {
            cm.extendSelectionsBy(function (range) {
                return lineStart(cm, range.head.line);
            }, {
                origin: '+move',
                bias: 1
            });
        },
        goLineStartSmart: function (cm) {
            cm.extendSelectionsBy(function (range) {
                return lineStartSmart(cm, range.head);
            }, {
                origin: '+move',
                bias: 1
            });
        },
        goLineEnd: function (cm) {
            cm.extendSelectionsBy(function (range) {
                return lineEnd(cm, range.head.line);
            }, {
                origin: '+move',
                bias: -1
            });
        },
        goLineRight: function (cm) {
            cm.extendSelectionsBy(function (range) {
                var top = cm.charCoords(range.head, 'div').top + 5;
                return cm.coordsChar({
                    left: cm.display.lineDiv.offsetWidth + 100,
                    top: top
                }, 'div');
            }, sel_move);
        },
        goLineLeft: function (cm) {
            cm.extendSelectionsBy(function (range) {
                var top = cm.charCoords(range.head, 'div').top + 5;
                return cm.coordsChar({
                    left: 0,
                    top: top
                }, 'div');
            }, sel_move);
        },
        goLineLeftSmart: function (cm) {
            cm.extendSelectionsBy(function (range) {
                var top = cm.charCoords(range.head, 'div').top + 5;
                var pos = cm.coordsChar({
                    left: 0,
                    top: top
                }, 'div');
                if (pos.ch < cm.getLine(pos.line).search(/\S/))
                    return lineStartSmart(cm, range.head);
                return pos;
            }, sel_move);
        },
        goLineUp: function (cm) {
            cm.moveV(-1, 'line');
        },
        goLineDown: function (cm) {
            cm.moveV(1, 'line');
        },
        goPageUp: function (cm) {
            cm.moveV(-1, 'page');
        },
        goPageDown: function (cm) {
            cm.moveV(1, 'page');
        },
        goCharLeft: function (cm) {
            cm.moveH(-1, 'char');
        },
        goCharRight: function (cm) {
            cm.moveH(1, 'char');
        },
        goColumnLeft: function (cm) {
            cm.moveH(-1, 'column');
        },
        goColumnRight: function (cm) {
            cm.moveH(1, 'column');
        },
        goWordLeft: function (cm) {
            cm.moveH(-1, 'word');
        },
        goGroupRight: function (cm) {
            cm.moveH(1, 'group');
        },
        goGroupLeft: function (cm) {
            cm.moveH(-1, 'group');
        },
        goWordRight: function (cm) {
            cm.moveH(1, 'word');
        },
        delCharBefore: function (cm) {
            cm.deleteH(-1, 'char');
        },
        delCharAfter: function (cm) {
            cm.deleteH(1, 'char');
        },
        delWordBefore: function (cm) {
            cm.deleteH(-1, 'word');
        },
        delWordAfter: function (cm) {
            cm.deleteH(1, 'word');
        },
        delGroupBefore: function (cm) {
            cm.deleteH(-1, 'group');
        },
        delGroupAfter: function (cm) {
            cm.deleteH(1, 'group');
        },
        indentAuto: function (cm) {
            cm.indentSelection('smart');
        },
        indentMore: function (cm) {
            cm.indentSelection('add');
        },
        indentLess: function (cm) {
            cm.indentSelection('subtract');
        },
        insertTab: function (cm) {
            cm.replaceSelection('\t');
        },
        insertSoftTab: function (cm) {
            var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
            for (var i = 0; i < ranges.length; i++) {
                var pos = ranges[i].from();
                var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
                spaces.push(new Array(tabSize - col % tabSize + 1).join(' '));
            }
            cm.replaceSelections(spaces);
        },
        defaultTab: function (cm) {
            if (cm.somethingSelected())
                cm.indentSelection('add');
            else
                cm.execCommand('insertTab');
        },
        transposeChars: function (cm) {
            runInOp(cm, function () {
                var ranges = cm.listSelections(), newSel = [];
                for (var i = 0; i < ranges.length; i++) {
                    var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
                    if (line) {
                        if (cur.ch == line.length)
                            cur = new Pos(cur.line, cur.ch - 1);
                        if (cur.ch > 0) {
                            cur = new Pos(cur.line, cur.ch + 1);
                            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, '+transpose');
                        } else if (cur.line > cm.doc.first) {
                            var prev = getLine(cm.doc, cur.line - 1).text;
                            if (prev)
                                cm.replaceRange(line.charAt(0) + '\n' + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), '+transpose');
                        }
                    }
                    newSel.push(new Range(cur, cur));
                }
                cm.setSelections(newSel);
            });
        },
        newlineAndIndent: function (cm) {
            runInOp(cm, function () {
                var len = cm.listSelections().length;
                for (var i = 0; i < len; i++) {
                    var range = cm.listSelections()[i];
                    cm.replaceRange('\n', range.anchor, range.head, '+input');
                    cm.indentLine(range.from().line + 1, null, true);
                    ensureCursorVisible(cm);
                }
            });
        },
        toggleOverwrite: function (cm) {
            cm.toggleOverwrite();
        }
    };
    var keyMap = CodeMirror.keyMap = {};
    keyMap.basic = {
        'Left': 'goCharLeft',
        'Right': 'goCharRight',
        'Up': 'goLineUp',
        'Down': 'goLineDown',
        'End': 'goLineEnd',
        'Home': 'goLineStartSmart',
        'PageUp': 'goPageUp',
        'PageDown': 'goPageDown',
        'Delete': 'delCharAfter',
        'Backspace': 'delCharBefore',
        'Shift-Backspace': 'delCharBefore',
        'Tab': 'defaultTab',
        'Shift-Tab': 'indentAuto',
        'Enter': 'newlineAndIndent',
        'Insert': 'toggleOverwrite',
        'Esc': 'singleSelection'
    };
    keyMap.pcDefault = {
        'Ctrl-A': 'selectAll',
        'Ctrl-D': 'deleteLine',
        'Ctrl-Z': 'undo',
        'Shift-Ctrl-Z': 'redo',
        'Ctrl-Y': 'redo',
        'Ctrl-Home': 'goDocStart',
        'Ctrl-Up': 'goDocStart',
        'Ctrl-End': 'goDocEnd',
        'Ctrl-Down': 'goDocEnd',
        'Ctrl-Left': 'goGroupLeft',
        'Ctrl-Right': 'goGroupRight',
        'Alt-Left': 'goLineStart',
        'Alt-Right': 'goLineEnd',
        'Ctrl-Backspace': 'delGroupBefore',
        'Ctrl-Delete': 'delGroupAfter',
        'Ctrl-S': 'save',
        'Ctrl-F': 'find',
        'Ctrl-G': 'findNext',
        'Shift-Ctrl-G': 'findPrev',
        'Shift-Ctrl-F': 'replace',
        'Shift-Ctrl-R': 'replaceAll',
        'Ctrl-[': 'indentLess',
        'Ctrl-]': 'indentMore',
        'Ctrl-U': 'undoSelection',
        'Shift-Ctrl-U': 'redoSelection',
        'Alt-U': 'redoSelection',
        fallthrough: 'basic'
    };
    keyMap.macDefault = {
        'Cmd-A': 'selectAll',
        'Cmd-D': 'deleteLine',
        'Cmd-Z': 'undo',
        'Shift-Cmd-Z': 'redo',
        'Cmd-Y': 'redo',
        'Cmd-Home': 'goDocStart',
        'Cmd-Up': 'goDocStart',
        'Cmd-End': 'goDocEnd',
        'Cmd-Down': 'goDocEnd',
        'Alt-Left': 'goGroupLeft',
        'Alt-Right': 'goGroupRight',
        'Cmd-Left': 'goLineLeft',
        'Cmd-Right': 'goLineRight',
        'Alt-Backspace': 'delGroupBefore',
        'Ctrl-Alt-Backspace': 'delGroupAfter',
        'Alt-Delete': 'delGroupAfter',
        'Cmd-S': 'save',
        'Cmd-F': 'find',
        'Cmd-G': 'findNext',
        'Shift-Cmd-G': 'findPrev',
        'Cmd-Alt-F': 'replace',
        'Shift-Cmd-Alt-F': 'replaceAll',
        'Cmd-[': 'indentLess',
        'Cmd-]': 'indentMore',
        'Cmd-Backspace': 'delWrappedLineLeft',
        'Cmd-Delete': 'delWrappedLineRight',
        'Cmd-U': 'undoSelection',
        'Shift-Cmd-U': 'redoSelection',
        fallthrough: [
            'basic',
            'emacsy'
        ]
    };
    keyMap.emacsy = {
        'Ctrl-F': 'goCharRight',
        'Ctrl-B': 'goCharLeft',
        'Ctrl-P': 'goLineUp',
        'Ctrl-N': 'goLineDown',
        'Alt-F': 'goWordRight',
        'Alt-B': 'goWordLeft',
        'Ctrl-A': 'goLineStart',
        'Ctrl-E': 'goLineEnd',
        'Ctrl-V': 'goPageDown',
        'Shift-Ctrl-V': 'goPageUp',
        'Ctrl-D': 'delCharAfter',
        'Ctrl-H': 'delCharBefore',
        'Alt-D': 'delWordAfter',
        'Alt-Backspace': 'delWordBefore',
        'Ctrl-K': 'killLine',
        'Ctrl-T': 'transposeChars'
    };
    keyMap['default'] = mac ? keyMap.macDefault : keyMap.pcDefault;
    function getKeyMap(val) {
        if (typeof val == 'string')
            return keyMap[val];
        else
            return val;
    }
    var lookupKey = CodeMirror.lookupKey = function (name, maps, handle) {
        function lookup(map) {
            map = getKeyMap(map);
            var found = map[name];
            if (found === false)
                return 'stop';
            if (found != null && handle(found))
                return true;
            if (map.nofallthrough)
                return 'stop';
            var fallthrough = map.fallthrough;
            if (fallthrough == null)
                return false;
            if (Object.prototype.toString.call(fallthrough) != '[object Array]')
                return lookup(fallthrough);
            for (var i = 0; i < fallthrough.length; ++i) {
                var done = lookup(fallthrough[i]);
                if (done)
                    return done;
            }
            return false;
        }
        for (var i = 0; i < maps.length; ++i) {
            var done = lookup(maps[i]);
            if (done)
                return done != 'stop';
        }
    };
    var isModifierKey = CodeMirror.isModifierKey = function (event) {
        var name = keyNames[event.keyCode];
        return name == 'Ctrl' || name == 'Alt' || name == 'Shift' || name == 'Mod';
    };
    var keyName = CodeMirror.keyName = function (event, noShift) {
        if (presto && event.keyCode == 34 && event['char'])
            return false;
        var name = keyNames[event.keyCode];
        if (name == null || event.altGraphKey)
            return false;
        if (event.altKey)
            name = 'Alt-' + name;
        if (flipCtrlCmd ? event.metaKey : event.ctrlKey)
            name = 'Ctrl-' + name;
        if (flipCtrlCmd ? event.ctrlKey : event.metaKey)
            name = 'Cmd-' + name;
        if (!noShift && event.shiftKey)
            name = 'Shift-' + name;
        return name;
    };
    CodeMirror.fromTextArea = function (textarea, options) {
        if (!options)
            options = {};
        options.value = textarea.value;
        if (!options.tabindex && textarea.tabindex)
            options.tabindex = textarea.tabindex;
        if (!options.placeholder && textarea.placeholder)
            options.placeholder = textarea.placeholder;
        if (options.autofocus == null) {
            var hasFocus = activeElt();
            options.autofocus = hasFocus == textarea || textarea.getAttribute('autofocus') != null && hasFocus == document.body;
        }
        function save() {
            textarea.value = cm.getValue();
        }
        if (textarea.form) {
            on(textarea.form, 'submit', save);
            if (!options.leaveSubmitMethodAlone) {
                var form = textarea.form, realSubmit = form.submit;
                try {
                    var wrappedSubmit = form.submit = function () {
                        save();
                        form.submit = realSubmit;
                        form.submit();
                        form.submit = wrappedSubmit;
                    };
                } catch (e) {
                }
            }
        }
        textarea.style.display = 'none';
        var cm = CodeMirror(function (node) {
            textarea.parentNode.insertBefore(node, textarea.nextSibling);
        }, options);
        cm.save = save;
        cm.getTextArea = function () {
            return textarea;
        };
        cm.toTextArea = function () {
            save();
            textarea.parentNode.removeChild(cm.getWrapperElement());
            textarea.style.display = '';
            if (textarea.form) {
                off(textarea.form, 'submit', save);
                if (typeof textarea.form.submit == 'function')
                    textarea.form.submit = realSubmit;
            }
        };
        return cm;
    };
    var StringStream = CodeMirror.StringStream = function (string, tabSize) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
        this.lineStart = 0;
    };
    StringStream.prototype = {
        eol: function () {
            return this.pos >= this.string.length;
        },
        sol: function () {
            return this.pos == this.lineStart;
        },
        peek: function () {
            return this.string.charAt(this.pos) || undefined;
        },
        next: function () {
            if (this.pos < this.string.length)
                return this.string.charAt(this.pos++);
        },
        eat: function (match) {
            var ch = this.string.charAt(this.pos);
            if (typeof match == 'string')
                var ok = ch == match;
            else
                var ok = ch && (match.test ? match.test(ch) : match(ch));
            if (ok) {
                ++this.pos;
                return ch;
            }
        },
        eatWhile: function (match) {
            var start = this.pos;
            while (this.eat(match)) {
            }
            return this.pos > start;
        },
        eatSpace: function () {
            var start = this.pos;
            while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
                ++this.pos;
            return this.pos > start;
        },
        skipToEnd: function () {
            this.pos = this.string.length;
        },
        skipTo: function (ch) {
            var found = this.string.indexOf(ch, this.pos);
            if (found > -1) {
                this.pos = found;
                return true;
            }
        },
        backUp: function (n) {
            this.pos -= n;
        },
        column: function () {
            if (this.lastColumnPos < this.start) {
                this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
                this.lastColumnPos = this.start;
            }
            return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        },
        indentation: function () {
            return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        },
        match: function (pattern, consume, caseInsensitive) {
            if (typeof pattern == 'string') {
                var cased = function (str) {
                    return caseInsensitive ? str.toLowerCase() : str;
                };
                var substr = this.string.substr(this.pos, pattern.length);
                if (cased(substr) == cased(pattern)) {
                    if (consume !== false)
                        this.pos += pattern.length;
                    return true;
                }
            } else {
                var match = this.string.slice(this.pos).match(pattern);
                if (match && match.index > 0)
                    return null;
                if (match && consume !== false)
                    this.pos += match[0].length;
                return match;
            }
        },
        current: function () {
            return this.string.slice(this.start, this.pos);
        },
        hideFirstChars: function (n, inner) {
            this.lineStart += n;
            try {
                return inner();
            } finally {
                this.lineStart -= n;
            }
        }
    };
    var TextMarker = CodeMirror.TextMarker = function (doc, type) {
        this.lines = [];
        this.type = type;
        this.doc = doc;
    };
    eventMixin(TextMarker);
    TextMarker.prototype.clear = function () {
        if (this.explicitlyCleared)
            return;
        var cm = this.doc.cm, withOp = cm && !cm.curOp;
        if (withOp)
            startOperation(cm);
        if (hasHandler(this, 'clear')) {
            var found = this.find();
            if (found)
                signalLater(this, 'clear', found.from, found.to);
        }
        var min = null, max = null;
        for (var i = 0; i < this.lines.length; ++i) {
            var line = this.lines[i];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (cm && !this.collapsed)
                regLineChange(cm, lineNo(line), 'text');
            else if (cm) {
                if (span.to != null)
                    max = lineNo(line);
                if (span.from != null)
                    min = lineNo(line);
            }
            line.markedSpans = removeMarkedSpan(line.markedSpans, span);
            if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
                updateLineHeight(line, textHeight(cm.display));
        }
        if (cm && this.collapsed && !cm.options.lineWrapping)
            for (var i = 0; i < this.lines.length; ++i) {
                var visual = visualLine(this.lines[i]), len = lineLength(visual);
                if (len > cm.display.maxLineLength) {
                    cm.display.maxLine = visual;
                    cm.display.maxLineLength = len;
                    cm.display.maxLineChanged = true;
                }
            }
        if (min != null && cm && this.collapsed)
            regChange(cm, min, max + 1);
        this.lines.length = 0;
        this.explicitlyCleared = true;
        if (this.atomic && this.doc.cantEdit) {
            this.doc.cantEdit = false;
            if (cm)
                reCheckSelection(cm.doc);
        }
        if (cm)
            signalLater(cm, 'markerCleared', cm, this);
        if (withOp)
            endOperation(cm);
        if (this.parent)
            this.parent.clear();
    };
    TextMarker.prototype.find = function (side, lineObj) {
        if (side == null && this.type == 'bookmark')
            side = 1;
        var from, to;
        for (var i = 0; i < this.lines.length; ++i) {
            var line = this.lines[i];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (span.from != null) {
                from = Pos(lineObj ? line : lineNo(line), span.from);
                if (side == -1)
                    return from;
            }
            if (span.to != null) {
                to = Pos(lineObj ? line : lineNo(line), span.to);
                if (side == 1)
                    return to;
            }
        }
        return from && {
            from: from,
            to: to
        };
    };
    TextMarker.prototype.changed = function () {
        var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
        if (!pos || !cm)
            return;
        runInOp(cm, function () {
            var line = pos.line, lineN = lineNo(pos.line);
            var view = findViewForLine(cm, lineN);
            if (view) {
                clearLineMeasurementCacheFor(view);
                cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
            }
            cm.curOp.updateMaxLine = true;
            if (!lineIsHidden(widget.doc, line) && widget.height != null) {
                var oldHeight = widget.height;
                widget.height = null;
                var dHeight = widgetHeight(widget) - oldHeight;
                if (dHeight)
                    updateLineHeight(line, line.height + dHeight);
            }
        });
    };
    TextMarker.prototype.attachLine = function (line) {
        if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
                (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
        }
        this.lines.push(line);
    };
    TextMarker.prototype.detachLine = function (line) {
        this.lines.splice(indexOf(this.lines, line), 1);
        if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
        }
    };
    var nextMarkerId = 0;
    function markText(doc, from, to, options, type) {
        if (options && options.shared)
            return markTextShared(doc, from, to, options, type);
        if (doc.cm && !doc.cm.curOp)
            return operation(doc.cm, markText)(doc, from, to, options, type);
        var marker = new TextMarker(doc, type), diff = cmp(from, to);
        if (options)
            copyObj(options, marker, false);
        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
            return marker;
        if (marker.replacedWith) {
            marker.collapsed = true;
            marker.widgetNode = elt('span', [marker.replacedWith], 'CodeMirror-widget');
            if (!options.handleMouseEvents)
                marker.widgetNode.ignoreEvents = true;
            if (options.insertLeft)
                marker.widgetNode.insertLeft = true;
        }
        if (marker.collapsed) {
            if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
                throw new Error('Inserting collapsed marker partially overlapping an existing one');
            sawCollapsedSpans = true;
        }
        if (marker.addToHistory)
            addChangeToHistory(doc, {
                from: from,
                to: to,
                origin: 'markText'
            }, doc.sel, NaN);
        var curLine = from.line, cm = doc.cm, updateMaxLine;
        doc.iter(curLine, to.line + 1, function (line) {
            if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
                updateMaxLine = true;
            if (marker.collapsed && curLine != from.line)
                updateLineHeight(line, 0);
            addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
            ++curLine;
        });
        if (marker.collapsed)
            doc.iter(from.line, to.line + 1, function (line) {
                if (lineIsHidden(doc, line))
                    updateLineHeight(line, 0);
            });
        if (marker.clearOnEnter)
            on(marker, 'beforeCursorEnter', function () {
                marker.clear();
            });
        if (marker.readOnly) {
            sawReadOnlySpans = true;
            if (doc.history.done.length || doc.history.undone.length)
                doc.clearHistory();
        }
        if (marker.collapsed) {
            marker.id = ++nextMarkerId;
            marker.atomic = true;
        }
        if (cm) {
            if (updateMaxLine)
                cm.curOp.updateMaxLine = true;
            if (marker.collapsed)
                regChange(cm, from.line, to.line + 1);
            else if (marker.className || marker.title || marker.startStyle || marker.endStyle)
                for (var i = from.line; i <= to.line; i++)
                    regLineChange(cm, i, 'text');
            if (marker.atomic)
                reCheckSelection(cm.doc);
            signalLater(cm, 'markerAdded', cm, marker);
        }
        return marker;
    }
    var SharedTextMarker = CodeMirror.SharedTextMarker = function (markers, primary) {
        this.markers = markers;
        this.primary = primary;
        for (var i = 0; i < markers.length; ++i)
            markers[i].parent = this;
    };
    eventMixin(SharedTextMarker);
    SharedTextMarker.prototype.clear = function () {
        if (this.explicitlyCleared)
            return;
        this.explicitlyCleared = true;
        for (var i = 0; i < this.markers.length; ++i)
            this.markers[i].clear();
        signalLater(this, 'clear');
    };
    SharedTextMarker.prototype.find = function (side, lineObj) {
        return this.primary.find(side, lineObj);
    };
    function markTextShared(doc, from, to, options, type) {
        options = copyObj(options);
        options.shared = false;
        var markers = [markText(doc, from, to, options, type)], primary = markers[0];
        var widget = options.widgetNode;
        linkedDocs(doc, function (doc) {
            if (widget)
                options.widgetNode = widget.cloneNode(true);
            markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
            for (var i = 0; i < doc.linked.length; ++i)
                if (doc.linked[i].isParent)
                    return;
            primary = lst(markers);
        });
        return new SharedTextMarker(markers, primary);
    }
    function findSharedMarkers(doc) {
        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {
            return m.parent;
        });
    }
    function copySharedMarkers(doc, markers) {
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i], pos = marker.find();
            var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
            if (cmp(mFrom, mTo)) {
                var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
                marker.markers.push(subMark);
                subMark.parent = marker;
            }
        }
    }
    function detachSharedMarkers(markers) {
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i], linked = [marker.primary.doc];
            ;
            linkedDocs(marker.primary.doc, function (d) {
                linked.push(d);
            });
            for (var j = 0; j < marker.markers.length; j++) {
                var subMarker = marker.markers[j];
                if (indexOf(linked, subMarker.doc) == -1) {
                    subMarker.parent = null;
                    marker.markers.splice(j--, 1);
                }
            }
        }
    }
    function MarkedSpan(marker, from, to) {
        this.marker = marker;
        this.from = from;
        this.to = to;
    }
    function getMarkedSpanFor(spans, marker) {
        if (spans)
            for (var i = 0; i < spans.length; ++i) {
                var span = spans[i];
                if (span.marker == marker)
                    return span;
            }
    }
    function removeMarkedSpan(spans, span) {
        for (var r, i = 0; i < spans.length; ++i)
            if (spans[i] != span)
                (r || (r = [])).push(spans[i]);
        return r;
    }
    function addMarkedSpan(line, span) {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
        span.marker.attachLine(line);
    }
    function markedSpansBefore(old, startCh, isInsert) {
        if (old)
            for (var i = 0, nw; i < old.length; ++i) {
                var span = old[i], marker = span.marker;
                var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
                if (startsBefore || span.from == startCh && marker.type == 'bookmark' && (!isInsert || !span.marker.insertLeft)) {
                    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                    (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
                }
            }
        return nw;
    }
    function markedSpansAfter(old, endCh, isInsert) {
        if (old)
            for (var i = 0, nw; i < old.length; ++i) {
                var span = old[i], marker = span.marker;
                var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
                if (endsAfter || span.from == endCh && marker.type == 'bookmark' && (!isInsert || span.marker.insertLeft)) {
                    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                    (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
                }
            }
        return nw;
    }
    function stretchSpansOverChange(doc, change) {
        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
        var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
        if (!oldFirst && !oldLast)
            return null;
        var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
        var first = markedSpansBefore(oldFirst, startCh, isInsert);
        var last = markedSpansAfter(oldLast, endCh, isInsert);
        var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first) {
            for (var i = 0; i < first.length; ++i) {
                var span = first[i];
                if (span.to == null) {
                    var found = getMarkedSpanFor(last, span.marker);
                    if (!found)
                        span.to = startCh;
                    else if (sameLine)
                        span.to = found.to == null ? null : found.to + offset;
                }
            }
        }
        if (last) {
            for (var i = 0; i < last.length; ++i) {
                var span = last[i];
                if (span.to != null)
                    span.to += offset;
                if (span.from == null) {
                    var found = getMarkedSpanFor(first, span.marker);
                    if (!found) {
                        span.from = offset;
                        if (sameLine)
                            (first || (first = [])).push(span);
                    }
                } else {
                    span.from += offset;
                    if (sameLine)
                        (first || (first = [])).push(span);
                }
            }
        }
        if (first)
            first = clearEmptySpans(first);
        if (last && last != first)
            last = clearEmptySpans(last);
        var newMarkers = [first];
        if (!sameLine) {
            var gap = change.text.length - 2, gapMarkers;
            if (gap > 0 && first)
                for (var i = 0; i < first.length; ++i)
                    if (first[i].to == null)
                        (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
            for (var i = 0; i < gap; ++i)
                newMarkers.push(gapMarkers);
            newMarkers.push(last);
        }
        return newMarkers;
    }
    function clearEmptySpans(spans) {
        for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];
            if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
                spans.splice(i--, 1);
        }
        if (!spans.length)
            return null;
        return spans;
    }
    function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change);
        var stretched = stretchSpansOverChange(doc, change);
        if (!old)
            return stretched;
        if (!stretched)
            return old;
        for (var i = 0; i < old.length; ++i) {
            var oldCur = old[i], stretchCur = stretched[i];
            if (oldCur && stretchCur) {
                spans:
                    for (var j = 0; j < stretchCur.length; ++j) {
                        var span = stretchCur[j];
                        for (var k = 0; k < oldCur.length; ++k)
                            if (oldCur[k].marker == span.marker)
                                continue spans;
                        oldCur.push(span);
                    }
            } else if (stretchCur) {
                old[i] = stretchCur;
            }
        }
        return old;
    }
    function removeReadOnlyRanges(doc, from, to) {
        var markers = null;
        doc.iter(from.line, to.line + 1, function (line) {
            if (line.markedSpans)
                for (var i = 0; i < line.markedSpans.length; ++i) {
                    var mark = line.markedSpans[i].marker;
                    if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
                        (markers || (markers = [])).push(mark);
                }
        });
        if (!markers)
            return null;
        var parts = [{
                from: from,
                to: to
            }];
        for (var i = 0; i < markers.length; ++i) {
            var mk = markers[i], m = mk.find(0);
            for (var j = 0; j < parts.length; ++j) {
                var p = parts[j];
                if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0)
                    continue;
                var newParts = [
                        j,
                        1
                    ], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
                if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
                    newParts.push({
                        from: p.from,
                        to: m.from
                    });
                if (dto > 0 || !mk.inclusiveRight && !dto)
                    newParts.push({
                        from: m.to,
                        to: p.to
                    });
                parts.splice.apply(parts, newParts);
                j += newParts.length - 1;
            }
        }
        return parts;
    }
    function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (!spans)
            return;
        for (var i = 0; i < spans.length; ++i)
            spans[i].marker.detachLine(line);
        line.markedSpans = null;
    }
    function attachMarkedSpans(line, spans) {
        if (!spans)
            return;
        for (var i = 0; i < spans.length; ++i)
            spans[i].marker.attachLine(line);
        line.markedSpans = spans;
    }
    function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0;
    }
    function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0;
    }
    function compareCollapsedMarkers(a, b) {
        var lenDiff = a.lines.length - b.lines.length;
        if (lenDiff != 0)
            return lenDiff;
        var aPos = a.find(), bPos = b.find();
        var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
        if (fromCmp)
            return -fromCmp;
        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
        if (toCmp)
            return toCmp;
        return b.id - a.id;
    }
    function collapsedSpanAtSide(line, start) {
        var sps = sawCollapsedSpans && line.markedSpans, found;
        if (sps)
            for (var sp, i = 0; i < sps.length; ++i) {
                sp = sps[i];
                if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0))
                    found = sp.marker;
            }
        return found;
    }
    function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, true);
    }
    function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, false);
    }
    function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
        var line = getLine(doc, lineNo);
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps)
            for (var i = 0; i < sps.length; ++i) {
                var sp = sps[i];
                if (!sp.marker.collapsed)
                    continue;
                var found = sp.marker.find(0);
                var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
                var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
                if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0)
                    continue;
                if (fromCmp <= 0 && (cmp(found.to, from) > 0 || sp.marker.inclusiveRight && marker.inclusiveLeft) || fromCmp >= 0 && (cmp(found.from, to) < 0 || sp.marker.inclusiveLeft && marker.inclusiveRight))
                    return true;
            }
    }
    function visualLine(line) {
        var merged;
        while (merged = collapsedSpanAtStart(line))
            line = merged.find(-1, true).line;
        return line;
    }
    function visualLineContinued(line) {
        var merged, lines;
        while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
            (lines || (lines = [])).push(line);
        }
        return lines;
    }
    function visualLineNo(doc, lineN) {
        var line = getLine(doc, lineN), vis = visualLine(line);
        if (line == vis)
            return lineN;
        return lineNo(vis);
    }
    function visualLineEndNo(doc, lineN) {
        if (lineN > doc.lastLine())
            return lineN;
        var line = getLine(doc, lineN), merged;
        if (!lineIsHidden(doc, line))
            return lineN;
        while (merged = collapsedSpanAtEnd(line))
            line = merged.find(1, true).line;
        return lineNo(line) + 1;
    }
    function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps)
            for (var sp, i = 0; i < sps.length; ++i) {
                sp = sps[i];
                if (!sp.marker.collapsed)
                    continue;
                if (sp.from == null)
                    return true;
                if (sp.marker.widgetNode)
                    continue;
                if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
                    return true;
            }
    }
    function lineIsHiddenInner(doc, line, span) {
        if (span.to == null) {
            var end = span.marker.find(1, true);
            return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
        }
        if (span.marker.inclusiveRight && span.to == line.text.length)
            return true;
        for (var sp, i = 0; i < line.markedSpans.length; ++i) {
            sp = line.markedSpans[i];
            if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
                return true;
        }
    }
    var LineWidget = CodeMirror.LineWidget = function (cm, node, options) {
        if (options)
            for (var opt in options)
                if (options.hasOwnProperty(opt))
                    this[opt] = options[opt];
        this.cm = cm;
        this.node = node;
    };
    eventMixin(LineWidget);
    function adjustScrollWhenAboveVisible(cm, line, diff) {
        if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop))
            addToScrollPos(cm, null, diff);
    }
    LineWidget.prototype.clear = function () {
        var cm = this.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
        if (no == null || !ws)
            return;
        for (var i = 0; i < ws.length; ++i)
            if (ws[i] == this)
                ws.splice(i--, 1);
        if (!ws.length)
            line.widgets = null;
        var height = widgetHeight(this);
        runInOp(cm, function () {
            adjustScrollWhenAboveVisible(cm, line, -height);
            regLineChange(cm, no, 'widget');
            updateLineHeight(line, Math.max(0, line.height - height));
        });
    };
    LineWidget.prototype.changed = function () {
        var oldH = this.height, cm = this.cm, line = this.line;
        this.height = null;
        var diff = widgetHeight(this) - oldH;
        if (!diff)
            return;
        runInOp(cm, function () {
            cm.curOp.forceUpdate = true;
            adjustScrollWhenAboveVisible(cm, line, diff);
            updateLineHeight(line, line.height + diff);
        });
    };
    function widgetHeight(widget) {
        if (widget.height != null)
            return widget.height;
        if (!contains(document.body, widget.node)) {
            var parentStyle = 'position: relative;';
            if (widget.coverGutter)
                parentStyle += 'margin-left: -' + widget.cm.getGutterElement().offsetWidth + 'px;';
            removeChildrenAndAdd(widget.cm.display.measure, elt('div', [widget.node], null, parentStyle));
        }
        return widget.height = widget.node.offsetHeight;
    }
    function addLineWidget(cm, handle, node, options) {
        var widget = new LineWidget(cm, node, options);
        if (widget.noHScroll)
            cm.display.alignWidgets = true;
        changeLine(cm.doc, handle, 'widget', function (line) {
            var widgets = line.widgets || (line.widgets = []);
            if (widget.insertAt == null)
                widgets.push(widget);
            else
                widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
            widget.line = line;
            if (!lineIsHidden(cm.doc, line)) {
                var aboveVisible = heightAtLine(line) < cm.doc.scrollTop;
                updateLineHeight(line, line.height + widgetHeight(widget));
                if (aboveVisible)
                    addToScrollPos(cm, null, widget.height);
                cm.curOp.forceUpdate = true;
            }
            return true;
        });
        return widget;
    }
    var Line = CodeMirror.Line = function (text, markedSpans, estimateHeight) {
        this.text = text;
        attachMarkedSpans(this, markedSpans);
        this.height = estimateHeight ? estimateHeight(this) : 1;
    };
    eventMixin(Line);
    Line.prototype.lineNo = function () {
        return lineNo(this);
    };
    function updateLine(line, text, markedSpans, estimateHeight) {
        line.text = text;
        if (line.stateAfter)
            line.stateAfter = null;
        if (line.styles)
            line.styles = null;
        if (line.order != null)
            line.order = null;
        detachMarkedSpans(line);
        attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight ? estimateHeight(line) : 1;
        if (estHeight != line.height)
            updateLineHeight(line, estHeight);
    }
    function cleanUpLine(line) {
        line.parent = null;
        detachMarkedSpans(line);
    }
    function extractLineClasses(type, output) {
        if (type)
            for (;;) {
                var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
                if (!lineClass)
                    break;
                type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
                var prop = lineClass[1] ? 'bgClass' : 'textClass';
                if (output[prop] == null)
                    output[prop] = lineClass[2];
                else if (!new RegExp('(?:^|s)' + lineClass[2] + '(?:$|s)').test(output[prop]))
                    output[prop] += ' ' + lineClass[2];
            }
        return type;
    }
    function callBlankLine(mode, state) {
        if (mode.blankLine)
            return mode.blankLine(state);
        if (!mode.innerMode)
            return;
        var inner = CodeMirror.innerMode(mode, state);
        if (inner.mode.blankLine)
            return inner.mode.blankLine(inner.state);
    }
    function readToken(mode, stream, state) {
        for (var i = 0; i < 10; i++) {
            var style = mode.token(stream, state);
            if (stream.pos > stream.start)
                return style;
        }
        throw new Error('Mode ' + mode.name + ' failed to advance stream.');
    }
    function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans;
        if (flattenSpans == null)
            flattenSpans = cm.options.flattenSpans;
        var curStart = 0, curStyle = null;
        var stream = new StringStream(text, cm.options.tabSize), style;
        if (text == '')
            extractLineClasses(callBlankLine(mode, state), lineClasses);
        while (!stream.eol()) {
            if (stream.pos > cm.options.maxHighlightLength) {
                flattenSpans = false;
                if (forceToEnd)
                    processLine(cm, text, state, stream.pos);
                stream.pos = text.length;
                style = null;
            } else {
                style = extractLineClasses(readToken(mode, stream, state), lineClasses);
            }
            if (cm.options.addModeClass) {
                var mName = CodeMirror.innerMode(mode, state).mode.name;
                if (mName)
                    style = 'm-' + (style ? mName + ' ' + style : mName);
            }
            if (!flattenSpans || curStyle != style) {
                if (curStart < stream.start)
                    f(stream.start, curStyle);
                curStart = stream.start;
                curStyle = style;
            }
            stream.start = stream.pos;
        }
        while (curStart < stream.pos) {
            var pos = Math.min(stream.pos, curStart + 50000);
            f(pos, curStyle);
            curStart = pos;
        }
    }
    function highlightLine(cm, line, state, forceToEnd) {
        var st = [cm.state.modeGen], lineClasses = {};
        runMode(cm, line.text, cm.doc.mode, state, function (end, style) {
            st.push(end, style);
        }, lineClasses, forceToEnd);
        for (var o = 0; o < cm.state.overlays.length; ++o) {
            var overlay = cm.state.overlays[o], i = 1, at = 0;
            runMode(cm, line.text, overlay.mode, true, function (end, style) {
                var start = i;
                while (at < end) {
                    var i_end = st[i];
                    if (i_end > end)
                        st.splice(i, 1, end, st[i + 1], i_end);
                    i += 2;
                    at = Math.min(end, i_end);
                }
                if (!style)
                    return;
                if (overlay.opaque) {
                    st.splice(start, i - start, end, 'cm-overlay ' + style);
                    i = start + 2;
                } else {
                    for (; start < i; start += 2) {
                        var cur = st[start + 1];
                        st[start + 1] = (cur ? cur + ' ' : '') + 'cm-overlay ' + style;
                    }
                }
            }, lineClasses);
        }
        return {
            styles: st,
            classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
        };
    }
    function getLineStyles(cm, line) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
            var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
            line.styles = result.styles;
            if (result.classes)
                line.styleClasses = result.classes;
            else if (line.styleClasses)
                line.styleClasses = null;
        }
        return line.styles;
    }
    function processLine(cm, text, state, startAt) {
        var mode = cm.doc.mode;
        var stream = new StringStream(text, cm.options.tabSize);
        stream.start = stream.pos = startAt || 0;
        if (text == '')
            callBlankLine(mode, state);
        while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
            readToken(mode, stream, state);
            stream.start = stream.pos;
        }
    }
    var styleToClassCache = {}, styleToClassCacheWithMode = {};
    function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style))
            return null;
        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] || (cache[style] = style.replace(/\S+/g, 'cm-$&'));
    }
    function buildLineContent(cm, lineView) {
        var content = elt('span', null, null, webkit ? 'padding-right: .1px' : null);
        var builder = {
            pre: elt('pre', [content]),
            content: content,
            col: 0,
            pos: 0,
            cm: cm
        };
        lineView.measure = {};
        for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
            var line = i ? lineView.rest[i - 1] : lineView.line, order;
            builder.pos = 0;
            builder.addToken = buildToken;
            if ((ie || webkit) && cm.getOption('lineWrapping'))
                builder.addToken = buildTokenSplitSpaces(builder.addToken);
            if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
                builder.addToken = buildTokenBadBidi(builder.addToken, order);
            builder.map = [];
            insertLineContent(line, builder, getLineStyles(cm, line));
            if (line.styleClasses) {
                if (line.styleClasses.bgClass)
                    builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || '');
                if (line.styleClasses.textClass)
                    builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || '');
            }
            if (builder.map.length == 0)
                builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
            if (i == 0) {
                lineView.measure.map = builder.map;
                lineView.measure.cache = {};
            } else {
                (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
                (lineView.measure.caches || (lineView.measure.caches = [])).push({});
            }
        }
        signal(cm, 'renderLine', cm, lineView.line, builder.pre);
        if (builder.pre.className)
            builder.textClass = joinClasses(builder.pre.className, builder.textClass || '');
        return builder;
    }
    function defaultSpecialCharPlaceholder(ch) {
        var token = elt('span', '\u2022', 'cm-invalidchar');
        token.title = '\\u' + ch.charCodeAt(0).toString(16);
        return token;
    }
    function buildToken(builder, text, style, startStyle, endStyle, title) {
        if (!text)
            return;
        var special = builder.cm.options.specialChars, mustWrap = false;
        if (!special.test(text)) {
            builder.col += text.length;
            var content = document.createTextNode(text);
            builder.map.push(builder.pos, builder.pos + text.length, content);
            if (ie && ie_version < 9)
                mustWrap = true;
            builder.pos += text.length;
        } else {
            var content = document.createDocumentFragment(), pos = 0;
            while (true) {
                special.lastIndex = pos;
                var m = special.exec(text);
                var skipped = m ? m.index - pos : text.length - pos;
                if (skipped) {
                    var txt = document.createTextNode(text.slice(pos, pos + skipped));
                    if (ie && ie_version < 9)
                        content.appendChild(elt('span', [txt]));
                    else
                        content.appendChild(txt);
                    builder.map.push(builder.pos, builder.pos + skipped, txt);
                    builder.col += skipped;
                    builder.pos += skipped;
                }
                if (!m)
                    break;
                pos += skipped + 1;
                if (m[0] == '\t') {
                    var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                    var txt = content.appendChild(elt('span', spaceStr(tabWidth), 'cm-tab'));
                    builder.col += tabWidth;
                } else {
                    var txt = builder.cm.options.specialCharPlaceholder(m[0]);
                    if (ie && ie_version < 9)
                        content.appendChild(elt('span', [txt]));
                    else
                        content.appendChild(txt);
                    builder.col += 1;
                }
                builder.map.push(builder.pos, builder.pos + 1, txt);
                builder.pos++;
            }
        }
        if (style || startStyle || endStyle || mustWrap) {
            var fullStyle = style || '';
            if (startStyle)
                fullStyle += startStyle;
            if (endStyle)
                fullStyle += endStyle;
            var token = elt('span', [content], fullStyle);
            if (title)
                token.title = title;
            return builder.content.appendChild(token);
        }
        builder.content.appendChild(content);
    }
    function buildTokenSplitSpaces(inner) {
        function split(old) {
            var out = ' ';
            for (var i = 0; i < old.length - 2; ++i)
                out += i % 2 ? ' ' : '\xA0';
            out += ' ';
            return out;
        }
        return function (builder, text, style, startStyle, endStyle, title) {
            inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);
        };
    }
    function buildTokenBadBidi(inner, order) {
        return function (builder, text, style, startStyle, endStyle, title) {
            style = style ? style + ' cm-force-border' : 'cm-force-border';
            var start = builder.pos, end = start + text.length;
            for (;;) {
                for (var i = 0; i < order.length; i++) {
                    var part = order[i];
                    if (part.to > start && part.from <= start)
                        break;
                }
                if (part.to >= end)
                    return inner(builder, text, style, startStyle, endStyle, title);
                inner(builder, text.slice(0, part.to - start), style, startStyle, null, title);
                startStyle = null;
                text = text.slice(part.to - start);
                start = part.to;
            }
        };
    }
    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;
        if (widget) {
            builder.map.push(builder.pos, builder.pos + size, widget);
            builder.content.appendChild(widget);
        }
        builder.pos += size;
    }
    function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans, allText = line.text, at = 0;
        if (!spans) {
            for (var i = 1; i < styles.length; i += 2)
                builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i + 1], builder.cm.options));
            return;
        }
        var len = allText.length, pos = 0, i = 1, text = '', style;
        var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
        for (;;) {
            if (nextChange == pos) {
                spanStyle = spanEndStyle = spanStartStyle = title = '';
                collapsed = null;
                nextChange = Infinity;
                var foundBookmarks = [];
                for (var j = 0; j < spans.length; ++j) {
                    var sp = spans[j], m = sp.marker;
                    if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
                        if (sp.to != null && nextChange > sp.to) {
                            nextChange = sp.to;
                            spanEndStyle = '';
                        }
                        if (m.className)
                            spanStyle += ' ' + m.className;
                        if (m.startStyle && sp.from == pos)
                            spanStartStyle += ' ' + m.startStyle;
                        if (m.endStyle && sp.to == nextChange)
                            spanEndStyle += ' ' + m.endStyle;
                        if (m.title && !title)
                            title = m.title;
                        if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
                            collapsed = sp;
                    } else if (sp.from > pos && nextChange > sp.from) {
                        nextChange = sp.from;
                    }
                    if (m.type == 'bookmark' && sp.from == pos && m.widgetNode)
                        foundBookmarks.push(m);
                }
                if (collapsed && (collapsed.from || 0) == pos) {
                    buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
                    if (collapsed.to == null)
                        return;
                }
                if (!collapsed && foundBookmarks.length)
                    for (var j = 0; j < foundBookmarks.length; ++j)
                        buildCollapsedSpan(builder, 0, foundBookmarks[j]);
            }
            if (pos >= len)
                break;
            var upto = Math.min(len, nextChange);
            while (true) {
                if (text) {
                    var end = pos + text.length;
                    if (!collapsed) {
                        var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                        builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : '', title);
                    }
                    if (end >= upto) {
                        text = text.slice(upto - pos);
                        pos = upto;
                        break;
                    }
                    pos = end;
                    spanStartStyle = '';
                }
                text = allText.slice(at, at = styles[i++]);
                style = interpretTokenStyle(styles[i++], builder.cm.options);
            }
        }
    }
    function isWholeLineUpdate(doc, change) {
        return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == '' && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
    }
    function updateDoc(doc, change, markedSpans, estimateHeight) {
        function spansFor(n) {
            return markedSpans ? markedSpans[n] : null;
        }
        function update(line, text, spans) {
            updateLine(line, text, spans, estimateHeight);
            signalLater(line, 'change', line, change);
        }
        var from = change.from, to = change.to, text = change.text;
        var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
        var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
        if (isWholeLineUpdate(doc, change)) {
            for (var i = 0, added = []; i < text.length - 1; ++i)
                added.push(new Line(text[i], spansFor(i), estimateHeight));
            update(lastLine, lastLine.text, lastSpans);
            if (nlines)
                doc.remove(from.line, nlines);
            if (added.length)
                doc.insert(from.line, added);
        } else if (firstLine == lastLine) {
            if (text.length == 1) {
                update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
            } else {
                for (var added = [], i = 1; i < text.length - 1; ++i)
                    added.push(new Line(text[i], spansFor(i), estimateHeight));
                added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
                update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
                doc.insert(from.line + 1, added);
            }
        } else if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
            doc.remove(from.line + 1, nlines);
        } else {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
            for (var i = 1, added = []; i < text.length - 1; ++i)
                added.push(new Line(text[i], spansFor(i), estimateHeight));
            if (nlines > 1)
                doc.remove(from.line + 1, nlines - 1);
            doc.insert(from.line + 1, added);
        }
        signalLater(doc, 'change', doc, change);
    }
    function LeafChunk(lines) {
        this.lines = lines;
        this.parent = null;
        for (var i = 0, height = 0; i < lines.length; ++i) {
            lines[i].parent = this;
            height += lines[i].height;
        }
        this.height = height;
    }
    LeafChunk.prototype = {
        chunkSize: function () {
            return this.lines.length;
        },
        removeInner: function (at, n) {
            for (var i = at, e = at + n; i < e; ++i) {
                var line = this.lines[i];
                this.height -= line.height;
                cleanUpLine(line);
                signalLater(line, 'delete');
            }
            this.lines.splice(at, n);
        },
        collapse: function (lines) {
            lines.push.apply(lines, this.lines);
        },
        insertInner: function (at, lines, height) {
            this.height += height;
            this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
            for (var i = 0; i < lines.length; ++i)
                lines[i].parent = this;
        },
        iterN: function (at, n, op) {
            for (var e = at + n; at < e; ++at)
                if (op(this.lines[at]))
                    return true;
        }
    };
    function BranchChunk(children) {
        this.children = children;
        var size = 0, height = 0;
        for (var i = 0; i < children.length; ++i) {
            var ch = children[i];
            size += ch.chunkSize();
            height += ch.height;
            ch.parent = this;
        }
        this.size = size;
        this.height = height;
        this.parent = null;
    }
    BranchChunk.prototype = {
        chunkSize: function () {
            return this.size;
        },
        removeInner: function (at, n) {
            this.size -= n;
            for (var i = 0; i < this.children.length; ++i) {
                var child = this.children[i], sz = child.chunkSize();
                if (at < sz) {
                    var rm = Math.min(n, sz - at), oldHeight = child.height;
                    child.removeInner(at, rm);
                    this.height -= oldHeight - child.height;
                    if (sz == rm) {
                        this.children.splice(i--, 1);
                        child.parent = null;
                    }
                    if ((n -= rm) == 0)
                        break;
                    at = 0;
                } else
                    at -= sz;
            }
            if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
                var lines = [];
                this.collapse(lines);
                this.children = [new LeafChunk(lines)];
                this.children[0].parent = this;
            }
        },
        collapse: function (lines) {
            for (var i = 0; i < this.children.length; ++i)
                this.children[i].collapse(lines);
        },
        insertInner: function (at, lines, height) {
            this.size += lines.length;
            this.height += height;
            for (var i = 0; i < this.children.length; ++i) {
                var child = this.children[i], sz = child.chunkSize();
                if (at <= sz) {
                    child.insertInner(at, lines, height);
                    if (child.lines && child.lines.length > 50) {
                        while (child.lines.length > 50) {
                            var spilled = child.lines.splice(child.lines.length - 25, 25);
                            var newleaf = new LeafChunk(spilled);
                            child.height -= newleaf.height;
                            this.children.splice(i + 1, 0, newleaf);
                            newleaf.parent = this;
                        }
                        this.maybeSpill();
                    }
                    break;
                }
                at -= sz;
            }
        },
        maybeSpill: function () {
            if (this.children.length <= 10)
                return;
            var me = this;
            do {
                var spilled = me.children.splice(me.children.length - 5, 5);
                var sibling = new BranchChunk(spilled);
                if (!me.parent) {
                    var copy = new BranchChunk(me.children);
                    copy.parent = me;
                    me.children = [
                        copy,
                        sibling
                    ];
                    me = copy;
                } else {
                    me.size -= sibling.size;
                    me.height -= sibling.height;
                    var myIndex = indexOf(me.parent.children, me);
                    me.parent.children.splice(myIndex + 1, 0, sibling);
                }
                sibling.parent = me.parent;
            } while (me.children.length > 10);
            me.parent.maybeSpill();
        },
        iterN: function (at, n, op) {
            for (var i = 0; i < this.children.length; ++i) {
                var child = this.children[i], sz = child.chunkSize();
                if (at < sz) {
                    var used = Math.min(n, sz - at);
                    if (child.iterN(at, used, op))
                        return true;
                    if ((n -= used) == 0)
                        break;
                    at = 0;
                } else
                    at -= sz;
            }
        }
    };
    var nextDocId = 0;
    var Doc = CodeMirror.Doc = function (text, mode, firstLine) {
        if (!(this instanceof Doc))
            return new Doc(text, mode, firstLine);
        if (firstLine == null)
            firstLine = 0;
        BranchChunk.call(this, [new LeafChunk([new Line('', null)])]);
        this.first = firstLine;
        this.scrollTop = this.scrollLeft = 0;
        this.cantEdit = false;
        this.cleanGeneration = 1;
        this.frontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = simpleSelection(start);
        this.history = new History(null);
        this.id = ++nextDocId;
        this.modeOption = mode;
        if (typeof text == 'string')
            text = splitLines(text);
        updateDoc(this, {
            from: start,
            to: start,
            text: text
        });
        setSelection(this, simpleSelection(start), sel_dontScroll);
    };
    Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        iter: function (from, to, op) {
            if (op)
                this.iterN(from - this.first, to - from, op);
            else
                this.iterN(this.first, this.first + this.size, from);
        },
        insert: function (at, lines) {
            var height = 0;
            for (var i = 0; i < lines.length; ++i)
                height += lines[i].height;
            this.insertInner(at - this.first, lines, height);
        },
        remove: function (at, n) {
            this.removeInner(at - this.first, n);
        },
        getValue: function (lineSep) {
            var lines = getLines(this, this.first, this.first + this.size);
            if (lineSep === false)
                return lines;
            return lines.join(lineSep || '\n');
        },
        setValue: docMethodOp(function (code) {
            var top = Pos(this.first, 0), last = this.first + this.size - 1;
            makeChange(this, {
                from: top,
                to: Pos(last, getLine(this, last).text.length),
                text: splitLines(code),
                origin: 'setValue'
            }, true);
            setSelection(this, simpleSelection(top));
        }),
        replaceRange: function (code, from, to, origin) {
            from = clipPos(this, from);
            to = to ? clipPos(this, to) : from;
            replaceRange(this, code, from, to, origin);
        },
        getRange: function (from, to, lineSep) {
            var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
            if (lineSep === false)
                return lines;
            return lines.join(lineSep || '\n');
        },
        getLine: function (line) {
            var l = this.getLineHandle(line);
            return l && l.text;
        },
        getLineHandle: function (line) {
            if (isLine(this, line))
                return getLine(this, line);
        },
        getLineNumber: function (line) {
            return lineNo(line);
        },
        getLineHandleVisualStart: function (line) {
            if (typeof line == 'number')
                line = getLine(this, line);
            return visualLine(line);
        },
        lineCount: function () {
            return this.size;
        },
        firstLine: function () {
            return this.first;
        },
        lastLine: function () {
            return this.first + this.size - 1;
        },
        clipPos: function (pos) {
            return clipPos(this, pos);
        },
        getCursor: function (start) {
            var range = this.sel.primary(), pos;
            if (start == null || start == 'head')
                pos = range.head;
            else if (start == 'anchor')
                pos = range.anchor;
            else if (start == 'end' || start == 'to' || start === false)
                pos = range.to();
            else
                pos = range.from();
            return pos;
        },
        listSelections: function () {
            return this.sel.ranges;
        },
        somethingSelected: function () {
            return this.sel.somethingSelected();
        },
        setCursor: docMethodOp(function (line, ch, options) {
            setSimpleSelection(this, clipPos(this, typeof line == 'number' ? Pos(line, ch || 0) : line), null, options);
        }),
        setSelection: docMethodOp(function (anchor, head, options) {
            setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
        }),
        extendSelection: docMethodOp(function (head, other, options) {
            extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
        }),
        extendSelections: docMethodOp(function (heads, options) {
            extendSelections(this, clipPosArray(this, heads, options));
        }),
        extendSelectionsBy: docMethodOp(function (f, options) {
            extendSelections(this, map(this.sel.ranges, f), options);
        }),
        setSelections: docMethodOp(function (ranges, primary, options) {
            if (!ranges.length)
                return;
            for (var i = 0, out = []; i < ranges.length; i++)
                out[i] = new Range(clipPos(this, ranges[i].anchor), clipPos(this, ranges[i].head));
            if (primary == null)
                primary = Math.min(ranges.length - 1, this.sel.primIndex);
            setSelection(this, normalizeSelection(out, primary), options);
        }),
        addSelection: docMethodOp(function (anchor, head, options) {
            var ranges = this.sel.ranges.slice(0);
            ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
            setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
        }),
        getSelection: function (lineSep) {
            var ranges = this.sel.ranges, lines;
            for (var i = 0; i < ranges.length; i++) {
                var sel = getBetween(this, ranges[i].from(), ranges[i].to());
                lines = lines ? lines.concat(sel) : sel;
            }
            if (lineSep === false)
                return lines;
            else
                return lines.join(lineSep || '\n');
        },
        getSelections: function (lineSep) {
            var parts = [], ranges = this.sel.ranges;
            for (var i = 0; i < ranges.length; i++) {
                var sel = getBetween(this, ranges[i].from(), ranges[i].to());
                if (lineSep !== false)
                    sel = sel.join(lineSep || '\n');
                parts[i] = sel;
            }
            return parts;
        },
        replaceSelection: function (code, collapse, origin) {
            var dup = [];
            for (var i = 0; i < this.sel.ranges.length; i++)
                dup[i] = code;
            this.replaceSelections(dup, collapse, origin || '+input');
        },
        replaceSelections: docMethodOp(function (code, collapse, origin) {
            var changes = [], sel = this.sel;
            for (var i = 0; i < sel.ranges.length; i++) {
                var range = sel.ranges[i];
                changes[i] = {
                    from: range.from(),
                    to: range.to(),
                    text: splitLines(code[i]),
                    origin: origin
                };
            }
            var newSel = collapse && collapse != 'end' && computeReplacedSel(this, changes, collapse);
            for (var i = changes.length - 1; i >= 0; i--)
                makeChange(this, changes[i]);
            if (newSel)
                setSelectionReplaceHistory(this, newSel);
            else if (this.cm)
                ensureCursorVisible(this.cm);
        }),
        undo: docMethodOp(function () {
            makeChangeFromHistory(this, 'undo');
        }),
        redo: docMethodOp(function () {
            makeChangeFromHistory(this, 'redo');
        }),
        undoSelection: docMethodOp(function () {
            makeChangeFromHistory(this, 'undo', true);
        }),
        redoSelection: docMethodOp(function () {
            makeChangeFromHistory(this, 'redo', true);
        }),
        setExtending: function (val) {
            this.extend = val;
        },
        getExtending: function () {
            return this.extend;
        },
        historySize: function () {
            var hist = this.history, done = 0, undone = 0;
            for (var i = 0; i < hist.done.length; i++)
                if (!hist.done[i].ranges)
                    ++done;
            for (var i = 0; i < hist.undone.length; i++)
                if (!hist.undone[i].ranges)
                    ++undone;
            return {
                undo: done,
                redo: undone
            };
        },
        clearHistory: function () {
            this.history = new History(this.history.maxGeneration);
        },
        markClean: function () {
            this.cleanGeneration = this.changeGeneration(true);
        },
        changeGeneration: function (forceSplit) {
            if (forceSplit)
                this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
            return this.history.generation;
        },
        isClean: function (gen) {
            return this.history.generation == (gen || this.cleanGeneration);
        },
        getHistory: function () {
            return {
                done: copyHistoryArray(this.history.done),
                undone: copyHistoryArray(this.history.undone)
            };
        },
        setHistory: function (histData) {
            var hist = this.history = new History(this.history.maxGeneration);
            hist.done = copyHistoryArray(histData.done.slice(0), null, true);
            hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
        },
        addLineClass: docMethodOp(function (handle, where, cls) {
            return changeLine(this, handle, 'class', function (line) {
                var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
                if (!line[prop])
                    line[prop] = cls;
                else if (new RegExp('(?:^|\\s)' + cls + '(?:$|\\s)').test(line[prop]))
                    return false;
                else
                    line[prop] += ' ' + cls;
                return true;
            });
        }),
        removeLineClass: docMethodOp(function (handle, where, cls) {
            return changeLine(this, handle, 'class', function (line) {
                var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
                var cur = line[prop];
                if (!cur)
                    return false;
                else if (cls == null)
                    line[prop] = null;
                else {
                    var found = cur.match(new RegExp('(?:^|\\s+)' + cls + '(?:$|\\s+)'));
                    if (!found)
                        return false;
                    var end = found.index + found[0].length;
                    line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? '' : ' ') + cur.slice(end) || null;
                }
                return true;
            });
        }),
        markText: function (from, to, options) {
            return markText(this, clipPos(this, from), clipPos(this, to), options, 'range');
        },
        setBookmark: function (pos, options) {
            var realOpts = {
                replacedWith: options && (options.nodeType == null ? options.widget : options),
                insertLeft: options && options.insertLeft,
                clearWhenEmpty: false,
                shared: options && options.shared
            };
            pos = clipPos(this, pos);
            return markText(this, pos, pos, realOpts, 'bookmark');
        },
        findMarksAt: function (pos) {
            pos = clipPos(this, pos);
            var markers = [], spans = getLine(this, pos.line).markedSpans;
            if (spans)
                for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))
                        markers.push(span.marker.parent || span.marker);
                }
            return markers;
        },
        findMarks: function (from, to, filter) {
            from = clipPos(this, from);
            to = clipPos(this, to);
            var found = [], lineNo = from.line;
            this.iter(from.line, to.line + 1, function (line) {
                var spans = line.markedSpans;
                if (spans)
                    for (var i = 0; i < spans.length; i++) {
                        var span = spans[i];
                        if (!(lineNo == from.line && from.ch > span.to || span.from == null && lineNo != from.line || lineNo == to.line && span.from > to.ch) && (!filter || filter(span.marker)))
                            found.push(span.marker.parent || span.marker);
                    }
                ++lineNo;
            });
            return found;
        },
        getAllMarks: function () {
            var markers = [];
            this.iter(function (line) {
                var sps = line.markedSpans;
                if (sps)
                    for (var i = 0; i < sps.length; ++i)
                        if (sps[i].from != null)
                            markers.push(sps[i].marker);
            });
            return markers;
        },
        posFromIndex: function (off) {
            var ch, lineNo = this.first;
            this.iter(function (line) {
                var sz = line.text.length + 1;
                if (sz > off) {
                    ch = off;
                    return true;
                }
                off -= sz;
                ++lineNo;
            });
            return clipPos(this, Pos(lineNo, ch));
        },
        indexFromPos: function (coords) {
            coords = clipPos(this, coords);
            var index = coords.ch;
            if (coords.line < this.first || coords.ch < 0)
                return 0;
            this.iter(this.first, coords.line, function (line) {
                index += line.text.length + 1;
            });
            return index;
        },
        copy: function (copyHistory) {
            var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
            doc.scrollTop = this.scrollTop;
            doc.scrollLeft = this.scrollLeft;
            doc.sel = this.sel;
            doc.extend = false;
            if (copyHistory) {
                doc.history.undoDepth = this.history.undoDepth;
                doc.setHistory(this.getHistory());
            }
            return doc;
        },
        linkedDoc: function (options) {
            if (!options)
                options = {};
            var from = this.first, to = this.first + this.size;
            if (options.from != null && options.from > from)
                from = options.from;
            if (options.to != null && options.to < to)
                to = options.to;
            var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
            if (options.sharedHist)
                copy.history = this.history;
            (this.linked || (this.linked = [])).push({
                doc: copy,
                sharedHist: options.sharedHist
            });
            copy.linked = [{
                    doc: this,
                    isParent: true,
                    sharedHist: options.sharedHist
                }];
            copySharedMarkers(copy, findSharedMarkers(this));
            return copy;
        },
        unlinkDoc: function (other) {
            if (other instanceof CodeMirror)
                other = other.doc;
            if (this.linked)
                for (var i = 0; i < this.linked.length; ++i) {
                    var link = this.linked[i];
                    if (link.doc != other)
                        continue;
                    this.linked.splice(i, 1);
                    other.unlinkDoc(this);
                    detachSharedMarkers(findSharedMarkers(this));
                    break;
                }
            if (other.history == this.history) {
                var splitIds = [other.id];
                linkedDocs(other, function (doc) {
                    splitIds.push(doc.id);
                }, true);
                other.history = new History(null);
                other.history.done = copyHistoryArray(this.history.done, splitIds);
                other.history.undone = copyHistoryArray(this.history.undone, splitIds);
            }
        },
        iterLinkedDocs: function (f) {
            linkedDocs(this, f);
        },
        getMode: function () {
            return this.mode;
        },
        getEditor: function () {
            return this.cm;
        }
    });
    Doc.prototype.eachLine = Doc.prototype.iter;
    var dontDelegate = 'iter insert remove copy getEditor'.split(' ');
    for (var prop in Doc.prototype)
        if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
            CodeMirror.prototype[prop] = function (method) {
                return function () {
                    return method.apply(this.doc, arguments);
                };
            }(Doc.prototype[prop]);
    eventMixin(Doc);
    function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc, skip, sharedHist) {
            if (doc.linked)
                for (var i = 0; i < doc.linked.length; ++i) {
                    var rel = doc.linked[i];
                    if (rel.doc == skip)
                        continue;
                    var shared = sharedHist && rel.sharedHist;
                    if (sharedHistOnly && !shared)
                        continue;
                    f(rel.doc, shared);
                    propagate(rel.doc, doc, shared);
                }
        }
        propagate(doc, null, true);
    }
    function attachDoc(cm, doc) {
        if (doc.cm)
            throw new Error('This document is already in use.');
        cm.doc = doc;
        doc.cm = cm;
        estimateLineHeights(cm);
        loadMode(cm);
        if (!cm.options.lineWrapping)
            findMaxLine(cm);
        cm.options.mode = doc.modeOption;
        regChange(cm);
    }
    function getLine(doc, n) {
        n -= doc.first;
        if (n < 0 || n >= doc.size)
            throw new Error('There is no line ' + (n + doc.first) + ' in the document.');
        for (var chunk = doc; !chunk.lines;) {
            for (var i = 0;; ++i) {
                var child = chunk.children[i], sz = child.chunkSize();
                if (n < sz) {
                    chunk = child;
                    break;
                }
                n -= sz;
            }
        }
        return chunk.lines[n];
    }
    function getBetween(doc, start, end) {
        var out = [], n = start.line;
        doc.iter(start.line, end.line + 1, function (line) {
            var text = line.text;
            if (n == end.line)
                text = text.slice(0, end.ch);
            if (n == start.line)
                text = text.slice(start.ch);
            out.push(text);
            ++n;
        });
        return out;
    }
    function getLines(doc, from, to) {
        var out = [];
        doc.iter(from, to, function (line) {
            out.push(line.text);
        });
        return out;
    }
    function updateLineHeight(line, height) {
        var diff = height - line.height;
        if (diff)
            for (var n = line; n; n = n.parent)
                n.height += diff;
    }
    function lineNo(line) {
        if (line.parent == null)
            return null;
        var cur = line.parent, no = indexOf(cur.lines, line);
        for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
            for (var i = 0;; ++i) {
                if (chunk.children[i] == cur)
                    break;
                no += chunk.children[i].chunkSize();
            }
        }
        return no + cur.first;
    }
    function lineAtHeight(chunk, h) {
        var n = chunk.first;
        outer:
            do {
                for (var i = 0; i < chunk.children.length; ++i) {
                    var child = chunk.children[i], ch = child.height;
                    if (h < ch) {
                        chunk = child;
                        continue outer;
                    }
                    h -= ch;
                    n += child.chunkSize();
                }
                return n;
            } while (!chunk.lines);
        for (var i = 0; i < chunk.lines.length; ++i) {
            var line = chunk.lines[i], lh = line.height;
            if (h < lh)
                break;
            h -= lh;
        }
        return n + i;
    }
    function heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);
        var h = 0, chunk = lineObj.parent;
        for (var i = 0; i < chunk.lines.length; ++i) {
            var line = chunk.lines[i];
            if (line == lineObj)
                break;
            else
                h += line.height;
        }
        for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
            for (var i = 0; i < p.children.length; ++i) {
                var cur = p.children[i];
                if (cur == chunk)
                    break;
                else
                    h += cur.height;
            }
        }
        return h;
    }
    function getOrder(line) {
        var order = line.order;
        if (order == null)
            order = line.order = bidiOrdering(line.text);
        return order;
    }
    function History(startGen) {
        this.done = [];
        this.undone = [];
        this.undoDepth = Infinity;
        this.lastModTime = this.lastSelTime = 0;
        this.lastOp = this.lastSelOp = null;
        this.lastOrigin = this.lastSelOrigin = null;
        this.generation = this.maxGeneration = startGen || 1;
    }
    function historyChangeFromChange(doc, change) {
        var histChange = {
            from: copyPos(change.from),
            to: changeEnd(change),
            text: getBetween(doc, change.from, change.to)
        };
        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        linkedDocs(doc, function (doc) {
            attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        }, true);
        return histChange;
    }
    function clearSelectionEvents(array) {
        while (array.length) {
            var last = lst(array);
            if (last.ranges)
                array.pop();
            else
                break;
        }
    }
    function lastChangeEvent(hist, force) {
        if (force) {
            clearSelectionEvents(hist.done);
            return lst(hist.done);
        } else if (hist.done.length && !lst(hist.done).ranges) {
            return lst(hist.done);
        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
            hist.done.pop();
            return lst(hist.done);
        }
    }
    function addChangeToHistory(doc, change, selAfter, opId) {
        var hist = doc.history;
        hist.undone.length = 0;
        var time = +new Date(), cur;
        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == '*')) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
            var last = lst(cur.changes);
            if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
                last.to = changeEnd(change);
            } else {
                cur.changes.push(historyChangeFromChange(doc, change));
            }
        } else {
            var before = lst(hist.done);
            if (!before || !before.ranges)
                pushSelectionToHistory(doc.sel, hist.done);
            cur = {
                changes: [historyChangeFromChange(doc, change)],
                generation: hist.generation
            };
            hist.done.push(cur);
            while (hist.done.length > hist.undoDepth) {
                hist.done.shift();
                if (!hist.done[0].ranges)
                    hist.done.shift();
            }
        }
        hist.done.push(selAfter);
        hist.generation = ++hist.maxGeneration;
        hist.lastModTime = hist.lastSelTime = time;
        hist.lastOp = hist.lastSelOp = opId;
        hist.lastOrigin = hist.lastSelOrigin = change.origin;
        if (!last)
            signal(doc, 'historyAdded');
    }
    function selectionEventCanBeMerged(doc, origin, prev, sel) {
        var ch = origin.charAt(0);
        return ch == '*' || ch == '+' && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
    }
    function addSelectionToHistory(doc, sel, opId, options) {
        var hist = doc.history, origin = options && options.origin;
        if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel)))
            hist.done[hist.done.length - 1] = sel;
        else
            pushSelectionToHistory(sel, hist.done);
        hist.lastSelTime = +new Date();
        hist.lastSelOrigin = origin;
        hist.lastSelOp = opId;
        if (options && options.clearRedo !== false)
            clearSelectionEvents(hist.undone);
    }
    function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);
        if (!(top && top.ranges && top.equals(sel)))
            dest.push(sel);
    }
    function attachLocalSpans(doc, change, from, to) {
        var existing = change['spans_' + doc.id], n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
            if (line.markedSpans)
                (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;
            ++n;
        });
    }
    function removeClearedSpans(spans) {
        if (!spans)
            return null;
        for (var i = 0, out; i < spans.length; ++i) {
            if (spans[i].marker.explicitlyCleared) {
                if (!out)
                    out = spans.slice(0, i);
            } else if (out)
                out.push(spans[i]);
        }
        return !out ? spans : out.length ? out : null;
    }
    function getOldSpans(doc, change) {
        var found = change['spans_' + doc.id];
        if (!found)
            return null;
        for (var i = 0, nw = []; i < change.text.length; ++i)
            nw.push(removeClearedSpans(found[i]));
        return nw;
    }
    function copyHistoryArray(events, newGroup, instantiateSel) {
        for (var i = 0, copy = []; i < events.length; ++i) {
            var event = events[i];
            if (event.ranges) {
                copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
                continue;
            }
            var changes = event.changes, newChanges = [];
            copy.push({ changes: newChanges });
            for (var j = 0; j < changes.length; ++j) {
                var change = changes[j], m;
                newChanges.push({
                    from: change.from,
                    to: change.to,
                    text: change.text
                });
                if (newGroup)
                    for (var prop in change)
                        if (m = prop.match(/^spans_(\d+)$/)) {
                            if (indexOf(newGroup, Number(m[1])) > -1) {
                                lst(newChanges)[prop] = change[prop];
                                delete change[prop];
                            }
                        }
            }
        }
        return copy;
    }
    function rebaseHistSelSingle(pos, from, to, diff) {
        if (to < pos.line) {
            pos.line += diff;
        } else if (from < pos.line) {
            pos.line = from;
            pos.ch = 0;
        }
    }
    function rebaseHistArray(array, from, to, diff) {
        for (var i = 0; i < array.length; ++i) {
            var sub = array[i], ok = true;
            if (sub.ranges) {
                if (!sub.copied) {
                    sub = array[i] = sub.deepCopy();
                    sub.copied = true;
                }
                for (var j = 0; j < sub.ranges.length; j++) {
                    rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
                    rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
                }
                continue;
            }
            for (var j = 0; j < sub.changes.length; ++j) {
                var cur = sub.changes[j];
                if (to < cur.from.line) {
                    cur.from = Pos(cur.from.line + diff, cur.from.ch);
                    cur.to = Pos(cur.to.line + diff, cur.to.ch);
                } else if (from <= cur.to.line) {
                    ok = false;
                    break;
                }
            }
            if (!ok) {
                array.splice(0, i + 1);
                i = 0;
            }
        }
    }
    function rebaseHist(hist, change) {
        var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff);
        rebaseHistArray(hist.undone, from, to, diff);
    }
    var e_preventDefault = CodeMirror.e_preventDefault = function (e) {
        if (e.preventDefault)
            e.preventDefault();
        else
            e.returnValue = false;
    };
    var e_stopPropagation = CodeMirror.e_stopPropagation = function (e) {
        if (e.stopPropagation)
            e.stopPropagation();
        else
            e.cancelBubble = true;
    };
    function e_defaultPrevented(e) {
        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
    }
    var e_stop = CodeMirror.e_stop = function (e) {
        e_preventDefault(e);
        e_stopPropagation(e);
    };
    function e_target(e) {
        return e.target || e.srcElement;
    }
    function e_button(e) {
        var b = e.which;
        if (b == null) {
            if (e.button & 1)
                b = 1;
            else if (e.button & 2)
                b = 3;
            else if (e.button & 4)
                b = 2;
        }
        if (mac && e.ctrlKey && b == 1)
            b = 3;
        return b;
    }
    var on = CodeMirror.on = function (emitter, type, f) {
        if (emitter.addEventListener)
            emitter.addEventListener(type, f, false);
        else if (emitter.attachEvent)
            emitter.attachEvent('on' + type, f);
        else {
            var map = emitter._handlers || (emitter._handlers = {});
            var arr = map[type] || (map[type] = []);
            arr.push(f);
        }
    };
    var off = CodeMirror.off = function (emitter, type, f) {
        if (emitter.removeEventListener)
            emitter.removeEventListener(type, f, false);
        else if (emitter.detachEvent)
            emitter.detachEvent('on' + type, f);
        else {
            var arr = emitter._handlers && emitter._handlers[type];
            if (!arr)
                return;
            for (var i = 0; i < arr.length; ++i)
                if (arr[i] == f) {
                    arr.splice(i, 1);
                    break;
                }
        }
    };
    var signal = CodeMirror.signal = function (emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        if (!arr)
            return;
        var args = Array.prototype.slice.call(arguments, 2);
        for (var i = 0; i < arr.length; ++i)
            arr[i].apply(null, args);
    };
    var orphanDelayedCallbacks = null;
    function signalLater(emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        if (!arr)
            return;
        var args = Array.prototype.slice.call(arguments, 2), list;
        if (operationGroup) {
            list = operationGroup.delayedCallbacks;
        } else if (orphanDelayedCallbacks) {
            list = orphanDelayedCallbacks;
        } else {
            list = orphanDelayedCallbacks = [];
            setTimeout(fireOrphanDelayed, 0);
        }
        function bnd(f) {
            return function () {
                f.apply(null, args);
            };
        }
        ;
        for (var i = 0; i < arr.length; ++i)
            list.push(bnd(arr[i]));
    }
    function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;
        for (var i = 0; i < delayed.length; ++i)
            delayed[i]();
    }
    function signalDOMEvent(cm, e, override) {
        signal(cm, override || e.type, cm, e);
        return e_defaultPrevented(e) || e.codemirrorIgnore;
    }
    function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;
        if (!arr)
            return;
        var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
        for (var i = 0; i < arr.length; ++i)
            if (indexOf(set, arr[i]) == -1)
                set.push(arr[i]);
    }
    function hasHandler(emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        return arr && arr.length > 0;
    }
    function eventMixin(ctor) {
        ctor.prototype.on = function (type, f) {
            on(this, type, f);
        };
        ctor.prototype.off = function (type, f) {
            off(this, type, f);
        };
    }
    var scrollerCutOff = 30;
    var Pass = CodeMirror.Pass = {
        toString: function () {
            return 'CodeMirror.Pass';
        }
    };
    var sel_dontScroll = { scroll: false }, sel_mouse = { origin: '*mouse' }, sel_move = { origin: '+move' };
    function Delayed() {
        this.id = null;
    }
    Delayed.prototype.set = function (ms, f) {
        clearTimeout(this.id);
        this.id = setTimeout(f, ms);
    };
    var countColumn = CodeMirror.countColumn = function (string, end, tabSize, startIndex, startValue) {
        if (end == null) {
            end = string.search(/[^\s\u00a0]/);
            if (end == -1)
                end = string.length;
        }
        for (var i = startIndex || 0, n = startValue || 0;;) {
            var nextTab = string.indexOf('\t', i);
            if (nextTab < 0 || nextTab >= end)
                return n + (end - i);
            n += nextTab - i;
            n += tabSize - n % tabSize;
            i = nextTab + 1;
        }
    };
    function findColumn(string, goal, tabSize) {
        for (var pos = 0, col = 0;;) {
            var nextTab = string.indexOf('\t', pos);
            if (nextTab == -1)
                nextTab = string.length;
            var skipped = nextTab - pos;
            if (nextTab == string.length || col + skipped >= goal)
                return pos + Math.min(skipped, goal - col);
            col += nextTab - pos;
            col += tabSize - col % tabSize;
            pos = nextTab + 1;
            if (col >= goal)
                return pos;
        }
    }
    var spaceStrs = [''];
    function spaceStr(n) {
        while (spaceStrs.length <= n)
            spaceStrs.push(lst(spaceStrs) + ' ');
        return spaceStrs[n];
    }
    function lst(arr) {
        return arr[arr.length - 1];
    }
    var selectInput = function (node) {
        node.select();
    };
    if (ios)
        selectInput = function (node) {
            node.selectionStart = 0;
            node.selectionEnd = node.value.length;
        };
    else if (ie)
        selectInput = function (node) {
            try {
                node.select();
            } catch (_e) {
            }
        };
    function indexOf(array, elt) {
        for (var i = 0; i < array.length; ++i)
            if (array[i] == elt)
                return i;
        return -1;
    }
    if ([].indexOf)
        indexOf = function (array, elt) {
            return array.indexOf(elt);
        };
    function map(array, f) {
        var out = [];
        for (var i = 0; i < array.length; i++)
            out[i] = f(array[i], i);
        return out;
    }
    if ([].map)
        map = function (array, f) {
            return array.map(f);
        };
    function createObj(base, props) {
        var inst;
        if (Object.create) {
            inst = Object.create(base);
        } else {
            var ctor = function () {
            };
            ctor.prototype = base;
            inst = new ctor();
        }
        if (props)
            copyObj(props, inst);
        return inst;
    }
    ;
    function copyObj(obj, target, overwrite) {
        if (!target)
            target = {};
        for (var prop in obj)
            if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
                target[prop] = obj[prop];
        return target;
    }
    function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return f.apply(null, args);
        };
    }
    var nonASCIISingleCaseWordChar = /[\u00df\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    var isWordCharBasic = CodeMirror.isWordChar = function (ch) {
        return /\w/.test(ch) || ch > '\x80' && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
    };
    function isWordChar(ch, helper) {
        if (!helper)
            return isWordCharBasic(ch);
        if (helper.source.indexOf('\\w') > -1 && isWordCharBasic(ch))
            return true;
        return helper.test(ch);
    }
    function isEmpty(obj) {
        for (var n in obj)
            if (obj.hasOwnProperty(n) && obj[n])
                return false;
        return true;
    }
    var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
    function isExtendingChar(ch) {
        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
    }
    function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className)
            e.className = className;
        if (style)
            e.style.cssText = style;
        if (typeof content == 'string')
            e.appendChild(document.createTextNode(content));
        else if (content)
            for (var i = 0; i < content.length; ++i)
                e.appendChild(content[i]);
        return e;
    }
    var range;
    if (document.createRange)
        range = function (node, start, end) {
            var r = document.createRange();
            r.setEnd(node, end);
            r.setStart(node, start);
            return r;
        };
    else
        range = function (node, start, end) {
            var r = document.body.createTextRange();
            r.moveToElementText(node.parentNode);
            r.collapse(true);
            r.moveEnd('character', end);
            r.moveStart('character', start);
            return r;
        };
    function removeChildren(e) {
        for (var count = e.childNodes.length; count > 0; --count)
            e.removeChild(e.firstChild);
        return e;
    }
    function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e);
    }
    function contains(parent, child) {
        if (parent.contains)
            return parent.contains(child);
        while (child = child.parentNode)
            if (child == parent)
                return true;
    }
    function activeElt() {
        return document.activeElement;
    }
    if (ie && ie_version < 11)
        activeElt = function () {
            try {
                return document.activeElement;
            } catch (e) {
                return document.body;
            }
        };
    function classTest(cls) {
        return new RegExp('\\b' + cls + '\\b\\s*');
    }
    function rmClass(node, cls) {
        var test = classTest(cls);
        if (test.test(node.className))
            node.className = node.className.replace(test, '');
    }
    function addClass(node, cls) {
        if (!classTest(cls).test(node.className))
            node.className += ' ' + cls;
    }
    function joinClasses(a, b) {
        var as = a.split(' ');
        for (var i = 0; i < as.length; i++)
            if (as[i] && !classTest(as[i]).test(b))
                b += ' ' + as[i];
        return b;
    }
    function forEachCodeMirror(f) {
        if (!document.body.getElementsByClassName)
            return;
        var byClass = document.body.getElementsByClassName('CodeMirror');
        for (var i = 0; i < byClass.length; i++) {
            var cm = byClass[i].CodeMirror;
            if (cm)
                f(cm);
        }
    }
    var globalsRegistered = false;
    function ensureGlobalHandlers() {
        if (globalsRegistered)
            return;
        registerGlobalHandlers();
        globalsRegistered = true;
    }
    function registerGlobalHandlers() {
        var resizeTimer;
        on(window, 'resize', function () {
            if (resizeTimer == null)
                resizeTimer = setTimeout(function () {
                    resizeTimer = null;
                    knownScrollbarWidth = null;
                    forEachCodeMirror(onResize);
                }, 100);
        });
        on(window, 'blur', function () {
            forEachCodeMirror(onBlur);
        });
    }
    var dragAndDrop = function () {
        if (ie && ie_version < 9)
            return false;
        var div = elt('div');
        return 'draggable' in div || 'dragDrop' in div;
    }();
    var knownScrollbarWidth;
    function scrollbarWidth(measure) {
        if (knownScrollbarWidth != null)
            return knownScrollbarWidth;
        var test = elt('div', null, null, 'width: 50px; height: 50px; overflow-x: scroll');
        removeChildrenAndAdd(measure, test);
        if (test.offsetWidth)
            knownScrollbarWidth = test.offsetHeight - test.clientHeight;
        return knownScrollbarWidth || 0;
    }
    var zwspSupported;
    function zeroWidthElement(measure) {
        if (zwspSupported == null) {
            var test = elt('span', '\u200B');
            removeChildrenAndAdd(measure, elt('span', [
                test,
                document.createTextNode('x')
            ]));
            if (measure.firstChild.offsetHeight != 0)
                zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
        }
        if (zwspSupported)
            return elt('span', '\u200B');
        else
            return elt('span', '\xA0', null, 'display: inline-block; width: 1px; margin-right: -1px');
    }
    var badBidiRects;
    function hasBadBidiRects(measure) {
        if (badBidiRects != null)
            return badBidiRects;
        var txt = removeChildrenAndAdd(measure, document.createTextNode('A\u062EA'));
        var r0 = range(txt, 0, 1).getBoundingClientRect();
        if (r0.left == r0.right)
            return false;
        var r1 = range(txt, 1, 2).getBoundingClientRect();
        return badBidiRects = r1.right - r0.right < 3;
    }
    var splitLines = CodeMirror.splitLines = '\n\nb'.split(/\n/).length != 3 ? function (string) {
        var pos = 0, result = [], l = string.length;
        while (pos <= l) {
            var nl = string.indexOf('\n', pos);
            if (nl == -1)
                nl = string.length;
            var line = string.slice(pos, string.charAt(nl - 1) == '\r' ? nl - 1 : nl);
            var rt = line.indexOf('\r');
            if (rt != -1) {
                result.push(line.slice(0, rt));
                pos += rt + 1;
            } else {
                result.push(line);
                pos = nl + 1;
            }
        }
        return result;
    } : function (string) {
        return string.split(/\r\n?|\n/);
    };
    var hasSelection = window.getSelection ? function (te) {
        try {
            return te.selectionStart != te.selectionEnd;
        } catch (e) {
            return false;
        }
    } : function (te) {
        try {
            var range = te.ownerDocument.selection.createRange();
        } catch (e) {
        }
        if (!range || range.parentElement() != te)
            return false;
        return range.compareEndPoints('StartToEnd', range) != 0;
    };
    var hasCopyEvent = function () {
        var e = elt('div');
        if ('oncopy' in e)
            return true;
        e.setAttribute('oncopy', 'return;');
        return typeof e.oncopy == 'function';
    }();
    var badZoomedRects = null;
    function hasBadZoomedRects(measure) {
        if (badZoomedRects != null)
            return badZoomedRects;
        var node = removeChildrenAndAdd(measure, elt('span', 'x'));
        var normal = node.getBoundingClientRect();
        var fromRange = range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
    }
    var keyNames = {
        3: 'Enter',
        8: 'Backspace',
        9: 'Tab',
        13: 'Enter',
        16: 'Shift',
        17: 'Ctrl',
        18: 'Alt',
        19: 'Pause',
        20: 'CapsLock',
        27: 'Esc',
        32: 'Space',
        33: 'PageUp',
        34: 'PageDown',
        35: 'End',
        36: 'Home',
        37: 'Left',
        38: 'Up',
        39: 'Right',
        40: 'Down',
        44: 'PrintScrn',
        45: 'Insert',
        46: 'Delete',
        59: ';',
        61: '=',
        91: 'Mod',
        92: 'Mod',
        93: 'Mod',
        107: '=',
        109: '-',
        127: 'Delete',
        173: '-',
        186: ';',
        187: '=',
        188: ',',
        189: '-',
        190: '.',
        191: '/',
        192: '`',
        219: '[',
        220: '\\',
        221: ']',
        222: '\'',
        63232: 'Up',
        63233: 'Down',
        63234: 'Left',
        63235: 'Right',
        63272: 'Delete',
        63273: 'Home',
        63275: 'End',
        63276: 'PageUp',
        63277: 'PageDown',
        63302: 'Insert'
    };
    CodeMirror.keyNames = keyNames;
    (function () {
        for (var i = 0; i < 10; i++)
            keyNames[i + 48] = keyNames[i + 96] = String(i);
        for (var i = 65; i <= 90; i++)
            keyNames[i] = String.fromCharCode(i);
        for (var i = 1; i <= 12; i++)
            keyNames[i + 111] = keyNames[i + 63235] = 'F' + i;
    }());
    function iterateBidiSections(order, from, to, f) {
        if (!order)
            return f(from, to, 'ltr');
        var found = false;
        for (var i = 0; i < order.length; ++i) {
            var part = order[i];
            if (part.from < to && part.to > from || from == to && part.to == from) {
                f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? 'rtl' : 'ltr');
                found = true;
            }
        }
        if (!found)
            f(from, to, 'ltr');
    }
    function bidiLeft(part) {
        return part.level % 2 ? part.to : part.from;
    }
    function bidiRight(part) {
        return part.level % 2 ? part.from : part.to;
    }
    function lineLeft(line) {
        var order = getOrder(line);
        return order ? bidiLeft(order[0]) : 0;
    }
    function lineRight(line) {
        var order = getOrder(line);
        if (!order)
            return line.text.length;
        return bidiRight(lst(order));
    }
    function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLine(line);
        if (visual != line)
            lineN = lineNo(visual);
        var order = getOrder(visual);
        var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
        return Pos(lineN, ch);
    }
    function lineEnd(cm, lineN) {
        var merged, line = getLine(cm.doc, lineN);
        while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
            lineN = null;
        }
        var order = getOrder(line);
        var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
        return Pos(lineN == null ? lineNo(line) : lineN, ch);
    }
    function lineStartSmart(cm, pos) {
        var start = lineStart(cm, pos.line);
        var line = getLine(cm.doc, start.line);
        var order = getOrder(line);
        if (!order || order[0].level == 0) {
            var firstNonWS = Math.max(0, line.text.search(/\S/));
            var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
            return Pos(start.line, inWS ? 0 : firstNonWS);
        }
        return start;
    }
    function compareBidiLevel(order, a, b) {
        var linedir = order[0].level;
        if (a == linedir)
            return true;
        if (b == linedir)
            return false;
        return a < b;
    }
    var bidiOther;
    function getBidiPartAt(order, pos) {
        bidiOther = null;
        for (var i = 0, found; i < order.length; ++i) {
            var cur = order[i];
            if (cur.from < pos && cur.to > pos)
                return i;
            if (cur.from == pos || cur.to == pos) {
                if (found == null) {
                    found = i;
                } else if (compareBidiLevel(order, cur.level, order[found].level)) {
                    if (cur.from != cur.to)
                        bidiOther = found;
                    return i;
                } else {
                    if (cur.from != cur.to)
                        bidiOther = i;
                    return found;
                }
            }
        }
        return found;
    }
    function moveInLine(line, pos, dir, byUnit) {
        if (!byUnit)
            return pos + dir;
        do
            pos += dir;
        while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
        return pos;
    }
    function moveVisually(line, start, dir, byUnit) {
        var bidi = getOrder(line);
        if (!bidi)
            return moveLogically(line, start, dir, byUnit);
        var pos = getBidiPartAt(bidi, start), part = bidi[pos];
        var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);
        for (;;) {
            if (target > part.from && target < part.to)
                return target;
            if (target == part.from || target == part.to) {
                if (getBidiPartAt(bidi, target) == pos)
                    return target;
                part = bidi[pos += dir];
                return dir > 0 == part.level % 2 ? part.to : part.from;
            } else {
                part = bidi[pos += dir];
                if (!part)
                    return null;
                if (dir > 0 == part.level % 2)
                    target = moveInLine(line, part.to, -1, byUnit);
                else
                    target = moveInLine(line, part.from, 1, byUnit);
            }
        }
    }
    function moveLogically(line, start, dir, byUnit) {
        var target = start + dir;
        if (byUnit)
            while (target > 0 && isExtendingChar(line.text.charAt(target)))
                target += dir;
        return target < 0 || target > line.text.length ? null : target;
    }
    var bidiOrdering = function () {
        var lowTypes = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN';
        var arabicTypes = 'rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm';
        function charType(code) {
            if (code <= 247)
                return lowTypes.charAt(code);
            else if (1424 <= code && code <= 1524)
                return 'R';
            else if (1536 <= code && code <= 1773)
                return arabicTypes.charAt(code - 1536);
            else if (1774 <= code && code <= 2220)
                return 'r';
            else if (8192 <= code && code <= 8203)
                return 'w';
            else if (code == 8204)
                return 'b';
            else
                return 'L';
        }
        var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
        var outerType = 'L';
        function BidiSpan(level, from, to) {
            this.level = level;
            this.from = from;
            this.to = to;
        }
        return function (str) {
            if (!bidiRE.test(str))
                return false;
            var len = str.length, types = [];
            for (var i = 0, type; i < len; ++i)
                types.push(type = charType(str.charCodeAt(i)));
            for (var i = 0, prev = outerType; i < len; ++i) {
                var type = types[i];
                if (type == 'm')
                    types[i] = prev;
                else
                    prev = type;
            }
            for (var i = 0, cur = outerType; i < len; ++i) {
                var type = types[i];
                if (type == '1' && cur == 'r')
                    types[i] = 'n';
                else if (isStrong.test(type)) {
                    cur = type;
                    if (type == 'r')
                        types[i] = 'R';
                }
            }
            for (var i = 1, prev = types[0]; i < len - 1; ++i) {
                var type = types[i];
                if (type == '+' && prev == '1' && types[i + 1] == '1')
                    types[i] = '1';
                else if (type == ',' && prev == types[i + 1] && (prev == '1' || prev == 'n'))
                    types[i] = prev;
                prev = type;
            }
            for (var i = 0; i < len; ++i) {
                var type = types[i];
                if (type == ',')
                    types[i] = 'N';
                else if (type == '%') {
                    for (var end = i + 1; end < len && types[end] == '%'; ++end) {
                    }
                    var replace = i && types[i - 1] == '!' || end < len && types[end] == '1' ? '1' : 'N';
                    for (var j = i; j < end; ++j)
                        types[j] = replace;
                    i = end - 1;
                }
            }
            for (var i = 0, cur = outerType; i < len; ++i) {
                var type = types[i];
                if (cur == 'L' && type == '1')
                    types[i] = 'L';
                else if (isStrong.test(type))
                    cur = type;
            }
            for (var i = 0; i < len; ++i) {
                if (isNeutral.test(types[i])) {
                    for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {
                    }
                    var before = (i ? types[i - 1] : outerType) == 'L';
                    var after = (end < len ? types[end] : outerType) == 'L';
                    var replace = before || after ? 'L' : 'R';
                    for (var j = i; j < end; ++j)
                        types[j] = replace;
                    i = end - 1;
                }
            }
            var order = [], m;
            for (var i = 0; i < len;) {
                if (countsAsLeft.test(types[i])) {
                    var start = i;
                    for (++i; i < len && countsAsLeft.test(types[i]); ++i) {
                    }
                    order.push(new BidiSpan(0, start, i));
                } else {
                    var pos = i, at = order.length;
                    for (++i; i < len && types[i] != 'L'; ++i) {
                    }
                    for (var j = pos; j < i;) {
                        if (countsAsNum.test(types[j])) {
                            if (pos < j)
                                order.splice(at, 0, new BidiSpan(1, pos, j));
                            var nstart = j;
                            for (++j; j < i && countsAsNum.test(types[j]); ++j) {
                            }
                            order.splice(at, 0, new BidiSpan(2, nstart, j));
                            pos = j;
                        } else
                            ++j;
                    }
                    if (pos < i)
                        order.splice(at, 0, new BidiSpan(1, pos, i));
                }
            }
            if (order[0].level == 1 && (m = str.match(/^\s+/))) {
                order[0].from = m[0].length;
                order.unshift(new BidiSpan(0, 0, m[0].length));
            }
            if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
                lst(order).to -= m[0].length;
                order.push(new BidiSpan(0, len - m[0].length, len));
            }
            if (order[0].level != lst(order).level)
                order.push(new BidiSpan(order[0].level, len, len));
            return order;
        };
    }();
    CodeMirror.version = '4.5.0';
    CodeMirror.defineMode('markdown', function (cmCfg, modeCfg) {
        var htmlFound = CodeMirror.modes.hasOwnProperty('xml');
        var htmlMode = CodeMirror.getMode(cmCfg, htmlFound ? {
            name: 'xml',
            htmlMode: true
        } : 'text/plain');
        var aliases = {
            html: 'htmlmixed',
            js: 'javascript',
            json: 'application/json',
            c: 'text/x-csrc',
            'c++': 'text/x-c++src',
            java: 'text/x-java',
            csharp: 'text/x-csharp',
            'c#': 'text/x-csharp',
            scala: 'text/x-scala'
        };
        var getMode = function () {
            var i, modes = {}, mimes = {}, mime;
            var list = [];
            for (var m in CodeMirror.modes)
                if (CodeMirror.modes.propertyIsEnumerable(m))
                    list.push(m);
            for (i = 0; i < list.length; i++) {
                modes[list[i]] = list[i];
            }
            var mimesList = [];
            for (var m in CodeMirror.mimeModes)
                if (CodeMirror.mimeModes.propertyIsEnumerable(m))
                    mimesList.push({
                        mime: m,
                        mode: CodeMirror.mimeModes[m]
                    });
            for (i = 0; i < mimesList.length; i++) {
                mime = mimesList[i].mime;
                mimes[mime] = mimesList[i].mime;
            }
            for (var a in aliases) {
                if (aliases[a] in modes || aliases[a] in mimes)
                    modes[a] = aliases[a];
            }
            return function (lang) {
                return modes[lang] ? CodeMirror.getMode(cmCfg, modes[lang]) : null;
            };
        }();
        if (modeCfg.highlightFormatting === undefined)
            modeCfg.highlightFormatting = false;
        if (modeCfg.maxBlockquoteDepth === undefined)
            modeCfg.maxBlockquoteDepth = 0;
        if (modeCfg.underscoresBreakWords === undefined)
            modeCfg.underscoresBreakWords = true;
        if (modeCfg.fencedCodeBlocks === undefined)
            modeCfg.fencedCodeBlocks = false;
        if (modeCfg.taskLists === undefined)
            modeCfg.taskLists = false;
        var codeDepth = 0;
        var header = 'header', code = 'comment', quote = 'quote', list1 = 'variable-2', list2 = 'variable-3', list3 = 'keyword', hr = 'hr', image = 'tag', formatting = 'formatting', linkinline = 'link', linkemail = 'link', linktext = 'link', linkhref = 'string', em = 'em', strong = 'strong';
        var hrRE = /^([*\-=_])(?:\s*\1){2,}\s*$/, ulRE = /^[*\-+]\s+/, olRE = /^[0-9]+\.\s+/, taskListRE = /^\[(x| )\](?=\s)/, atxHeaderRE = /^#+/, setextHeaderRE = /^(?:\={1,}|-{1,})$/, textRE = /^[^#!\[\]*_\\<>` "'(]+/;
        function switchInline(stream, state, f) {
            state.f = state.inline = f;
            return f(stream, state);
        }
        function switchBlock(stream, state, f) {
            state.f = state.block = f;
            return f(stream, state);
        }
        function blankLine(state) {
            state.linkTitle = false;
            state.em = false;
            state.strong = false;
            state.quote = 0;
            if (!htmlFound && state.f == htmlBlock) {
                state.f = inlineNormal;
                state.block = blockNormal;
            }
            state.trailingSpace = 0;
            state.trailingSpaceNewLine = false;
            state.thisLineHasContent = false;
            return null;
        }
        function blockNormal(stream, state) {
            var sol = stream.sol();
            var prevLineIsList = state.list !== false;
            if (state.list !== false && state.indentationDiff >= 0) {
                if (state.indentationDiff < 4) {
                    state.indentation -= state.indentationDiff;
                }
                state.list = null;
            } else if (state.list !== false && state.indentation > 0) {
                state.list = null;
                state.listDepth = Math.floor(state.indentation / 4);
            } else if (state.list !== false) {
                state.list = false;
                state.listDepth = 0;
            }
            var match = null;
            if (state.indentationDiff >= 4) {
                state.indentation -= 4;
                stream.skipToEnd();
                return code;
            } else if (stream.eatSpace()) {
                return null;
            } else if (match = stream.match(atxHeaderRE)) {
                state.header = match[0].length <= 6 ? match[0].length : 6;
                if (modeCfg.highlightFormatting)
                    state.formatting = 'header';
                state.f = state.inline;
                return getType(state);
            } else if (state.prevLineHasContent && (match = stream.match(setextHeaderRE))) {
                state.header = match[0].charAt(0) == '=' ? 1 : 2;
                if (modeCfg.highlightFormatting)
                    state.formatting = 'header';
                state.f = state.inline;
                return getType(state);
            } else if (stream.eat('>')) {
                state.indentation++;
                state.quote = sol ? 1 : state.quote + 1;
                if (modeCfg.highlightFormatting)
                    state.formatting = 'quote';
                stream.eatSpace();
                return getType(state);
            } else if (stream.peek() === '[') {
                return switchInline(stream, state, footnoteLink);
            } else if (stream.match(hrRE, true)) {
                return hr;
            } else if ((!state.prevLineHasContent || prevLineIsList) && (stream.match(ulRE, false) || stream.match(olRE, false))) {
                var listType = null;
                if (stream.match(ulRE, true)) {
                    listType = 'ul';
                } else {
                    stream.match(olRE, true);
                    listType = 'ol';
                }
                state.indentation += 4;
                state.list = true;
                state.listDepth++;
                if (modeCfg.taskLists && stream.match(taskListRE, false)) {
                    state.taskList = true;
                }
                state.f = state.inline;
                if (modeCfg.highlightFormatting)
                    state.formatting = [
                        'list',
                        'list-' + listType
                    ];
                return getType(state);
            } else if (modeCfg.fencedCodeBlocks && stream.match(/^```([\w+#]*)/, true)) {
                state.localMode = getMode(RegExp.$1);
                if (state.localMode)
                    state.localState = state.localMode.startState();
                switchBlock(stream, state, local);
                if (modeCfg.highlightFormatting)
                    state.formatting = 'code-block';
                state.code = true;
                return getType(state);
            }
            return switchInline(stream, state, state.inline);
        }
        function htmlBlock(stream, state) {
            var style = htmlMode.token(stream, state.htmlState);
            if (htmlFound && state.htmlState.tagStart === null && !state.htmlState.context || state.md_inside && stream.current().indexOf('>') > -1) {
                state.f = inlineNormal;
                state.block = blockNormal;
                state.htmlState = null;
            }
            return style;
        }
        function local(stream, state) {
            if (stream.sol() && stream.match(/^```/, true)) {
                state.localMode = state.localState = null;
                state.f = inlineNormal;
                state.block = blockNormal;
                if (modeCfg.highlightFormatting)
                    state.formatting = 'code-block';
                state.code = true;
                var returnType = getType(state);
                state.code = false;
                return returnType;
            } else if (state.localMode) {
                return state.localMode.token(stream, state.localState);
            } else {
                stream.skipToEnd();
                return code;
            }
        }
        function getType(state) {
            var styles = [];
            if (state.formatting) {
                styles.push(formatting);
                if (typeof state.formatting === 'string')
                    state.formatting = [state.formatting];
                for (var i = 0; i < state.formatting.length; i++) {
                    styles.push(formatting + '-' + state.formatting[i]);
                    if (state.formatting[i] === 'header') {
                        styles.push(formatting + '-' + state.formatting[i] + '-' + state.header);
                    }
                    if (state.formatting[i] === 'quote') {
                        if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                            styles.push(formatting + '-' + state.formatting[i] + '-' + state.quote);
                        } else {
                            styles.push('error');
                        }
                    }
                }
            }
            if (state.taskOpen) {
                styles.push('meta');
                return styles.length ? styles.join(' ') : null;
            }
            if (state.taskClosed) {
                styles.push('property');
                return styles.length ? styles.join(' ') : null;
            }
            if (state.linkHref) {
                styles.push(linkhref);
                return styles.length ? styles.join(' ') : null;
            }
            if (state.strong) {
                styles.push(strong);
            }
            if (state.em) {
                styles.push(em);
            }
            if (state.linkText) {
                styles.push(linktext);
            }
            if (state.code) {
                styles.push(code);
            }
            if (state.header) {
                styles.push(header);
                styles.push(header + '-' + state.header);
            }
            if (state.quote) {
                styles.push(quote);
                if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
                    styles.push(quote + '-' + state.quote);
                } else {
                    styles.push(quote + '-' + modeCfg.maxBlockquoteDepth);
                }
            }
            if (state.list !== false) {
                var listMod = (state.listDepth - 1) % 3;
                if (!listMod) {
                    styles.push(list1);
                } else if (listMod === 1) {
                    styles.push(list2);
                } else {
                    styles.push(list3);
                }
            }
            if (state.trailingSpaceNewLine) {
                styles.push('trailing-space-new-line');
            } else if (state.trailingSpace) {
                styles.push('trailing-space-' + (state.trailingSpace % 2 ? 'a' : 'b'));
            }
            return styles.length ? styles.join(' ') : null;
        }
        function handleText(stream, state) {
            if (stream.match(textRE, true)) {
                return getType(state);
            }
            return undefined;
        }
        function inlineNormal(stream, state) {
            var style = state.text(stream, state);
            if (typeof style !== 'undefined')
                return style;
            if (state.list) {
                state.list = null;
                return getType(state);
            }
            if (state.taskList) {
                var taskOpen = stream.match(taskListRE, true)[1] !== 'x';
                if (taskOpen)
                    state.taskOpen = true;
                else
                    state.taskClosed = true;
                if (modeCfg.highlightFormatting)
                    state.formatting = 'task';
                state.taskList = false;
                return getType(state);
            }
            state.taskOpen = false;
            state.taskClosed = false;
            if (state.header && stream.match(/^#+$/, true)) {
                if (modeCfg.highlightFormatting)
                    state.formatting = 'header';
                return getType(state);
            }
            var sol = stream.sol();
            var ch = stream.next();
            if (state.escape) {
                state.escape = false;
                return getType(state);
            }
            if (ch === '\\') {
                if (modeCfg.highlightFormatting)
                    state.formatting = 'escape';
                state.escape = true;
                return getType(state);
            }
            if (state.linkTitle) {
                state.linkTitle = false;
                var matchCh = ch;
                if (ch === '(') {
                    matchCh = ')';
                }
                matchCh = (matchCh + '').replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
                var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;
                if (stream.match(new RegExp(regex), true)) {
                    return linkhref;
                }
            }
            if (ch === '`') {
                var previousFormatting = state.formatting;
                if (modeCfg.highlightFormatting)
                    state.formatting = 'code';
                var t = getType(state);
                var before = stream.pos;
                stream.eatWhile('`');
                var difference = 1 + stream.pos - before;
                if (!state.code) {
                    codeDepth = difference;
                    state.code = true;
                    return getType(state);
                } else {
                    if (difference === codeDepth) {
                        state.code = false;
                        return t;
                    }
                    state.formatting = previousFormatting;
                    return getType(state);
                }
            } else if (state.code) {
                return getType(state);
            }
            if (ch === '!' && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
                stream.match(/\[[^\]]*\]/);
                state.inline = state.f = linkHref;
                return image;
            }
            if (ch === '[' && stream.match(/.*\](\(| ?\[)/, false)) {
                state.linkText = true;
                if (modeCfg.highlightFormatting)
                    state.formatting = 'link';
                return getType(state);
            }
            if (ch === ']' && state.linkText) {
                if (modeCfg.highlightFormatting)
                    state.formatting = 'link';
                var type = getType(state);
                state.linkText = false;
                state.inline = state.f = linkHref;
                return type;
            }
            if (ch === '<' && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
                state.f = state.inline = linkInline;
                if (modeCfg.highlightFormatting)
                    state.formatting = 'link';
                var type = getType(state);
                if (type) {
                    type += ' ';
                } else {
                    type = '';
                }
                return type + linkinline;
            }
            if (ch === '<' && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
                state.f = state.inline = linkInline;
                if (modeCfg.highlightFormatting)
                    state.formatting = 'link';
                var type = getType(state);
                if (type) {
                    type += ' ';
                } else {
                    type = '';
                }
                return type + linkemail;
            }
            if (ch === '<' && stream.match(/^\w/, false)) {
                if (stream.string.indexOf('>') != -1) {
                    var atts = stream.string.substring(1, stream.string.indexOf('>'));
                    if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) {
                        state.md_inside = true;
                    }
                }
                stream.backUp(1);
                state.htmlState = CodeMirror.startState(htmlMode);
                return switchBlock(stream, state, htmlBlock);
            }
            if (ch === '<' && stream.match(/^\/\w*?>/)) {
                state.md_inside = false;
                return 'tag';
            }
            var ignoreUnderscore = false;
            if (!modeCfg.underscoresBreakWords) {
                if (ch === '_' && stream.peek() !== '_' && stream.match(/(\w)/, false)) {
                    var prevPos = stream.pos - 2;
                    if (prevPos >= 0) {
                        var prevCh = stream.string.charAt(prevPos);
                        if (prevCh !== '_' && prevCh.match(/(\w)/, false)) {
                            ignoreUnderscore = true;
                        }
                    }
                }
            }
            if (ch === '*' || ch === '_' && !ignoreUnderscore) {
                if (sol && stream.peek() === ' ') {
                } else if (state.strong === ch && stream.eat(ch)) {
                    if (modeCfg.highlightFormatting)
                        state.formatting = 'strong';
                    var t = getType(state);
                    state.strong = false;
                    return t;
                } else if (!state.strong && stream.eat(ch)) {
                    state.strong = ch;
                    if (modeCfg.highlightFormatting)
                        state.formatting = 'strong';
                    return getType(state);
                } else if (state.em === ch) {
                    if (modeCfg.highlightFormatting)
                        state.formatting = 'em';
                    var t = getType(state);
                    state.em = false;
                    return t;
                } else if (!state.em) {
                    state.em = ch;
                    if (modeCfg.highlightFormatting)
                        state.formatting = 'em';
                    return getType(state);
                }
            } else if (ch === ' ') {
                if (stream.eat('*') || stream.eat('_')) {
                    if (stream.peek() === ' ') {
                        return getType(state);
                    } else {
                        stream.backUp(1);
                    }
                }
            }
            if (ch === ' ') {
                if (stream.match(/ +$/, false)) {
                    state.trailingSpace++;
                } else if (state.trailingSpace) {
                    state.trailingSpaceNewLine = true;
                }
            }
            return getType(state);
        }
        function linkInline(stream, state) {
            var ch = stream.next();
            if (ch === '>') {
                state.f = state.inline = inlineNormal;
                if (modeCfg.highlightFormatting)
                    state.formatting = 'link';
                var type = getType(state);
                if (type) {
                    type += ' ';
                } else {
                    type = '';
                }
                return type + linkinline;
            }
            stream.match(/^[^>]+/, true);
            return linkinline;
        }
        function linkHref(stream, state) {
            if (stream.eatSpace()) {
                return null;
            }
            var ch = stream.next();
            if (ch === '(' || ch === '[') {
                state.f = state.inline = getLinkHrefInside(ch === '(' ? ')' : ']');
                if (modeCfg.highlightFormatting)
                    state.formatting = 'link-string';
                state.linkHref = true;
                return getType(state);
            }
            return 'error';
        }
        function getLinkHrefInside(endChar) {
            return function (stream, state) {
                var ch = stream.next();
                if (ch === endChar) {
                    state.f = state.inline = inlineNormal;
                    if (modeCfg.highlightFormatting)
                        state.formatting = 'link-string';
                    var returnState = getType(state);
                    state.linkHref = false;
                    return returnState;
                }
                if (stream.match(inlineRE(endChar), true)) {
                    stream.backUp(1);
                }
                state.linkHref = true;
                return getType(state);
            };
        }
        function footnoteLink(stream, state) {
            if (stream.match(/^[^\]]*\]:/, false)) {
                state.f = footnoteLinkInside;
                stream.next();
                if (modeCfg.highlightFormatting)
                    state.formatting = 'link';
                state.linkText = true;
                return getType(state);
            }
            return switchInline(stream, state, inlineNormal);
        }
        function footnoteLinkInside(stream, state) {
            if (stream.match(/^\]:/, true)) {
                state.f = state.inline = footnoteUrl;
                if (modeCfg.highlightFormatting)
                    state.formatting = 'link';
                var returnType = getType(state);
                state.linkText = false;
                return returnType;
            }
            stream.match(/^[^\]]+/, true);
            return linktext;
        }
        function footnoteUrl(stream, state) {
            if (stream.eatSpace()) {
                return null;
            }
            stream.match(/^[^\s]+/, true);
            if (stream.peek() === undefined) {
                state.linkTitle = true;
            } else {
                stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
            }
            state.f = state.inline = inlineNormal;
            return linkhref;
        }
        var savedInlineRE = [];
        function inlineRE(endChar) {
            if (!savedInlineRE[endChar]) {
                endChar = (endChar + '').replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
                savedInlineRE[endChar] = new RegExp('^(?:[^\\\\]|\\\\.)*?(' + endChar + ')');
            }
            return savedInlineRE[endChar];
        }
        var mode = {
            startState: function () {
                return {
                    f: blockNormal,
                    prevLineHasContent: false,
                    thisLineHasContent: false,
                    block: blockNormal,
                    htmlState: null,
                    indentation: 0,
                    inline: inlineNormal,
                    text: handleText,
                    escape: false,
                    formatting: false,
                    linkText: false,
                    linkHref: false,
                    linkTitle: false,
                    em: false,
                    strong: false,
                    header: 0,
                    taskList: false,
                    list: false,
                    listDepth: 0,
                    quote: 0,
                    trailingSpace: 0,
                    trailingSpaceNewLine: false
                };
            },
            copyState: function (s) {
                return {
                    f: s.f,
                    prevLineHasContent: s.prevLineHasContent,
                    thisLineHasContent: s.thisLineHasContent,
                    block: s.block,
                    htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),
                    indentation: s.indentation,
                    localMode: s.localMode,
                    localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,
                    inline: s.inline,
                    text: s.text,
                    escape: false,
                    formatting: false,
                    linkTitle: s.linkTitle,
                    em: s.em,
                    strong: s.strong,
                    header: s.header,
                    taskList: s.taskList,
                    list: s.list,
                    listDepth: s.listDepth,
                    quote: s.quote,
                    trailingSpace: s.trailingSpace,
                    trailingSpaceNewLine: s.trailingSpaceNewLine,
                    md_inside: s.md_inside
                };
            },
            token: function (stream, state) {
                state.formatting = false;
                if (stream.sol()) {
                    var forceBlankLine = stream.match(/^\s*$/, true) || state.header;
                    state.header = 0;
                    if (forceBlankLine) {
                        state.prevLineHasContent = false;
                        return blankLine(state);
                    } else {
                        state.prevLineHasContent = state.thisLineHasContent;
                        state.thisLineHasContent = true;
                    }
                    state.escape = false;
                    state.taskList = false;
                    state.code = false;
                    state.trailingSpace = 0;
                    state.trailingSpaceNewLine = false;
                    state.f = state.block;
                    var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, '    ').length;
                    var difference = Math.floor((indentation - state.indentation) / 4) * 4;
                    if (difference > 4)
                        difference = 4;
                    var adjustedIndentation = state.indentation + difference;
                    state.indentationDiff = adjustedIndentation - state.indentation;
                    state.indentation = adjustedIndentation;
                    if (indentation > 0)
                        return null;
                }
                var result = state.f(stream, state);
                if (stream.start == stream.pos)
                    return this.token(stream, state);
                else
                    return result;
            },
            innerMode: function (state) {
                if (state.block == htmlBlock)
                    return {
                        state: state.htmlState,
                        mode: htmlMode
                    };
                if (state.localState)
                    return {
                        state: state.localState,
                        mode: state.localMode
                    };
                return {
                    state: state,
                    mode: mode
                };
            },
            blankLine: blankLine,
            getType: getType,
            fold: 'markdown'
        };
        return mode;
    }, 'xml');
    CodeMirror.defineMIME('text/x-markdown', 'markdown');
    var listRE = /^(\s*)([*+-]|(\d+)\.)(\s+)/, unorderedBullets = '*+-';
    CodeMirror.commands.newlineAndIndentContinueMarkdownList = function (cm) {
        if (cm.getOption('disableInput'))
            return CodeMirror.Pass;
        var ranges = cm.listSelections(), replacements = [];
        for (var i = 0; i < ranges.length; i++) {
            var pos = ranges[i].head, match;
            var inList = cm.getStateAfter(pos.line).list !== false;
            if (!ranges[i].empty() || !inList || !(match = cm.getLine(pos.line).match(listRE))) {
                cm.execCommand('newlineAndIndent');
                return;
            }
            var indent = match[1], after = match[4];
            var bullet = unorderedBullets.indexOf(match[2]) >= 0 ? match[2] : parseInt(match[3], 10) + 1 + '.';
            replacements[i] = '\n' + indent + bullet + after;
        }
        cm.replaceSelections(replacements);
    };
    return CodeMirror;
}));
(function () {
    var __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };
    define('views/editor_view', [
        'backbone',
        'lib/codemirror',
        'app'
    ], function (Backbone, CodeMirror, app) {
        var EditorView;
        return EditorView = function (_super) {
            __extends(EditorView, _super);
            function EditorView() {
                return EditorView.__super__.constructor.apply(this, arguments);
            }
            EditorView.prototype.className = 'editor-view';
            EditorView.prototype.initialize = function () {
                return this.handleValueChange = _.debounce(this.handleValueChange, 200);
            };
            EditorView.prototype.render = function () {
                this.editor = CodeMirror(this.el, {
                    mode: 'markdown',
                    theme: 'empty',
                    lineNumbers: false,
                    lineWrapping: true,
                    viewportMargin: Infinity,
                    extraKeys: { 'Enter': 'newlineAndIndentContinueMarkdownList' }
                });
                this.editor.on('change', this.handleValueChange.bind(this));
                return this;
            };
            EditorView.prototype.handleValueChange = function (editor, options) {
                if (options.origin !== 'setValue') {
                    this.trigger('change', this.editor.getValue(), this);
                }
            };
            EditorView.prototype.setValue = function (value) {
                this.editor.setValue(value);
            };
            EditorView.prototype.refresh = function () {
                return this.editor.refresh();
            };
            EditorView.prototype.focus = function () {
                return this.editor.focus();
            };
            return EditorView;
        }(Backbone.View);
    });
}.call(this));
(function () {
    var __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };
    define('views/panel_view', [
        'backbone',
        'mousetrap',
        'app',
        'views/editor_view'
    ], function (Backbone, Mousetrap, app, EditorView) {
        var PanelView;
        return PanelView = function (_super) {
            __extends(PanelView, _super);
            function PanelView() {
                return PanelView.__super__.constructor.apply(this, arguments);
            }
            PanelView.prototype.template = _.template('<h2>\n  <input type="text" class="title-input">\n  <label class="title-label"></label>\n</h2>\n<div class="editor-view"></div>');
            PanelView.prototype.className = 'panel-view';
            PanelView.prototype.events = {
                'click': 'handleClick',
                'change input': 'handleChangeTitle'
            };
            PanelView.prototype.render = function () {
                this.$el.html(this.template());
                this.$el.addClass('number-' + this.model.id);
                this.$el.css('background-color', app.options.colors[this.model.id % app.options.colors.length]);
                this.updateTitle();
                this.editorView = new EditorView({ el: this.$('.editor-view') });
                this.editorView.render();
                this.editorView.setValue(this.model.get('contents'));
                this.listenTo(this.editorView, 'change', function (value) {
                    return this.model.set('contents', value);
                });
                this.listenTo(this, 'pageshow', function () {
                    return this.editorView.refresh();
                });
                this.listenTo(this.model, 'reset', function () {
                    this.editorView.setValue(this.model.get('contents'));
                    return this.updateTitle();
                });
                this.listenTo(this.model, 'change:title', function () {
                    return this.updateTitle();
                });
                Mousetrap.bind([
                    'command+' + (this.model.id + 1),
                    'ctrl+' + (this.model.id + 1)
                ], function (_this) {
                    return function (event) {
                        event.preventDefault();
                        return app.router.navigate('/panel/' + _this.model.id, { trigger: true });
                    };
                }(this));
                return this;
            };
            PanelView.prototype.updateTitle = function () {
                this.$('input').val(this.model.get('title'));
                return this.$('label').html(this.model.get('title'));
            };
            PanelView.prototype.handleClick = function () {
                return app.router.navigate('/panel/' + this.model.id, { trigger: true });
            };
            PanelView.prototype.handleChangeTitle = function () {
                return this.model.set('title', this.$('input').val());
            };
            PanelView.prototype.activate = function () {
                this.$el.addClass('active');
                return this.editorView.refresh();
            };
            PanelView.prototype.deactivate = function () {
                this.$el.removeClass('active');
                return this.editorView.refresh();
            };
            return PanelView;
        }(Backbone.View);
    });
}.call(this));
(function () {
    var __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };
    define('views/layout_view', [
        'backbone',
        'lodash',
        'hammer',
        'views/panel_view'
    ], function (Backbone, _, Hammer, PanelView) {
        var LayoutView, SCREEN_XS_MAX;
        SCREEN_XS_MAX = 767;
        return LayoutView = function (_super) {
            __extends(LayoutView, _super);
            function LayoutView() {
                return LayoutView.__super__.constructor.apply(this, arguments);
            }
            LayoutView.prototype.className = 'layout-view';
            LayoutView.prototype.template = '<div class="connection-label"></div>';
            LayoutView.prototype.events = { 'click .connection-label': 'handleConnectionLabelClick' };
            LayoutView.prototype.initialize = function () {
                return this.activeIndex = -1;
            };
            LayoutView.prototype.render = function () {
                this.$el.append(this.template);
                this.panelViews = app.models.map(function (_this) {
                    return function (model, i) {
                        var view;
                        view = new PanelView({ model: model });
                        _this.$el.append(view.render().el);
                        return view;
                    };
                }(this));
                if (this.panelViews.length > 0) {
                    this.setActive(0);
                }
                Hammer(document.body).on('swiperight', function (_this) {
                    return function () {
                        if (window.innerWidth <= SCREEN_XS_MAX && _this.activeIndex > 0) {
                            return app.router.navigate('/panel/' + (_this.activeIndex - 1), { trigger: true });
                        }
                    };
                }(this));
                Hammer(document.body).on('swipeleft', function (_this) {
                    return function () {
                        if (window.innerWidth <= SCREEN_XS_MAX && _this.activeIndex < app.options.panelCount - 1) {
                            return app.router.navigate('/panel/' + (_this.activeIndex + 1), { trigger: true });
                        }
                    };
                }(this));
                this.listenTo(this, 'pageshow', function () {
                    return this.panelViews.forEach(function (panelView) {
                        return panelView.trigger('pageshow');
                    });
                });
                this.listenTo(app, 'dropboxService:syncing', this.updateConnectionLabel);
                this.listenTo(app, 'dropboxService:authenticated', this.updateConnectionLabel);
                this.listenTo(app, 'dropboxService:synced', this.updateConnectionLabel);
                this.listenTo(app, 'dropboxService:ready', this.updateConnectionLabel);
                this.updateConnectionLabel();
                return this;
            };
            LayoutView.prototype.updateConnectionLabel = function () {
                var connectionLabel;
                if (app.dropboxService.isAuthenticated()) {
                    if (app.dropboxService.isReady) {
                        if (app.dropboxService.isTransient()) {
                            connectionLabel = 'Syncing...';
                        } else {
                            connectionLabel = 'Synced';
                        }
                    } else {
                        connectionLabel = 'Offline';
                    }
                } else {
                    connectionLabel = 'Connect with Dropbox.';
                }
                return this.$('.connection-label').html(connectionLabel);
            };
            LayoutView.prototype.setActive = function (index) {
                index = parseInt(index);
                if (index === this.activeIndex) {
                    return;
                }
                if (this.activeIndex >= 0) {
                    this.panelViews[this.activeIndex].deactivate();
                }
                if (index >= 0) {
                    this.panelViews[index].activate();
                }
                this.activeIndex = index;
            };
            LayoutView.prototype.handleConnectionLabelClick = function (event) {
                event.preventDefault();
                if (!app.dropboxService.isAuthenticated()) {
                    app.dropboxService.authenticate();
                }
            };
            return LayoutView;
        }(Backbone.View);
    });
}.call(this));
define('diff', [], function () {
    var JsDiff = function () {
        function clonePath(path) {
            return {
                newPos: path.newPos,
                components: path.components.slice(0)
            };
        }
        function removeEmpty(array) {
            var ret = [];
            for (var i = 0; i < array.length; i++) {
                if (array[i]) {
                    ret.push(array[i]);
                }
            }
            return ret;
        }
        function escapeHTML(s) {
            var n = s;
            n = n.replace(/&/g, '&amp;');
            n = n.replace(/</g, '&lt;');
            n = n.replace(/>/g, '&gt;');
            n = n.replace(/"/g, '&quot;');
            return n;
        }
        var Diff = function (ignoreWhitespace) {
            this.ignoreWhitespace = ignoreWhitespace;
        };
        Diff.prototype = {
            diff: function (oldString, newString) {
                if (newString === oldString) {
                    return [{ value: newString }];
                }
                if (!newString) {
                    return [{
                            value: oldString,
                            removed: true
                        }];
                }
                if (!oldString) {
                    return [{
                            value: newString,
                            added: true
                        }];
                }
                newString = this.tokenize(newString);
                oldString = this.tokenize(oldString);
                var newLen = newString.length, oldLen = oldString.length;
                var maxEditLength = newLen + oldLen;
                var bestPath = [{
                        newPos: -1,
                        components: []
                    }];
                var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
                if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
                    return bestPath[0].components;
                }
                for (var editLength = 1; editLength <= maxEditLength; editLength++) {
                    for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
                        var basePath;
                        var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1];
                        oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
                        if (addPath) {
                            bestPath[diagonalPath - 1] = undefined;
                        }
                        var canAdd = addPath && addPath.newPos + 1 < newLen;
                        var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;
                        if (!canAdd && !canRemove) {
                            bestPath[diagonalPath] = undefined;
                            continue;
                        }
                        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
                            basePath = clonePath(removePath);
                            this.pushComponent(basePath.components, oldString[oldPos], undefined, true);
                        } else {
                            basePath = clonePath(addPath);
                            basePath.newPos++;
                            this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);
                        }
                        var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);
                        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
                            return basePath.components;
                        } else {
                            bestPath[diagonalPath] = basePath;
                        }
                    }
                }
            },
            pushComponent: function (components, value, added, removed) {
                var last = components[components.length - 1];
                if (last && last.added === added && last.removed === removed) {
                    components[components.length - 1] = {
                        value: this.join(last.value, value),
                        added: added,
                        removed: removed
                    };
                } else {
                    components.push({
                        value: value,
                        added: added,
                        removed: removed
                    });
                }
            },
            extractCommon: function (basePath, newString, oldString, diagonalPath) {
                var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath;
                while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
                    newPos++;
                    oldPos++;
                    this.pushComponent(basePath.components, newString[newPos], undefined, undefined);
                }
                basePath.newPos = newPos;
                return oldPos;
            },
            equals: function (left, right) {
                var reWhitespace = /\S/;
                if (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right)) {
                    return true;
                } else {
                    return left === right;
                }
            },
            join: function (left, right) {
                return left + right;
            },
            tokenize: function (value) {
                return value;
            }
        };
        var CharDiff = new Diff();
        var WordDiff = new Diff(true);
        var WordWithSpaceDiff = new Diff();
        WordDiff.tokenize = WordWithSpaceDiff.tokenize = function (value) {
            return removeEmpty(value.split(/(\s+|\b)/));
        };
        var CssDiff = new Diff(true);
        CssDiff.tokenize = function (value) {
            return removeEmpty(value.split(/([{}:;,]|\s+)/));
        };
        var LineDiff = new Diff();
        LineDiff.tokenize = function (value) {
            var retLines = [], lines = value.split(/^/m);
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i], lastLine = lines[i - 1];
                if (line == '\n' && lastLine && lastLine[lastLine.length - 1] === '\r') {
                    retLines[retLines.length - 1] += '\n';
                } else if (line) {
                    retLines.push(line);
                }
            }
            return retLines;
        };
        return {
            Diff: Diff,
            diffChars: function (oldStr, newStr) {
                return CharDiff.diff(oldStr, newStr);
            },
            diffWords: function (oldStr, newStr) {
                return WordDiff.diff(oldStr, newStr);
            },
            diffWordsWithSpace: function (oldStr, newStr) {
                return WordWithSpaceDiff.diff(oldStr, newStr);
            },
            diffLines: function (oldStr, newStr) {
                return LineDiff.diff(oldStr, newStr);
            },
            diffCss: function (oldStr, newStr) {
                return CssDiff.diff(oldStr, newStr);
            },
            createPatch: function (fileName, oldStr, newStr, oldHeader, newHeader) {
                var ret = [];
                ret.push('Index: ' + fileName);
                ret.push('===================================================================');
                ret.push('--- ' + fileName + (typeof oldHeader === 'undefined' ? '' : '\t' + oldHeader));
                ret.push('+++ ' + fileName + (typeof newHeader === 'undefined' ? '' : '\t' + newHeader));
                var diff = LineDiff.diff(oldStr, newStr);
                if (!diff[diff.length - 1].value) {
                    diff.pop();
                }
                diff.push({
                    value: '',
                    lines: []
                });
                function contextLines(lines) {
                    return lines.map(function (entry) {
                        return ' ' + entry;
                    });
                }
                function eofNL(curRange, i, current) {
                    var last = diff[diff.length - 2], isLast = i === diff.length - 2, isLastOfType = i === diff.length - 3 && (current.added !== last.added || current.removed !== last.removed);
                    if (!/\n$/.test(current.value) && (isLast || isLastOfType)) {
                        curRange.push('\\ No newline at end of file');
                    }
                }
                var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
                for (var i = 0; i < diff.length; i++) {
                    var current = diff[i], lines = current.lines || current.value.replace(/\n$/, '').split('\n');
                    current.lines = lines;
                    if (current.added || current.removed) {
                        if (!oldRangeStart) {
                            var prev = diff[i - 1];
                            oldRangeStart = oldLine;
                            newRangeStart = newLine;
                            if (prev) {
                                curRange = contextLines(prev.lines.slice(-4));
                                oldRangeStart -= curRange.length;
                                newRangeStart -= curRange.length;
                            }
                        }
                        curRange.push.apply(curRange, lines.map(function (entry) {
                            return (current.added ? '+' : '-') + entry;
                        }));
                        eofNL(curRange, i, current);
                        if (current.added) {
                            newLine += lines.length;
                        } else {
                            oldLine += lines.length;
                        }
                    } else {
                        if (oldRangeStart) {
                            if (lines.length <= 8 && i < diff.length - 2) {
                                curRange.push.apply(curRange, contextLines(lines));
                            } else {
                                var contextSize = Math.min(lines.length, 4);
                                ret.push('@@ -' + oldRangeStart + ',' + (oldLine - oldRangeStart + contextSize) + ' +' + newRangeStart + ',' + (newLine - newRangeStart + contextSize) + ' @@');
                                ret.push.apply(ret, curRange);
                                ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));
                                if (lines.length <= 4) {
                                    eofNL(ret, i, current);
                                }
                                oldRangeStart = 0;
                                newRangeStart = 0;
                                curRange = [];
                            }
                        }
                        oldLine += lines.length;
                        newLine += lines.length;
                    }
                }
                return ret.join('\n') + '\n';
            },
            applyPatch: function (oldStr, uniDiff) {
                var diffstr = uniDiff.split('\n');
                var diff = [];
                var remEOFNL = false, addEOFNL = false;
                for (var i = diffstr[0][0] === 'I' ? 4 : 0; i < diffstr.length; i++) {
                    if (diffstr[i][0] === '@') {
                        var meh = diffstr[i].split(/@@ -(\d+),(\d+) \+(\d+),(\d+) @@/);
                        diff.unshift({
                            start: meh[3],
                            oldlength: meh[2],
                            oldlines: [],
                            newlength: meh[4],
                            newlines: []
                        });
                    } else if (diffstr[i][0] === '+') {
                        diff[0].newlines.push(diffstr[i].substr(1));
                    } else if (diffstr[i][0] === '-') {
                        diff[0].oldlines.push(diffstr[i].substr(1));
                    } else if (diffstr[i][0] === ' ') {
                        diff[0].newlines.push(diffstr[i].substr(1));
                        diff[0].oldlines.push(diffstr[i].substr(1));
                    } else if (diffstr[i][0] === '\\') {
                        if (diffstr[i - 1][0] === '+') {
                            remEOFNL = true;
                        } else if (diffstr[i - 1][0] === '-') {
                            addEOFNL = true;
                        }
                    }
                }
                var str = oldStr.split('\n');
                for (var i = diff.length - 1; i >= 0; i--) {
                    var d = diff[i];
                    for (var j = 0; j < d.oldlength; j++) {
                        if (str[d.start - 1 + j] !== d.oldlines[j]) {
                            return false;
                        }
                    }
                    Array.prototype.splice.apply(str, [
                        d.start - 1,
                        +d.oldlength
                    ].concat(d.newlines));
                }
                if (remEOFNL) {
                    while (!str[str.length - 1]) {
                        str.pop();
                    }
                } else if (addEOFNL) {
                    str.push('');
                }
                return str.join('\n');
            },
            convertChangesToXML: function (changes) {
                var ret = [];
                for (var i = 0; i < changes.length; i++) {
                    var change = changes[i];
                    if (change.added) {
                        ret.push('<ins>');
                    } else if (change.removed) {
                        ret.push('<del>');
                    }
                    ret.push(escapeHTML(change.value));
                    if (change.added) {
                        ret.push('</ins>');
                    } else if (change.removed) {
                        ret.push('</del>');
                    }
                }
                return ret.join('');
            },
            convertChangesToDMP: function (changes) {
                var ret = [], change;
                for (var i = 0; i < changes.length; i++) {
                    change = changes[i];
                    ret.push([
                        change.added ? 1 : change.removed ? -1 : 0,
                        change.value
                    ]);
                }
                return ret;
            }
        };
    }();
    if (typeof module !== 'undefined') {
        module.exports = JsDiff;
    }
    return JsDiff;
});
(function () {
    define('models/note_model', [
        'lodash',
        'backbone',
        'diff',
        'app'
    ], function (_, Backbone, Diff, app) {
        var NoteModel;
        return NoteModel = function () {
            NoteModel.prototype.LOCALSTORAGE_KEY = 'scratchpad-note';
            function NoteModel(options) {
                _.extend(this, Backbone.Events);
                this.id = options.id;
                this.attributes = {
                    _syncedRevision: 0,
                    _revision: 0,
                    title: '',
                    contents: ''
                };
                this.load();
                app.on('dropboxService:recordsChangedRemote', function (_this) {
                    return function () {
                        console.log(_this.id, 'dropbox change');
                        return _this.sync();
                    };
                }(this));
                app.on('dropboxService:synced', function (_this) {
                    return function () {
                        console.log(_this.id, 'dropbox synced', _this.pull()._revision);
                        _this.attributes._syncedRevision = _this.pull()._revision;
                        return _this.persist();
                    };
                }(this));
                app.on('dropboxService:ready', function (_this) {
                    return function () {
                        console.log(_this.id, 'dropbox ready');
                        return _this.sync();
                    };
                }(this));
            }
            NoteModel.prototype.set = function (key, value, options) {
                if (options == null) {
                    options = {};
                }
                if (key in this.attributes && this.attributes[key] !== value) {
                    this.attributes[key] = value;
                    this.attributes._revision += 1;
                    this.persist();
                    if (!options.silent) {
                        this.trigger('change', this);
                        this.trigger('change:' + key, this, value);
                    }
                    this.sync();
                }
            };
            NoteModel.prototype.get = function (key) {
                return this.attributes[key];
            };
            NoteModel.prototype.sync = function () {
                var local, remote;
                if (remote = this.pull()) {
                    local = this.attributes;
                    if (local._revision > local._syncedRevision && remote._revision > local._syncedRevision && !app.dropboxService.isTransient()) {
                        console.log(this.id, 'merge conflict', app.dropboxService.isTransient());
                        if (!confirm('Merge conflict in Panel \'' + local.title + '\'. Do you wish to keep your local changes?')) {
                            this.attributes.title = remote.title;
                            this.attributes.contents = remote.contents;
                        }
                        this.attributes._revision = Math.max(local._revision, remote._revision) + 1;
                        this.persist();
                        this.push();
                        return this.trigger('reset');
                    } else {
                        this.attributes._syncedRevision = remote._revision;
                        this.persist();
                        if (local._revision > remote._revision) {
                            console.log(this.id, 'merge local');
                            return this.push();
                        } else if (local._revision < remote._revision) {
                            console.log(this.id, 'merge remote');
                            _.extend(this.attributes, remote);
                            this.trigger('reset');
                            return this.persist();
                        } else {
                            return console.log(this.id, 'merge equal');
                        }
                    }
                } else {
                    return this.push();
                }
            };
            NoteModel.prototype.toJSON = function () {
                return _.clone(this.attributes);
            };
            NoteModel.prototype.push = function () {
                var transferObj;
                transferObj = _.omit(this.attributes, '_syncedRevision');
                app.dropboxService.updateNote(this.id, transferObj);
            };
            NoteModel.prototype.pull = function () {
                return app.dropboxService.getNote(this.id);
            };
            NoteModel.prototype.persist = function () {
                var storedObj;
                storedObj = _.pick(this.attributes, [
                    '_revision',
                    '_syncedRevision',
                    'title',
                    'contents'
                ]);
                window.localStorage.setItem('' + this.LOCALSTORAGE_KEY + '-' + this.id, JSON.stringify(storedObj));
            };
            NoteModel.prototype.load = function () {
                var storedString;
                storedString = window.localStorage.getItem('' + this.LOCALSTORAGE_KEY + '-' + this.id);
                if (storedString) {
                    _.extend(this.attributes, JSON.parse(storedString));
                }
            };
            return NoteModel;
        }();
    });
}.call(this));
define('dropbox', [], function () {
    (function () {
        var t, e, r, n, i, o, s, a, u, l, h, c, d, p, _, f, g, y, m, v, w, b, S, D, E, A, I, O, x, T, U, C, R, k, P, L, N, F, B, z, j, X, M, H, q, V, G, J, W, K, Z, $, Q, Y, te, ee, re = {}.hasOwnProperty, ne = [].indexOf || function (t) {
                for (var e = 0, r = this.length; r > e; e++)
                    if (e in this && this[e] === t)
                        return e;
                return -1;
            }, ie = function (t, e) {
                function r() {
                    this.constructor = t;
                }
                for (var n in e)
                    re.call(e, n) && (t[n] = e[n]);
                return r.prototype = e.prototype, t.prototype = new r(), t.__super__ = e.prototype, t;
            }, oe = [].slice;
        if (D = function () {
                function t() {
                    throw new Error('Not implemented. Did you mean to use Dropbox.Client?');
                }
                return t;
            }(), D.Util = function () {
                function t() {
                }
                return t;
            }(), D.Http = function () {
                function t() {
                }
                return t;
            }(), D.File = function () {
                function t() {
                }
                return t;
            }(), u = '1.1.0', 'undefined' != typeof global && 'undefined' != typeof module && 'exports' in module)
            c = global, d = module.require.bind(module), module.exports = D;
        else if ('undefined' != typeof window && 'undefined' != typeof navigator)
            c = window, d = null, window.Dropbox && !function () {
                var t, e, r, n;
                r = window.Dropbox, n = [];
                for (t in r)
                    re.call(r, t) && (e = r[t], n.push(D[t] = e));
                return n;
            }(), window.Dropbox = D;
        else {
            if ('undefined' == typeof self || 'undefined' == typeof navigator)
                throw new Error('dropbox.js loaded in an unsupported JavaScript environment.');
            c = self, d = self.importScripts.bind(self), self.Dropbox = D;
        }
        if (D.Env = function () {
                function t() {
                }
                return t.global = c, t.require = d, t;
            }(), D.Util.EventSource = function () {
                function t(t) {
                    this._cancelable = t && t.cancelable, this._listeners = [];
                }
                return t.prototype.addListener = function (t) {
                    if ('function' != typeof t)
                        throw new TypeError('Invalid listener type; expected function');
                    return ne.call(this._listeners, t) < 0 && this._listeners.push(t), this;
                }, t.prototype.removeListener = function (t) {
                    var e, r, n, i, o, s;
                    if (this._listeners.indexOf)
                        r = this._listeners.indexOf(t), -1 !== r && this._listeners.splice(r, 1);
                    else
                        for (s = this._listeners, e = i = 0, o = s.length; o > i; e = ++i)
                            if (n = s[e], n === t) {
                                this._listeners.splice(e, 1);
                                break;
                            }
                    return this;
                }, t.prototype.dispatch = function (t) {
                    var e, r, n, i, o;
                    for (o = this._listeners, n = 0, i = o.length; i > n; n++)
                        if (e = o[n], r = e(t), this._cancelable && r === !1)
                            return !1;
                    return !0;
                }, t;
            }(), D.AccountInfo = function () {
                function t(t) {
                    var e;
                    this._json = t, this.name = t.display_name, this.email = t.email, this.countryCode = t.country || null, this.uid = t.uid.toString(), t.public_app_url ? (this.publicAppUrl = t.public_app_url, e = this.publicAppUrl.length - 1, e >= 0 && '/' === this.publicAppUrl.substring(e) && (this.publicAppUrl = this.publicAppUrl.substring(0, e))) : this.publicAppUrl = null, this.referralUrl = t.referral_link, this.quota = t.quota_info.quota, this.privateBytes = t.quota_info.normal || 0, this.sharedBytes = t.quota_info.shared || 0, this.usedQuota = this.privateBytes + this.sharedBytes;
                }
                return t.parse = function (t) {
                    return t && 'object' == typeof t ? new D.AccountInfo(t) : t;
                }, t.prototype.name = null, t.prototype.email = null, t.prototype.countryCode = null, t.prototype.uid = null, t.prototype.referralUrl = null, t.prototype.publicAppUrl = null, t.prototype.quota = null, t.prototype.usedQuota = null, t.prototype.privateBytes = null, t.prototype.sharedBytes = null, t.prototype.json = function () {
                    return this._json;
                }, t;
            }(), D.ApiError = function () {
                function t(t, e, r) {
                    var n, i;
                    if (this.method = e, this.url = r, this.status = t.status, t.responseType)
                        try {
                            n = t.response || t.responseText;
                        } catch (o) {
                            i = o;
                            try {
                                n = t.responseText;
                            } catch (o) {
                                i = o, n = null;
                            }
                        }
                    else
                        try {
                            n = t.responseText;
                        } catch (o) {
                            i = o, n = null;
                        }
                    if (n)
                        try {
                            this.responseText = n.toString(), this.response = JSON.parse(n);
                        } catch (o) {
                            i = o, this.response = null;
                        }
                    else
                        this.responseText = '(no response)', this.response = null;
                }
                return t.prototype.status = null, t.prototype.method = null, t.prototype.url = null, t.prototype.responseText = null, t.prototype.response = null, t.NETWORK_ERROR = 0, t.NO_CONTENT = 304, t.INVALID_PARAM = 400, t.INVALID_TOKEN = 401, t.OAUTH_ERROR = 403, t.NOT_FOUND = 404, t.INVALID_METHOD = 405, t.NOT_ACCEPTABLE = 406, t.CONFLICT = 409, t.RATE_LIMITED = 429, t.SERVER_ERROR = 503, t.OVER_QUOTA = 507, t.prototype.toString = function () {
                    return 'Dropbox API error ' + this.status + ' from ' + this.method + ' ' + this.url + ' :: ' + this.responseText;
                }, t.prototype.inspect = function () {
                    return this.toString();
                }, t;
            }(), D.AuthDriver = function () {
                function t() {
                }
                return t.prototype.authType = function () {
                    return 'code';
                }, t.prototype.url = function () {
                    return 'https://some.url';
                }, t.prototype.doAuthorize = function (t, e, r, n) {
                    return n({ code: 'access-code' });
                }, t.prototype.getStateParam = function (t, e) {
                    return e(D.Util.Oauth.randomAuthStateParam());
                }, t.prototype.resumeAuthorize = function (t, e, r) {
                    return r({ code: 'access-code' });
                }, t.prototype.onAuthStateChange = function (t, e) {
                    return e();
                }, t.oauthQueryParams = [
                    'access_token',
                    'expires_in',
                    'scope',
                    'token_type',
                    'code',
                    'error',
                    'error_description',
                    'error_uri',
                    'mac_key',
                    'mac_algorithm'
                ].sort(), t;
            }(), D.AuthDriver.autoConfigure = function (t) {
                if ('undefined' != typeof chrome && chrome.runtime && chrome.runtime.id)
                    return chrome.tabs && chrome.tabs.create ? t.authDriver(new D.AuthDriver.ChromeExtension()) : t.authDriver(new D.AuthDriver.ChromeApp()), void 0;
                if ('undefined' != typeof window) {
                    if (window.cordova)
                        return t.authDriver(new D.AuthDriver.Cordova()), void 0;
                    window && window.navigator && t.authDriver(new D.AuthDriver.Redirect());
                }
            }, D.AuthDriver.BrowserBase = function () {
                function t(t) {
                    t ? (this.rememberUser = 'rememberUser' in t ? t.rememberUser : !0, this.scope = t.scope || 'default') : (this.rememberUser = !0, this.scope = 'default'), this.storageKey = null, this.storage = D.AuthDriver.BrowserBase.localStorage(), this.stateRe = /^[^#]+\#(.*&)?state=([^&]+)(&|$)/;
                }
                return t.prototype.authType = function () {
                    return 'token';
                }, t.prototype.onAuthStepChange = function (t, e) {
                    var r = this;
                    switch (this.setStorageKey(t), t.authStep) {
                    case D.Client.RESET:
                        return this.loadCredentials(function (n) {
                            return n ? (t.setCredentials(n), t.authStep !== D.Client.DONE ? e() : r.rememberUser ? (t.setCredentials(n), e()) : r.forgetCredentials(e)) : e();
                        });
                    case D.Client.DONE:
                        return this.rememberUser ? this.storeCredentials(t.credentials(), e) : this.forgetCredentials(e);
                    case D.Client.SIGNED_OUT:
                        return this.forgetCredentials(e);
                    case D.Client.ERROR:
                        return this.forgetCredentials(e);
                    default:
                        return e(), this;
                    }
                }, t.prototype.setStorageKey = function (t) {
                    return this.storageKey = 'dropbox-auth:' + this.scope + ':' + t.appHash(), this;
                }, t.prototype.storeCredentials = function (t, e) {
                    var r, n, i, o;
                    r = JSON.stringify(t);
                    try {
                        this.storage.setItem(this.storageKey, r);
                    } catch (s) {
                        i = s, n = encodeURIComponent(this.storageKey), o = encodeURIComponent(r), document.cookie = '' + n + '=' + o + '; path=/';
                    }
                    return e(), this;
                }, t.prototype.loadCredentials = function (t) {
                    var e, r, n, i, o, s, a;
                    try {
                        n = this.storage.getItem(this.storageKey);
                    } catch (u) {
                        a = u, n = null;
                    }
                    if (null === n && (o = encodeURIComponent(this.storageKey), s = o.replace(/[.*+()]/g, '\\$&'), e = new RegExp('(^|(;\\s*))' + o + '=([^;]*)(;|$)'), (i = e.exec(document.cookie)) && (n = decodeURIComponent(i[3]))), !n)
                        return t(null), this;
                    try {
                        t(JSON.parse(n));
                    } catch (u) {
                        r = u, t(null);
                    }
                    return this;
                }, t.prototype.forgetCredentials = function (t) {
                    var e, r, n;
                    try {
                        this.storage.removeItem(this.storageKey);
                    } catch (i) {
                        n = i, r = encodeURIComponent(this.storageKey), e = new Date(0).toGMTString(), document.cookie = '' + r + '={}; expires=' + e + '; path=/';
                    }
                    return t(), this;
                }, t.prototype.locationStateParam = function (t) {
                    var e, r;
                    return e = t || D.AuthDriver.BrowserBase.currentLocation(), r = this.stateRe.exec(e), r ? decodeURIComponent(r[2]) : null;
                }, t.prototype.replaceUrlBasename = function (t, e) {
                    var r, n, i;
                    return n = t.indexOf('#'), -1 !== n && (t = t.substring(0, n)), i = t.indexOf('?'), -1 !== i && (t = t.substring(0, i)), r = t.split('/'), r[r.length - 1] = e, r.join('/');
                }, t.localStorage = function () {
                    return 'undefined' != typeof window ? window.localStorage : null;
                }, t.currentLocation = function () {
                    return window.location.href;
                }, t.cleanupLocation = function () {
                    var t, e;
                    window.history && window.history.replaceState ? (e = this.currentLocation(), t = e.indexOf('#'), window.history.replaceState({}, document.title, e.substring(0, t))) : window.location.hash = '';
                }, t;
            }(), D.AuthDriver.Redirect = function (t) {
                function e(t) {
                    e.__super__.constructor.call(this, t), this.receiverUrl = this.baseUrl(t);
                }
                return ie(e, t), e.prototype.baseUrl = function (t) {
                    var e, r;
                    if (r = D.AuthDriver.BrowserBase.currentLocation(), t) {
                        if (t.redirectUrl)
                            return t.redirectUrl;
                        if (t.redirectFile)
                            return this.replaceUrlBasename(r, t.redirectFile);
                    }
                    return e = r.indexOf('#'), -1 !== e && (r = r.substring(0, e)), r;
                }, e.prototype.url = function () {
                    return this.receiverUrl;
                }, e.prototype.doAuthorize = function (t, e, r) {
                    return this.storeCredentials(r.credentials(), function () {
                        return window.location.assign(t);
                    });
                }, e.prototype.resumeAuthorize = function (t, e, r) {
                    var n;
                    return this.locationStateParam() === t ? (n = D.AuthDriver.BrowserBase.currentLocation(), D.AuthDriver.BrowserBase.cleanupLocation(), r(D.Util.Oauth.queryParamsFromUrl(n))) : this.forgetCredentials(function () {
                        return r({ error: 'Authorization error' });
                    });
                }, e;
            }(D.AuthDriver.BrowserBase), D.AuthDriver.Popup = function (t) {
                function e(t) {
                    e.__super__.constructor.call(this, t), this.receiverUrl = this.baseUrl(t);
                }
                return ie(e, t), e.prototype.url = function () {
                    return this.receiverUrl;
                }, e.prototype.doAuthorize = function (t, e, r, n) {
                    return this.listenForMessage(e, n), this.openWindow(t);
                }, e.prototype.baseUrl = function (t) {
                    var e;
                    if (e = D.AuthDriver.BrowserBase.currentLocation(), t) {
                        if (t.receiverUrl)
                            return t.receiverUrl;
                        if (t.receiverFile)
                            return this.replaceUrlBasename(e, t.receiverFile);
                    }
                    return e;
                }, e.prototype.openWindow = function (t) {
                    return window.open(t, '_dropboxOauthSigninWindow', this.popupWindowSpec(980, 700));
                }, e.prototype.popupWindowSpec = function (t, e) {
                    var r, n, i, o, s, a, u, l, h, c;
                    return s = null != (u = window.screenX) ? u : window.screenLeft, a = null != (l = window.screenY) ? l : window.screenTop, o = null != (h = window.outerWidth) ? h : document.documentElement.clientWidth, r = null != (c = window.outerHeight) ? c : document.documentElement.clientHeight, n = Math.round(s + (o - t) / 2), i = Math.round(a + (r - e) / 2.5), s > n && (n = s), a > i && (i = a), 'width=' + t + ',height=' + e + ',' + ('left=' + n + ',top=' + i) + 'dialog=yes,dependent=yes,scrollbars=yes,location=yes';
                }, e.prototype.listenForMessage = function (t, e) {
                    var r, n = this;
                    return r = function (i) {
                        var o, s, a;
                        o = i.data ? i.data : i;
                        try {
                            a = JSON.parse(o)._dropboxjs_oauth_info;
                        } catch (u) {
                            return s = u, void 0;
                        }
                        if (a)
                            return n.locationStateParam(a) === t ? (t = !1, window.removeEventListener('message', r), D.AuthDriver.Popup.onMessage.removeListener(r), e(D.Util.Oauth.queryParamsFromUrl(o))) : void 0;
                    }, window.addEventListener('message', r, !1), D.AuthDriver.Popup.onMessage.addListener(r);
                }, e.locationOrigin = function (t) {
                    var e;
                    return (e = /^(file:\/\/[^\?\#]*)(\?|\#|$)/.exec(t)) ? e[1] : (e = /^([^\:]+\:\/\/[^\/\?\#]*)(\/|\?|\#|$)/.exec(t), e ? e[1] : t);
                }, e.oauthReceiver = function () {
                    window.addEventListener('load', function () {
                        var t, e, r, n, i, o;
                        if (o = window.location.href, r = JSON.stringify({ _dropboxjs_oauth_info: o }), D.AuthDriver.BrowserBase.cleanupLocation(), n = window.opener, window.parent !== window.top && (n || (n = window.parent)), n) {
                            try {
                                i = window.location.origin || locationOrigin(o), n.postMessage(r, i), window.close();
                            } catch (s) {
                                e = s;
                            }
                            try {
                                return n.Dropbox.AuthDriver.Popup.onMessage.dispatch(r), window.close();
                            } catch (s) {
                                t = s;
                            }
                        }
                    });
                }, e.onMessage = new D.Util.EventSource(), e;
            }(D.AuthDriver.BrowserBase), D.AuthDriver.ChromeBase = function (t) {
                function e(t) {
                    e.__super__.constructor.call(this, t), this.storageKey = 'dropbox_js_' + this.scope + '_credentials';
                }
                return ie(e, t), e.prototype.onAuthStepChange = function (t, e) {
                    switch (t.authStep) {
                    case D.Client.RESET:
                        return this.loadCredentials(function (r) {
                            return r && t.setCredentials(r), e();
                        });
                    case D.Client.DONE:
                        return this.storeCredentials(t.credentials(), e);
                    case D.Client.SIGNED_OUT:
                        return this.forgetCredentials(e);
                    case D.Client.ERROR:
                        return this.forgetCredentials(e);
                    default:
                        return e();
                    }
                }, e.prototype.url = function () {
                    return this.receiverUrl;
                }, e.prototype.storeCredentials = function (t, e) {
                    var r;
                    return r = {}, r[this.storageKey] = t, chrome.storage.local.set(r, e), this;
                }, e.prototype.loadCredentials = function (t) {
                    var e = this;
                    return chrome.storage.local.get(this.storageKey, function (r) {
                        return t(r[e.storageKey] || null);
                    }), this;
                }, e.prototype.forgetCredentials = function (t) {
                    return chrome.storage.local.remove(this.storageKey, t), this;
                }, e;
            }(D.AuthDriver.BrowserBase), D.AuthDriver.ChromeApp = function (t) {
                function e(t) {
                    e.__super__.constructor.call(this, t), this.receiverUrl = 'https://' + chrome.runtime.id + '.chromiumapp.org/';
                }
                return ie(e, t), e.prototype.doAuthorize = function (t, e, r, n) {
                    var i = this;
                    return chrome.identity.launchWebAuthFlow({
                        url: t,
                        interactive: !0
                    }, function (t) {
                        return i.locationStateParam(t) === e ? (e = !1, n(D.Util.Oauth.queryParamsFromUrl(t))) : void 0;
                    });
                }, e;
            }(D.AuthDriver.ChromeBase), D.AuthDriver.ChromeExtension = function (t) {
                function e(t) {
                    var r;
                    e.__super__.constructor.call(this, t), r = t && t.receiverPath || 'chrome_oauth_receiver.html', this.receiverUrl = chrome.runtime.getURL(r);
                }
                return ie(e, t), e.prototype.doAuthorize = function (t, e, r, n) {
                    var i, o, s = this;
                    return o = null, i = function (t, r) {
                        var a;
                        if ((!r || !r.tab || r.tab.url.substring(0, s.receiverUrl.length) === s.receiverUrl) && t.dropbox_oauth_receiver_href)
                            return a = t.dropbox_oauth_receiver_href, s.locationStateParam(a) === e ? (e = !1, o && chrome.tabs.remove(o.id), chrome.runtime.onMessage.removeListener(i), n(D.Util.Oauth.queryParamsFromUrl(a))) : void 0;
                    }, chrome.runtime.onMessage.addListener(i), chrome.tabs.create({
                        url: t,
                        active: !0,
                        pinned: !1
                    }, function (t) {
                        return o = t;
                    });
                }, e.oauthReceiver = function () {
                    return window.addEventListener('load', function () {
                        var t;
                        return t = window.location.href, window.location.hash = '', chrome.runtime.sendMessage({ dropbox_oauth_receiver_href: t }), window.close ? window.close() : void 0;
                    });
                }, e;
            }(D.AuthDriver.ChromeBase), D.AuthDriver.Cordova = function (t) {
                function e(t) {
                    e.__super__.constructor.call(this, t);
                }
                return ie(e, t), e.prototype.url = function () {
                    return 'https://www.dropbox.com/1/oauth2/redirect_receiver';
                }, e.prototype.doAuthorize = function (t, e, r, n) {
                    var i, o, s, a, u, l = this;
                    return o = window.open(t, '_blank', 'location=yes,closebuttoncaption=Cancel'), a = !1, i = /^[^/]*\/\/[^/]*\//.exec(t)[0], u = !1, s = function (t) {
                        if (t.url && l.locationStateParam(t.url) === e) {
                            if (u)
                                return;
                            return o.removeEventListener('loadstart', s), o.removeEventListener('loaderror', s), o.removeEventListener('loadstop', s), o.removeEventListener('exit', s), u = !0, window.setTimeout(function () {
                                return o.close();
                            }, 10), n(D.Util.Oauth.queryParamsFromUrl(t.url)), void 0;
                        }
                        if ('exit' === t.type) {
                            if (u)
                                return;
                            o.removeEventListener('loadstart', s), o.removeEventListener('loaderror', s), o.removeEventListener('loadstop', s), o.removeEventListener('exit', s), u = !0, n(new AuthError('error=access_denied&error_description=User+closed+browser+window'));
                        }
                    }, o.addEventListener('loadstart', s), o.addEventListener('loaderror', s), o.addEventListener('loadstop', s), o.addEventListener('exit', s);
                }, e;
            }(D.AuthDriver.BrowserBase), D.AuthDriver.NodeServer = function () {
                function t(t) {
                    this._port = (null != t ? t.port : void 0) || 8912, (null != t ? t.tls : void 0) ? (this._tlsOptions = t.tls, ('string' == typeof this._tlsOptions || this._tlsOptions instanceof Buffer) && (this._tlsOptions = {
                        key: this._tlsOptions,
                        cert: this._tlsOptions
                    })) : this._tlsOptions = null, this._fs = D.Env.require('fs'), this._http = D.Env.require('http'), this._https = D.Env.require('https'), this._open = D.Env.require('open'), this._callbacks = {}, this._nodeUrl = D.Env.require('url'), this.createApp();
                }
                return t.prototype.authType = function () {
                    return 'code';
                }, t.prototype.url = function () {
                    var t;
                    return t = null === this._tlsOptions ? 'http' : 'https', '' + t + '://localhost:' + this._port + '/oauth_callback';
                }, t.prototype.doAuthorize = function (t, e, r, n) {
                    return this._callbacks[e] = n, this.openBrowser(t);
                }, t.prototype.openBrowser = function (t) {
                    if (!t.match(/^https?:\/\//))
                        throw new Error('Not a http/https URL: ' + t);
                    return 'BROWSER' in process.env ? this._open(t, process.env.BROWSER) : this._open(t);
                }, t.prototype.createApp = function () {
                    var t = this;
                    return this._app = this._tlsOptions ? this._https.createServer(this._tlsOptions, function (e, r) {
                        return t.doRequest(e, r);
                    }) : this._http.createServer(function (e, r) {
                        return t.doRequest(e, r);
                    }), this._app.listen(this._port);
                }, t.prototype.closeServer = function () {
                    return this._app.close();
                }, t.prototype.doRequest = function (t, e) {
                    var r, n, i, o = this;
                    return i = this._nodeUrl.parse(t.url, !0), '/oauth_callback' === i.pathname && (n = i.query.state, this._callbacks[n] && (this._callbacks[n](i.query), delete this._callbacks[n])), r = '', t.on('data', function (t) {
                        return r += t;
                    }), t.on('end', function () {
                        return o.closeBrowser(e);
                    });
                }, t.prototype.closeBrowser = function (t) {
                    var e;
                    return e = '<!doctype html>\n<script type="text/javascript">window.close();</script>\n<p>Please close this window.</p>', t.writeHead(200, {
                        'Content-Length': e.length,
                        'Content-Type': 'text/html'
                    }), t.write(e), t.end();
                }, t;
            }(), D.AuthError = function () {
                function t(t) {
                    var e;
                    if (!t.error)
                        throw new Error('Not an OAuth 2.0 error: ' + JSON.stringify(t));
                    e = 'object' == typeof t.error && t.error.error ? t.error : t, this.code = e.error, this.description = e.error_description || null, this.uri = e.error_uri || null;
                }
                return t.prototype.code = null, t.prototype.description = null, t.prototype.uri = null, t.ACCESS_DENIED = 'access_denied', t.INVALID_REQUEST = 'invalid_request', t.UNAUTHORIZED_CLIENT = 'unauthorized_client', t.INVALID_GRANT = 'invalid_grant', t.INVALID_SCOPE = 'invalid_scope', t.UNSUPPORTED_GRANT_TYPE = 'unsupported_grant_type', t.UNSUPPORTED_RESPONSE_TYPE = 'unsupported_response_type', t.SERVER_ERROR = 'server_error', t.TEMPORARILY_UNAVAILABLE = 'temporarily_unavailable', t.prototype.toString = function () {
                    return 'Dropbox OAuth error ' + this.code + ' :: ' + this.description;
                }, t.prototype.inspect = function () {
                    return this.toString();
                }, t;
            }(), D.Client = function () {
                function t(t) {
                    var e = this;
                    this._serverRoot = t.server || this._defaultServerRoot(), this._maxApiServer = 'maxApiServer' in t ? t.maxApiServer : this._defaultMaxApiServer(), this._authServer = t.authServer || this._defaultAuthServer(), this._fileServer = t.fileServer || this._defaultFileServer(), this._downloadServer = t.downloadServer || this._defaultDownloadServer(), this._notifyServer = t.notifyServer || this._defaultNotifyServer(), this.onXhr = new D.Util.EventSource({ cancelable: !0 }), this.onError = new D.Util.EventSource(), this.onAuthStepChange = new D.Util.EventSource(), this._xhrOnErrorHandler = function (t, r) {
                        return e._handleXhrError(t, r);
                    }, this._oauth = new D.Util.Oauth(t), this._uid = t.uid || null, this.authStep = this._oauth.step(), this._driver = null, this.authError = null, this._credentials = null, this._datastoreManager = null, this.setupUrls();
                }
                return t.prototype.onXhr = null, t.prototype.onError = null, t.prototype.onAuthStepChange = null, t.prototype.authDriver = function (t) {
                    return this._driver = t, this;
                }, t.prototype.dropboxUid = function () {
                    return this._uid;
                }, t.prototype.credentials = function () {
                    return this._credentials || this._computeCredentials(), this._credentials;
                }, t.prototype.authenticate = function (t, e) {
                    var r, n, i, o, s, a = this;
                    if (e || 'function' != typeof t || (e = t, t = null), r = t && 'interactive' in t ? t.interactive : !0, !this._driver && this.authStep !== h.DONE && (D.AuthDriver.autoConfigure(this), !this._driver))
                        throw new Error('OAuth driver auto-configuration failed. Call authDriver.');
                    if (this.authStep === h.ERROR)
                        throw new Error('Client got in an error state. Call reset() to reuse it!');
                    return o = function () {
                        return a.authStep = a._oauth.step(), a.authStep === h.ERROR && (a.authError = a._oauth.error()), a._credentials = null, a.onAuthStepChange.dispatch(a), s();
                    }, i = function () {
                        return a.authStep = h.ERROR, a._credentials = null, a.onAuthStepChange.dispatch(a), s();
                    }, n = null, s = function () {
                        var t;
                        if (n !== a.authStep && (n = a.authStep, a._driver && a._driver.onAuthStepChange))
                            return a._driver.onAuthStepChange(a, s), void 0;
                        switch (a.authStep) {
                        case h.RESET:
                            return r ? (a._driver.getStateParam && a._driver.getStateParam(function (t) {
                                return a.client.authStep === h.RESET && a._oauth.setAuthStateParam(t), o();
                            }), a._oauth.setAuthStateParam(D.Util.Oauth.randomAuthStateParam()), o()) : (e && e(null, a), void 0);
                        case h.PARAM_SET:
                            return r ? (t = a.authorizeUrl(), a._driver.doAuthorize(t, a._oauth.authStateParam(), a, function (t) {
                                return a._oauth.processRedirectParams(t), t.uid && (a._uid = t.uid), o();
                            })) : (e && e(null, a), void 0);
                        case h.PARAM_LOADED:
                            return a._driver.resumeAuthorize ? a._driver.resumeAuthorize(a._oauth.authStateParam(), a, function (t) {
                                return a._oauth.processRedirectParams(t), t.uid && (a._uid = t.uid), o();
                            }) : (a._oauth.setAuthStateParam(a._oauth.authStateParam()), o(), void 0);
                        case h.AUTHORIZED:
                            return a.getAccessToken(function (t, e) {
                                return t ? (a.authError = t, i()) : (a._oauth.processRedirectParams(e), a._uid = e.uid, o());
                            });
                        case h.DONE:
                            e && e(null, a);
                            break;
                        case h.SIGNED_OUT:
                            return a.authStep = h.RESET, a.reset(), s();
                        case h.ERROR:
                            e && e(a.authError, a);
                        }
                    }, s(), this;
                }, t.prototype.isAuthenticated = function () {
                    return this.authStep === h.DONE;
                }, t.prototype.signOut = function (t, e) {
                    var r, n, i = this;
                    if (e || 'function' != typeof t || (e = t, t = null), r = t && t.mustInvalidate, this.authStep !== h.DONE)
                        throw new Error('This client doesn\'t have a user\'s token');
                    return n = new D.Util.Xhr('POST', this._urls.signOut), n.signWithOauth(this._oauth), this._dispatchXhr(n, function (t) {
                        if (t)
                            if (t.status === D.ApiError.INVALID_TOKEN)
                                t = null;
                            else if (r)
                                return e && e(t), void 0;
                        return i.authStep = h.RESET, i.reset(), i.authStep = h.SIGNED_OUT, i.onAuthStepChange.dispatch(i), i._driver && i._driver.onAuthStepChange ? i._driver.onAuthStepChange(i, function () {
                            return e ? e(null) : void 0;
                        }) : e ? e(null) : void 0;
                    });
                }, t.prototype.signOff = function (t, e) {
                    return this.signOut(t, e);
                }, t.prototype.getAccountInfo = function (t, e) {
                    var r, n;
                    return e || 'function' != typeof t || (e = t, t = null), r = !1, t && t.httpCache && (r = !0), n = new D.Util.Xhr('GET', this._urls.accountInfo), n.signWithOauth(this._oauth, r), this._dispatchXhr(n, function (t, r) {
                        return e(t, D.AccountInfo.parse(r), r);
                    });
                }, t.prototype.getUserInfo = function (t, e) {
                    return this.getAccountInfo(t, e);
                }, t.prototype.readFile = function (t, e, r) {
                    var n, i, o, s, a, u, l;
                    return r || 'function' != typeof e || (r = e, e = null), i = {}, u = 'text', s = null, n = !1, e && (e.versionTag ? i.rev = e.versionTag : e.rev && (i.rev = e.rev), e.arrayBuffer ? u = 'arraybuffer' : e.blob ? u = 'blob' : e.buffer ? u = 'buffer' : e.binary && (u = 'b'), e.length ? (null != e.start ? (a = e.start, o = e.start + e.length - 1) : (a = '', o = e.length), s = 'bytes=' + a + '-' + o) : null != e.start && (s = 'bytes=' + e.start + '-'), e.httpCache && (n = !0)), l = new D.Util.Xhr('GET', '' + this._urls.getFile + '/' + this._urlEncodePath(t)), l.setParams(i).signWithOauth(this._oauth, n), l.setResponseType(u), s && (s && l.setHeader('Range', s), l.reportResponseHeaders()), this._dispatchXhr(l, function (t, e, n, i) {
                        var o;
                        return o = i ? D.Http.RangeInfo.parse(i['content-range']) : null, r(t, e, D.File.Stat.parse(n), o);
                    });
                }, t.prototype.writeFile = function (t, e, r, n) {
                    var i;
                    return n || 'function' != typeof r || (n = r, r = null), i = D.Util.Xhr.canSendForms && 'object' == typeof e, i ? this._writeFileUsingForm(t, e, r, n) : this._writeFileUsingPut(t, e, r, n);
                }, t.prototype._writeFileUsingForm = function (t, e, r, n) {
                    var i, o, s, a;
                    return s = t.lastIndexOf('/'), -1 === s ? (i = t, t = '') : (i = t.substring(s), t = t.substring(0, s)), o = { file: i }, r && (r.noOverwrite && (o.overwrite = 'false'), r.lastVersionTag ? o.parent_rev = r.lastVersionTag : (r.parentRev || r.parent_rev) && (o.parent_rev = r.parentRev || r.parent_rev)), a = new D.Util.Xhr('POST', '' + this._urls.postFile + '/' + this._urlEncodePath(t)), a.setParams(o).signWithOauth(this._oauth).setFileField('file', i, e, 'application/octet-stream'), delete o.file, this._dispatchXhr(a, function (t, e) {
                        return n ? n(t, D.File.Stat.parse(e)) : void 0;
                    });
                }, t.prototype._writeFileUsingPut = function (t, e, r, n) {
                    var i, o;
                    return i = {}, r && (r.noOverwrite && (i.overwrite = 'false'), r.lastVersionTag ? i.parent_rev = r.lastVersionTag : (r.parentRev || r.parent_rev) && (i.parent_rev = r.parentRev || r.parent_rev)), o = new D.Util.Xhr('POST', '' + this._urls.putFile + '/' + this._urlEncodePath(t)), o.setBody(e).setParams(i).signWithOauth(this._oauth), this._dispatchXhr(o, function (t, e) {
                        return n ? n(t, D.File.Stat.parse(e)) : void 0;
                    });
                }, t.prototype.resumableUploadStep = function (t, e, r) {
                    var n, i;
                    return e ? (n = { offset: e.offset }, e.tag && (n.upload_id = e.tag)) : n = { offset: 0 }, i = new D.Util.Xhr('POST', this._urls.chunkedUpload), i.setBody(t).setParams(n).signWithOauth(this._oauth), this._dispatchXhr(i, function (t, e) {
                        return t && t.status === D.ApiError.INVALID_PARAM && t.response && t.response.upload_id && t.response.offset ? r(null, D.Http.UploadCursor.parse(t.response)) : r(t, D.Http.UploadCursor.parse(e));
                    });
                }, t.prototype.resumableUploadFinish = function (t, e, r, n) {
                    var i, o;
                    return n || 'function' != typeof r || (n = r, r = null), i = { upload_id: e.tag }, r && (r.lastVersionTag ? i.parent_rev = r.lastVersionTag : (r.parentRev || r.parent_rev) && (i.parent_rev = r.parentRev || r.parent_rev), r.noOverwrite && (i.overwrite = 'false')), o = new D.Util.Xhr('POST', '' + this._urls.commitChunkedUpload + '/' + this._urlEncodePath(t)), o.setParams(i).signWithOauth(this._oauth), this._dispatchXhr(o, function (t, e) {
                        return n ? n(t, D.File.Stat.parse(e)) : void 0;
                    });
                }, t.prototype.stat = function (t, e, r) {
                    var n, i, o;
                    return r || 'function' != typeof e || (r = e, e = null), i = {}, n = !1, e && (e.versionTag ? i.rev = e.versionTag : e.rev && (i.rev = e.rev), e.contentHash ? i.hash = e.contentHash : e.hash && (i.hash = e.hash), (e.removed || e.deleted) && (i.include_deleted = 'true'), e.readDir && (i.list = 'true', e.readDir !== !0 && (i.file_limit = e.readDir.toString())), e.cacheHash && (i.hash = e.cacheHash), e.httpCache && (n = !0)), i.include_deleted || (i.include_deleted = 'false'), i.list || (i.list = 'false'), o = new D.Util.Xhr('GET', '' + this._urls.metadata + '/' + this._urlEncodePath(t)), o.setParams(i).signWithOauth(this._oauth, n), this._dispatchXhr(o, function (t, e) {
                        var n, i, o;
                        return o = D.File.Stat.parse(e), n = (null != e ? e.contents : void 0) ? function () {
                            var t, r, n, o;
                            for (n = e.contents, o = [], t = 0, r = n.length; r > t; t++)
                                i = n[t], o.push(D.File.Stat.parse(i));
                            return o;
                        }() : void 0, r(t, o, n);
                    });
                }, t.prototype.readdir = function (t, e, r) {
                    var n;
                    return r || 'function' != typeof e || (r = e, e = null), n = { readDir: !0 }, e && (null != e.limit && (n.readDir = e.limit), e.versionTag ? n.versionTag = e.versionTag : e.rev && (n.versionTag = e.rev), e.contentHash ? n.contentHash = e.contentHash : e.hash && (n.contentHash = e.hash), (e.removed || e.deleted) && (n.removed = e.removed || e.deleted), e.httpCache && (n.httpCache = e.httpCache)), this.stat(t, n, function (t, e, n) {
                        var i, o;
                        return i = n ? function () {
                            var t, e, r;
                            for (r = [], t = 0, e = n.length; e > t; t++)
                                o = n[t], r.push(o.name);
                            return r;
                        }() : null, r(t, i, e, n);
                    });
                }, t.prototype.metadata = function (t, e, r) {
                    return this.stat(t, e, r);
                }, t.prototype.makeUrl = function (t, e, r) {
                    var n, i, o, s, a, u = this;
                    return r || 'function' != typeof e || (r = e, e = null), i = e && (e['long'] || e.longUrl || e.downloadHack) ? { short_url: 'false' } : {}, t = this._urlEncodePath(t), o = '' + this._urls.shares + '/' + t, n = !1, s = !1, e && (e.downloadHack ? (n = !0, s = !0) : e.download && (n = !0, o = '' + this._urls.media + '/' + t)), a = new D.Util.Xhr('POST', o).setParams(i).signWithOauth(this._oauth), this._dispatchXhr(a, function (t, e) {
                        return s && (null != e ? e.url : void 0) && (e.url = e.url.replace(u._authServer, u._downloadServer)), r(t, D.File.ShareUrl.parse(e, n));
                    });
                }, t.prototype.history = function (t, e, r) {
                    var n, i, o;
                    return r || 'function' != typeof e || (r = e, e = null), i = {}, n = !1, e && (null != e.limit && (i.rev_limit = e.limit), e.httpCache && (n = !0)), o = new D.Util.Xhr('GET', '' + this._urls.revisions + '/' + this._urlEncodePath(t)), o.setParams(i).signWithOauth(this._oauth, n), this._dispatchXhr(o, function (t, e) {
                        var n, i;
                        return i = e ? function () {
                            var t, r, i;
                            for (i = [], t = 0, r = e.length; r > t; t++)
                                n = e[t], i.push(D.File.Stat.parse(n));
                            return i;
                        }() : void 0, r(t, i);
                    });
                }, t.prototype.revisions = function (t, e, r) {
                    return this.history(t, e, r);
                }, t.prototype.thumbnailUrl = function (t, e) {
                    var r;
                    return r = this.thumbnailXhr(t, e), r.paramsToUrl().url;
                }, t.prototype.readThumbnail = function (t, e, r) {
                    var n, i;
                    return r || 'function' != typeof e || (r = e, e = null), n = 'b', e && (e.blob && (n = 'blob'), e.arrayBuffer && (n = 'arraybuffer'), e.buffer && (n = 'buffer')), i = this.thumbnailXhr(t, e), i.setResponseType(n), this._dispatchXhr(i, function (t, e, n) {
                        return r(t, e, D.File.Stat.parse(n));
                    });
                }, t.prototype.thumbnailXhr = function (t, e) {
                    var r, n;
                    return r = {}, e && (e.format ? r.format = e.format : e.png && (r.format = 'png'), e.size && (r.size = e.size)), n = new D.Util.Xhr('GET', '' + this._urls.thumbnails + '/' + this._urlEncodePath(t)), n.setParams(r).signWithOauth(this._oauth);
                }, t.prototype.revertFile = function (t, e, r) {
                    var n;
                    return n = new D.Util.Xhr('POST', '' + this._urls.restore + '/' + this._urlEncodePath(t)), n.setParams({ rev: e }).signWithOauth(this._oauth), this._dispatchXhr(n, function (t, e) {
                        return r ? r(t, D.File.Stat.parse(e)) : void 0;
                    });
                }, t.prototype.restore = function (t, e, r) {
                    return this.revertFile(t, e, r);
                }, t.prototype.findByName = function (t, e, r, n) {
                    var i, o, s;
                    return n || 'function' != typeof r || (n = r, r = null), o = { query: e }, i = !1, r && (null != r.limit && (o.file_limit = r.limit), (r.removed || r.deleted) && (o.include_deleted = !0), r.httpCache && (i = !0)), s = new D.Util.Xhr('GET', '' + this._urls.search + '/' + this._urlEncodePath(t)), s.setParams(o).signWithOauth(this._oauth, i), this._dispatchXhr(s, function (t, e) {
                        var r, i;
                        return i = e ? function () {
                            var t, n, i;
                            for (i = [], t = 0, n = e.length; n > t; t++)
                                r = e[t], i.push(D.File.Stat.parse(r));
                            return i;
                        }() : void 0, n(t, i);
                    });
                }, t.prototype.search = function (t, e, r, n) {
                    return this.findByName(t, e, r, n);
                }, t.prototype.makeCopyReference = function (t, e) {
                    var r;
                    return r = new D.Util.Xhr('GET', '' + this._urls.copyRef + '/' + this._urlEncodePath(t)), r.signWithOauth(this._oauth), this._dispatchXhr(r, function (t, r) {
                        return e(t, D.File.CopyReference.parse(r));
                    });
                }, t.prototype.copyRef = function (t, e) {
                    return this.makeCopyReference(t, e);
                }, t.prototype.pullChanges = function (t, e) {
                    var r, n;
                    return e || 'function' != typeof t || (e = t, t = null), r = t ? t.cursorTag ? { cursor: t.cursorTag } : { cursor: t } : {}, n = new D.Util.Xhr('POST', this._urls.delta), n.setParams(r).signWithOauth(this._oauth), this._dispatchXhr(n, function (t, r) {
                        return e(t, D.Http.PulledChanges.parse(r));
                    });
                }, t.prototype.delta = function (t, e) {
                    return this.pullChanges(t, e);
                }, t.prototype.pollForChanges = function (t, e, r) {
                    var n, i;
                    return r || 'function' != typeof e || (r = e, e = null), n = t.cursorTag ? { cursor: t.cursorTag } : { cursor: t }, e && 'timeout' in e && (n.timeout = e.timeout), i = new D.Util.Xhr('GET', this._urls.longpollDelta), i.setParams(n), this._dispatchXhr(i, function (t, e) {
                        var n;
                        if ('string' == typeof e)
                            try {
                                e = JSON.parse(e);
                            } catch (i) {
                                n = i, e = null;
                            }
                        return r(t, D.Http.PollResult.parse(e));
                    });
                }, t.prototype.mkdir = function (t, e) {
                    var r;
                    return r = new D.Util.Xhr('POST', this._urls.fileopsCreateFolder), r.setParams({
                        root: 'auto',
                        path: this._normalizePath(t)
                    }).signWithOauth(this._oauth), this._dispatchXhr(r, function (t, r) {
                        return e ? e(t, D.File.Stat.parse(r)) : void 0;
                    });
                }, t.prototype.remove = function (t, e) {
                    var r;
                    return r = new D.Util.Xhr('POST', this._urls.fileopsDelete), r.setParams({
                        root: 'auto',
                        path: this._normalizePath(t)
                    }).signWithOauth(this._oauth), this._dispatchXhr(r, function (t, r) {
                        return e ? e(t, D.File.Stat.parse(r)) : void 0;
                    });
                }, t.prototype.unlink = function (t, e) {
                    return this.remove(t, e);
                }, t.prototype['delete'] = function (t, e) {
                    return this.remove(t, e);
                }, t.prototype.copy = function (t, e, r) {
                    var n, i;
                    return n = {
                        root: 'auto',
                        to_path: this._normalizePath(e)
                    }, t instanceof D.File.CopyReference ? n.from_copy_ref = t.tag : n.from_path = this._normalizePath(t), i = new D.Util.Xhr('POST', this._urls.fileopsCopy), i.setParams(n).signWithOauth(this._oauth), this._dispatchXhr(i, function (t, e) {
                        return r ? r(t, D.File.Stat.parse(e)) : void 0;
                    });
                }, t.prototype.move = function (t, e, r) {
                    var n;
                    return n = new D.Util.Xhr('POST', this._urls.fileopsMove), n.setParams({
                        root: 'auto',
                        from_path: this._normalizePath(t),
                        to_path: this._normalizePath(e)
                    }).signWithOauth(this._oauth), this._dispatchXhr(n, function (t, e) {
                        return r ? r(t, D.File.Stat.parse(e)) : void 0;
                    });
                }, t.prototype.appInfo = function (t, e) {
                    var r;
                    return e || 'function' != typeof t || (e = t, t = this._oauth.credentials().key), r = new D.Util.Xhr('GET', this._urls.appsInfo), r.setParams({ app_key: t }), this._dispatchXhr(r, function (r, n) {
                        return e(r, D.Http.AppInfo.parse(n, t));
                    });
                }, t.prototype.isAppDeveloper = function (t, e, r) {
                    var n;
                    return 'object' == typeof t && 'uid' in t && (t = t.uid), r || 'function' != typeof e ? 'object' == typeof e && 'key' in e && (e = e.key) : (r = e, e = this._oauth.credentials().key), n = new D.Util.Xhr('GET', this._urls.appsCheckDeveloper), n.setParams({
                        app_key: e,
                        uid: t
                    }), this._dispatchXhr(n, function (t, e) {
                        return e ? r(t, e.is_developer) : r(t);
                    });
                }, t.prototype.hasOauthRedirectUri = function (t, e, r) {
                    var n;
                    return r || 'function' != typeof e ? 'object' == typeof e && 'key' in e && (e = e.key) : (r = e, e = this._oauth.credentials().key), n = new D.Util.Xhr('GET', this._urls.appsCheckRedirectUri), n.setParams({
                        app_key: e,
                        redirect_uri: t
                    }), this._dispatchXhr(n, function (t, e) {
                        return e ? r(t, e.has_redirect_uri) : r(t);
                    });
                }, t.prototype.reset = function () {
                    var t;
                    return this._uid = null, this._oauth.reset(), t = this.authStep, this.authStep = this._oauth.step(), t !== this.authStep && this.onAuthStepChange.dispatch(this), this.authError = null, this._credentials = null, this;
                }, t.prototype.setCredentials = function (t) {
                    var e;
                    return e = this.authStep, this._oauth.setCredentials(t), this.authStep = this._oauth.step(), this._uid = t.uid || null, this.authError = null, this._credentials = null, e !== this.authStep && this.onAuthStepChange.dispatch(this), this;
                }, t.prototype.appHash = function () {
                    return this._oauth.appHash();
                }, t.prototype.setupUrls = function () {
                    return this._apiServer = this._chooseApiServer(), this._urls = {
                        authorize: '' + this._authServer + '/1/oauth2/authorize',
                        token: '' + this._apiServer + '/1/oauth2/token',
                        signOut: '' + this._apiServer + '/1/unlink_access_token',
                        accountInfo: '' + this._apiServer + '/1/account/info',
                        getFile: '' + this._fileServer + '/1/files/auto',
                        postFile: '' + this._fileServer + '/1/files/auto',
                        putFile: '' + this._fileServer + '/1/files_put/auto',
                        metadata: '' + this._apiServer + '/1/metadata/auto',
                        delta: '' + this._apiServer + '/1/delta',
                        longpollDelta: '' + this._notifyServer + '/1/longpoll_delta',
                        revisions: '' + this._apiServer + '/1/revisions/auto',
                        restore: '' + this._apiServer + '/1/restore/auto',
                        search: '' + this._apiServer + '/1/search/auto',
                        shares: '' + this._apiServer + '/1/shares/auto',
                        media: '' + this._apiServer + '/1/media/auto',
                        copyRef: '' + this._apiServer + '/1/copy_ref/auto',
                        thumbnails: '' + this._fileServer + '/1/thumbnails/auto',
                        chunkedUpload: '' + this._fileServer + '/1/chunked_upload',
                        commitChunkedUpload: '' + this._fileServer + '/1/commit_chunked_upload/auto',
                        fileopsCopy: '' + this._apiServer + '/1/fileops/copy',
                        fileopsCreateFolder: '' + this._apiServer + '/1/fileops/create_folder',
                        fileopsDelete: '' + this._apiServer + '/1/fileops/delete',
                        fileopsMove: '' + this._apiServer + '/1/fileops/move',
                        appsInfo: '' + this._apiServer + '/1/apps/info',
                        appsCheckDeveloper: '' + this._apiServer + '/1/apps/check_developer',
                        appsCheckRedirectUri: '' + this._apiServer + '/1/apps/check_redirect_uri',
                        getDb: '' + this._apiServer + '/1/datastores/get_datastore',
                        getOrCreateDb: '' + this._apiServer + '/1/datastores/get_or_create_datastore',
                        createDb: '' + this._apiServer + '/1/datastores/create_datastore',
                        listDbs: '' + this._apiServer + '/1/datastores/list_datastores',
                        deleteDb: '' + this._apiServer + '/1/datastores/delete_datastore',
                        getSnapshot: '' + this._apiServer + '/1/datastores/get_snapshot',
                        getDeltas: '' + this._apiServer + '/1/datastores/get_deltas',
                        putDelta: '' + this._apiServer + '/1/datastores/put_delta',
                        datastoreAwait: '' + this._apiServer + '/1/datastores/await'
                    }, this;
                }, t.prototype._chooseApiServer = function () {
                    var t, e;
                    return e = Math.floor(Math.random() * (this._maxApiServer + 1)), t = 0 === e ? '' : e.toString(), this._serverRoot.replace('$', t);
                }, t.prototype.authStep = null, t.ERROR = 0, t.RESET = 1, t.PARAM_SET = 2, t.PARAM_LOADED = 3, t.AUTHORIZED = 4, t.DONE = 5, t.SIGNED_OUT = 6, t.prototype._urlEncodePath = function (t) {
                    return D.Util.Xhr.urlEncodeValue(this._normalizePath(t)).replace(/%2F/gi, '/');
                }, t.prototype._normalizePath = function (t) {
                    var e;
                    if ('/' === t.substring(0, 1)) {
                        for (e = 1; '/' === t.substring(e, e + 1);)
                            e += 1;
                        return t.substring(e);
                    }
                    return t;
                }, t.prototype.authorizeUrl = function () {
                    var t;
                    return t = this._oauth.authorizeUrlParams(this._driver.authType(), this._driver.url()), this._urls.authorize + '?' + D.Util.Xhr.urlEncode(t);
                }, t.prototype.getAccessToken = function (t) {
                    var e, r;
                    return e = this._oauth.accessTokenParams(this._driver.url()), r = new D.Util.Xhr('POST', this._urls.token).setParams(e).addOauthParams(this._oauth), this._dispatchXhr(r, function (e, r) {
                        return e && e.status === D.ApiError.INVALID_PARAM && e.response && e.response.error && (e = new D.AuthError(e.response)), t(e, r);
                    });
                }, t.prototype._dispatchLongPollXhr = function (t, e, r) {
                    return null == r && (r = 60000), this._dispatchXhr(t, e, r);
                }, t.prototype._dispatchXhr = function (t, e, r) {
                    var n, i, o = this;
                    return null == r && (r = 10000), n = setTimeout(function () {
                        return o._handleLongRequest(t);
                    }, 2 * r), t.setCallback(function (t, r, i, o) {
                        return clearTimeout(n), e(t, r, i, o);
                    }), t.onError = this._xhrOnErrorHandler, t.prepare(), i = t.xhr, this.onXhr.dispatch(t) && t.send(), i;
                }, t.prototype._handleXhrError = function (t, e) {
                    var r = this;
                    return t.status === D.ApiError.INVALID_TOKEN && this.authStep === h.DONE && (this.authError = t, this.authStep = h.ERROR, this.onAuthStepChange.dispatch(this), this._driver && this._driver.onAuthStepChange) ? (this._driver.onAuthStepChange(this, function () {
                        return r.onError.dispatch(t), e(t);
                    }), null) : (this.onError.dispatch(t), e(t), void 0);
                }, t.prototype._handleLongRequest = function () {
                    return this.setupUrls();
                }, t.prototype._defaultServerRoot = function () {
                    return 'https://api$.dropbox.com';
                }, t.prototype._defaultAuthServer = function () {
                    return this._serverRoot.replace('api$', 'www');
                }, t.prototype._defaultFileServer = function () {
                    return this._serverRoot.replace('api$', 'api-content');
                }, t.prototype._defaultDownloadServer = function () {
                    return 'https://dl.dropboxusercontent.com';
                }, t.prototype._defaultNotifyServer = function () {
                    return this._serverRoot.replace('api$', 'api-notify');
                }, t.prototype._defaultMaxApiServer = function () {
                    return 30;
                }, t.prototype._computeCredentials = function () {
                    var t;
                    t = this._oauth.credentials(), this._uid && (t.uid = this._uid), this._serverRoot !== this._defaultServerRoot() && (t.server = this._serverRoot), this._maxApiServer !== this._defaultMaxApiServer() && (t.maxApiServer = this._maxApiServer), this._authServer !== this._defaultAuthServer() && (t.authServer = this._authServer), this._fileServer !== this._defaultFileServer() && (t.fileServer = this._fileServer), this._downloadServer !== this._defaultDownloadServer() && (t.downloadServer = this._downloadServer), this._notifyServer !== this._defaultNotifyServer() && (t.notifyServer = this._notifyServer), this._credentials = t;
                }, t;
            }(), h = D.Client, D.Datastore = function () {
                function t(t, e) {
                    var r = this;
                    this._datastore_manager = t, this._managed_datastore = e, this._dsid = this._managed_datastore.get_dsid(), this._handle = this._managed_datastore.get_handle(), this._record_cache = new H(this), this._last_used_timestamp = 0, this.recordsChanged = new D.Util.EventSource(), this.syncStatusChanged = new D.Util.EventSource(), this._timeoutWrapper = function (t) {
                        return t;
                    }, this._evt_mgr = new E(), this._evt_mgr.register(this._managed_datastore.syncStateChanged, function () {
                        return r._syncSoon(), r.syncStatusChanged.dispatch(null);
                    }), this._syncPending = !1, this._closed = !1, this._metadata_table = new D.Datastore.Table(this, ':info'), this._metadata_table.setResolutionRule('mtime', 'max');
                }
                return t.DATASTORE_SIZE_LIMIT = 10485760, t.RECORD_COUNT_LIMIT = 100000, t.BASE_DATASTORE_SIZE = 1000, t.prototype.recordsChanged = null, t.prototype.syncStatusChanged = null, t.int64 = function (t) {
                    var e, r;
                    if (Z.is_number(t) && null != t[te.INT64_TAG])
                        return te.validateInt64(t);
                    if (Z.is_string(t)) {
                        if (!te.is_valid_int64_string(t))
                            throw new Error('Not a valid int64 in string form: ' + t);
                        return r = new Number(parseInt(t, 10)), r[te.INT64_TAG] = t, te.validateInt64(r);
                    }
                    if (!Z.is_number(t) || !isFinite(t))
                        throw new Error('Not a finite number: ' + t);
                    if (Number(t) !== Math.round(t))
                        throw new Error('Number is not an integer: ' + t);
                    if (e = t.toFixed(), !te.is_valid_int64_string(e))
                        throw new Error('Number not in int64 range: ' + t);
                    return r = new Number(t), r[te.INT64_TAG] = e, te.validateInt64(r);
                }, t.isInt64 = function (t) {
                    return te.isInt64(t);
                }, t.prototype.getModifiedTime = function () {
                    var t;
                    return t = this._metadata_table.getOrInsert('info', {}), t.get('mtime');
                }, t.prototype.getTitle = function () {
                    var t;
                    return t = this._metadata_table.getOrInsert('info', {}), t.get('title');
                }, t.prototype.setTitle = function (t) {
                    var e;
                    if (null != t && !Z.string(t))
                        throw new Error('Title must be a string or null!');
                    return e = this._metadata_table.getOrInsert('info', {}), e.set('title', t);
                }, t.prototype.getTable = function (t) {
                    if (this._checkNotClosed(), !D.Datastore.Table.isValidId(t))
                        throw new Error('Invalid table ID: ' + t);
                    return new D.Datastore.Table(this, t);
                }, t.prototype.listTableIds = function () {
                    return this._checkNotClosed(), this._managed_datastore.list_tables();
                }, t.prototype.getRecordCount = function () {
                    return this._managed_datastore.get_record_count();
                }, t.prototype.getSize = function () {
                    return this._managed_datastore.get_size();
                }, t.prototype.toString = function () {
                    var t;
                    return t = this._closed ? '[closed] ' : '', 'Datastore(' + t + this._dsid + ' [' + this._handle + '])';
                }, t.prototype.close = function () {
                    return this._closed = !0, this._evt_mgr.unregister_all(), this._listeners = [], this._datastore_manager._obj_manager.close(this._dsid), void 0;
                }, t.prototype.getId = function () {
                    return this._dsid;
                }, t.prototype.getSyncStatus = function () {
                    return { uploading: this._managed_datastore.get_outgoing_delta_count() > 0 };
                }, t.isValidId = function (t) {
                    var e;
                    return e = new RegExp(Z.DS_ID_REGEX), Z.is_string(t) && e.test(t);
                }, t.prototype._generateRid = function () {
                    var t, e, r, n;
                    for (n = '_', e = '_js_', r = Math.round(1000 * Date.now()), r <= this._last_used_timestamp && (r = this._last_used_timestamp + 1), this._last_used_timestamp = r, t = r.toString(32); t.length < 11;)
                        t = '0' + t;
                    return n + t + e + te.randomWeb64String(5);
                }, t.prototype._syncSoon = function () {
                    var t = this;
                    if (this._managed_datastore.is_deleted())
                        throw new Error('Cannot sync deleted datastore ' + this._dsid);
                    return this._checkNotClosed(), this._syncPending || (this._syncPending = !0, setTimeout(this._timeoutWrapper(function () {
                        return t._syncPending = !1, t._sync();
                    }), 0)), void 0;
                }, t.prototype._sync = function () {
                    var t, e, r, n, i, o, s, a, u;
                    this._checkNotClosed(), i = this._managed_datastore.sync(), n = this._resolveAffectedRecordMap(i), t = !1;
                    for (s in n)
                        for (r = n[s], a = 0, u = r.length; u > a; a++)
                            e = r[a], Y(s === e._tid, 'tid mismatch'), t = !0, o = e._rid, this._managed_datastore.query(s, o) || (e._deleted = !0, this._record_cache.remove(s, o));
                    return t && this.recordsChanged.dispatch(new V(n, !1)), void 0;
                }, t.prototype._resolveAffectedRecordMap = function (t) {
                    var e, r, n, i, o;
                    r = {};
                    for (o in t) {
                        i = t[o];
                        for (n in i)
                            e = this._record_cache.getOrCreate(o, n), null == r[o] && (r[o] = []), r[o].push(e);
                    }
                    return r;
                }, t.prototype._recordsChangedLocally = function (t) {
                    return t.length > 0 && (this.recordsChanged.dispatch(V._fromRecordList(t, !0)), this._syncSoon()), void 0;
                }, t.prototype._checkNotClosed = function () {
                    if (this._closed || !this._managed_datastore._open)
                        throw new Error('Datastore is already closed: ' + this);
                    return void 0;
                }, t;
            }(), te = D.Datastore.impl = {}, Z = D.Datastore.impl.T = {}, Z.identity = function (t) {
                return t;
            }, Z.get_coerce_fn = function (t) {
                return null != t.coerce ? t.coerce : null != t.load_json ? function (e) {
                    return e instanceof t ? e : t.load_json(e);
                } : Z.identity;
            }, Z.get_T_fn = function (t) {
                return null != t.Type ? t.Type : t;
            }, Z.str = function (t) {
                return Z.is_string(t) ? t : Z.is_function(t) ? t() : JSON.stringify(t);
            }, Z.assert = function (t, e) {
                if (!t)
                    throw new Error(Z.str(e));
            }, Y = Z.assert, Z.check = function (t, e, r, n, i, o) {
                if (t)
                    return r;
                throw Z.fail(e, r, n, i, o), new Error('unreachable');
            }, Z.safe_to_string = function (t) {
                var e, r;
                try {
                    if (r = t.toString(), '[object Object]' !== r)
                        return r;
                } catch (n) {
                    e = n;
                }
                try {
                    return JSON.stringify(t);
                } catch (n) {
                    e = n;
                }
                try {
                    if (r = t.constructor.name, null != r ? r.match(/^[A-Za-z0-9_]+$/) : void 0)
                        return r;
                } catch (n) {
                    e = n;
                }
                return '[T.safe_to_string failed]';
            }, Z.fail = function (t, e, r, n, i) {
                var o, s;
                throw s = null != r ? null != n ? null != i ? 'Wanted ' + Z.str(n) + ', but ' + Z.str(r) + ' in ' + Z.str(i) + ' ' + Z.str(t) : 'Wanted ' + Z.str(n) + ', but ' + Z.str(r) + ' ' + Z.str(t) : '' + Z.str(r) + ' ' + Z.str(t) : null != n ? null != i ? 'Wanted ' + Z.str(n) + ', but in ' + Z.str(i) + ' ' + Z.str(t) : 'Wanted ' + Z.str(n) + ', but ' + Z.str(t) : '' + Z.str(t), o = new Error('' + s + ': ' + Z.safe_to_string(e)), console.error(o), o;
            }, Z.any = function (t) {
                return t;
            }, Z.defined = function (t, e, r, n) {
                return null == r && (r = 'defined'), Z.check('undefined' != typeof t, 'is undefined', t, e, r, n), t;
            }, Z.nonnull = function (t, e, r, n) {
                return null == r && (r = 'nonnull'), Z.defined(t, e, r, n), Z.check(null != t, 'is null', t, e, r, n), t;
            }, Z.member = function (t) {
                var e, r;
                return r = 'value in ' + JSON.stringify(t), e = 'not in ' + JSON.stringify(t), function (n, i, o, s) {
                    return null == o && (o = r), Z.check(ne.call(t, n) >= 0, e, n, i, o, s);
                };
            }, Z.object = function (t, e, r, n) {
                return null == r && (r = 'object'), Z.nonnull(t, e, r, n), Z.check('object' == typeof t, 'not an object', t, e, r, n), t;
            }, Z.bool = function (t, e, r, n) {
                return null == r && (r = 'bool'), Z.nonnull(t, e, r, n), Z.check(t === !0 || t === !1, 'is not bool', t, e, r, n), t;
            }, Z.string = function (t, e, r, n) {
                return null == r && (r = 'string'), Z.nonnull(t, e, r, n), Z.check(Z.is_string(t), 'is not a string', t, e, r, n), t;
            }, Z.num = function (t, e, r, n) {
                return null == r && (r = 'num'), Z.nonnull(t, e, r, n), Z.check('number' == typeof t, 'is not numeric', t, e, r, n), t;
            }, Z.int = function (t, e, r, n) {
                return null == r && (r = 'int'), Z.num(t, e, r, n), Z.check(0 === t % 1, 'is not an integer', t, e, r, n), t;
            }, Z.uint = function (t, e, r, n) {
                return null == r && (r = 'uint'), Z.int(t, e, r, n), Z.check(t >= 0, 'is negative', t, e, r, n), t;
            }, Z.nullable = function (t) {
                var e, r;
                return r = 'nullable(' + t + ')', e = function (e, n, i, o) {
                    return null == i && (i = function () {
                        return r;
                    }), Z.defined(e, n, i, o), null != e && Z.get_T_fn(t)(e, n, i, o), e;
                }, e.toString = function () {
                    return r;
                }, e.coerce = function (e) {
                    return null != e ? Z.get_coerce_fn(t)(e) : null;
                }, e.fromJSON = function (r) {
                    return null != r ? null != t.fromJSON ? t.fromJSON(r) : e.coerce(r) : null;
                }, e;
            }, Z.array = function (t, e, r, n) {
                return null == r && (r = 'array'), Z.nonnull(t, e, r, n), Z.check(Z.is_array(t), 'is not an array', t, e, r, n), t;
            }, Z.arrayOf = function (t) {
                var e, r;
                return r = 'arrayOf(' + t + ')', e = function (e, n, i, o) {
                    var s, a, u, l, h;
                    for (null == i && (i = r), Z.array(e, n, i, o), u = l = 0, h = e.length; h > l; u = ++l)
                        s = e[u], a = function () {
                            return null != n ? 'element ' + u + ' of ' + Z.str(n) : 'element ' + u;
                        }, Z.get_T_fn(t)(s, a, i, o);
                    return e;
                }, e.toString = function () {
                    return r;
                }, e.coerce = function (e) {
                    var n, i, o, s;
                    for (Z.array(e, null, r), s = [], i = 0, o = e.length; o > i; i++)
                        n = e[i], s.push(Z.get_coerce_fn(t)(n));
                    return s;
                }, e.fromJSON = function (n) {
                    var i, o, s, a;
                    if (Z.array(n, 'fromJSON input', r), null != t.fromJSON) {
                        for (a = [], o = 0, s = n.length; s > o; o++)
                            i = n[o], a.push(t.fromJSON(i));
                        return a;
                    }
                    return e.coerce(n);
                }, e;
            }, Z.instance = function (t, e, r, n, i) {
                var o;
                if (!(e instanceof Function))
                    throw new Error('Invalid type given: ' + e);
                return t instanceof e || (null == n && (n = e.name), Z.check(!1, 'got instance of ' + (null != t ? null != (o = t.constructor) ? o.name : void 0 : void 0), t, r, n, i)), t;
            }, Z.unimplemented = function (t) {
                return function () {
                    throw new Error('unimplemented ' + t);
                };
            }, Z.startsWith = function (t, e) {
                return 0 === t.lastIndexOf(e, 0);
            }, Z.string_matching = function (t) {
                var e;
                return Z.string(t), Z.check(/^[^].*[$]$/.test(t), 'does not start with ^ and end with $', t), e = 'does not match regex ' + t, function (r, n, i, o) {
                    return Z.string(r, n, i, o), Z.check(new RegExp(t).test(r), e, r, n, i, o), r;
                };
            }, Z.is_defined = function (t) {
                return 'undefined' != typeof t;
            }, Z.is_bool = function (t) {
                return t === !0 || t === !1 || t && 'object' == typeof t && t.constructor === Boolean;
            }, Z.is_number = function (t) {
                return 'number' == typeof t || t && 'object' == typeof t && t.constructor === Number;
            }, Z.is_json_number = function (t) {
                return Z.is_number(t) && !isNaN(t) && isFinite(t);
            }, Z.is_string = function (t) {
                return 'string' == typeof t || t && 'object' == typeof t && t.constructor === String;
            }, Z.is_function = function (t) {
                return 'function' == typeof t;
            }, Z.is_object = function (t) {
                return null != t && 'object' == typeof t;
            }, Z.is_array = function (t) {
                return '[object Array]' === Object.prototype.toString.call(t);
            }, Z.is_empty = function (t) {
                return 0 === Object.keys(t).length;
            }, Z.is_date = function (t) {
                return '[object Date]' === Object.prototype.toString.call(t);
            }, Z.isUint8Array = function (t) {
                return '[object Uint8Array]' === Object.prototype.toString.call(t);
            }, Z.is_simple_map = function (t) {
                var e, r;
                if (null == t || 'object' != typeof t)
                    return !1;
                for (e in t)
                    if (r = t[e], !Object.prototype.hasOwnProperty.call(t, e))
                        return !1;
                return !0;
            }, Z.simple_map = function (t, e, r, n) {
                var i, o;
                null == r && (r = 'simple map'), Z.object(t, e, r, n);
                for (i in t)
                    o = t[i], Z.check(Object.prototype.hasOwnProperty.call(t, i), function () {
                        return 'property ' + i + ' is inherited';
                    }, t, e, r, t);
                return t;
            }, Z.simple_typed_map = function (t, e, r) {
                var n, i, o;
                return n = Z.get_coerce_fn(e), i = Z.get_coerce_fn(r), o = function (n, i, o, s) {
                    var a, u;
                    null == o && (o = t), Z.simple_map(n, i, o, s);
                    for (a in n)
                        u = n[a], Z.get_T_fn(e)(a, 'property', null, n), Z.get_T_fn(r)(u, function () {
                            return 'value of property ' + a;
                        }, null, n);
                    return n;
                }, o.coerce = function (e) {
                    var r, o, s;
                    Z.simple_map(e, null, t), o = {};
                    for (r in e)
                        s = e[r], o[n(r)] = i(s);
                    return o;
                }, o.fromJSON = function (e) {
                    var i, o, s;
                    Z.simple_map(e, null, t), o = {};
                    for (i in e)
                        s = e[i], o[n(i)] = null != r.fromJSON ? r.fromJSON(s) : s;
                    return o;
                }, o;
            }, Z.DS_ID_REGEX = '^[-_a-z0-9]([-_a-z0-9.]{0,62}[-_a-z0-9])?$|^[.][-_a-zA-Z0-9]{1,63}$', Z.dsid = function (t, e, r, n) {
                return null == r && (r = 'dsid'), Z.string_matching(Z.DS_ID_REGEX)(t, e, r, n), t;
            }, Z.SS_ID_REGEX = '^[-._+/=a-zA-Z0-9]{1,64}$|^:[-._+/=a-zA-Z0-9]{1,63}$', Z.tid = function (t, e, r, n) {
                return null == r && (r = 'tid'), Z.string_matching(Z.SS_ID_REGEX)(t, e, r, n), t;
            }, Z.rowid = function (t, e, r, n) {
                return null == r && (r = 'rowid'), Z.string_matching(Z.SS_ID_REGEX)(t, e, r, n), t;
            }, Z.field_name = function (t, e, r, n) {
                return null == r && (r = 'field name'), Z.string_matching(Z.SS_ID_REGEX)(t, e, r, n), t;
            }, function () {
                var t, e, r;
                r = [];
                for (t in Z)
                    e = Z[t], Z.hasOwnProperty(t) ? r.push(function (t) {
                        return e.toString = function () {
                            return 'T.' + t;
                        };
                    }(t)) : r.push(void 0);
                return r;
            }(), te.struct = ee = {}, ee.define = function (t, e) {
                var r, n, i, o, s, a, u, l, h, c, d, p, _, f, g, y;
                for (Z.string(t, 'struct name'), Z.array(e, 'fields'), f = [], _ = {}, s = g = 0, y = e.length; y > g; s = ++g) {
                    i = e[s], Z.array(i, 'field', 'field descriptor', e), Z.check(2 <= i.length && i.length <= 3, 'does not have length 2 or 3', i, 'field descriptor'), c = Z.string(i[0], 'field name', 'field descriptor', e), p = Z.nonnull(i[1], 'field type', 'field descriptor', e), d = i.length <= 2 ? {} : Z.nonnull(i[2], 'map of field options', 'field descriptor', e);
                    for (l in d)
                        'init' !== l && 'initFn' !== l && Z.fail('unknown option ' + l, d, 'field options', 'field descrptor', e);
                    ne.call(d, 'init') >= 0 && ne.call(d, 'initFn') >= 0 && Z.fail('both \'init\' and \'initFn\' specified', d, 'field options', 'field descriptor', e), u = 'initFn' in d ? d.initFn : 'init' in d ? (a = d.init, function (t) {
                        return function () {
                            return t;
                        };
                    }(a)) : null, r = {
                        name: c,
                        type: p,
                        initFn: u
                    }, o = 'undefined' != typeof J && null !== J ? new J(r) : r, f.push(o), _[c] = o;
                }
                return h = 'initializer for ' + t + ' (fields ' + function () {
                    var t, e, r;
                    for (r = [], t = 0, e = f.length; e > t; t++)
                        i = f[t], r.push(i.name);
                    return r;
                }().join(', ') + ')', n = function (t) {
                    var e, r, i;
                    Z.defined(t, 'x', 'initializer');
                    for (c in t)
                        e = t[c], t.hasOwnProperty(c) && Z.check(null != _[c], function () {
                            return 'has an unexpected field ' + c;
                        }, t, 'initializer');
                    for (r = 0, i = f.length; i > r; r++)
                        o = f[r], t[o.name] && !t.hasOwnProperty(o.name) && Z.fail('Has an indirect property ' + o.name, t, 'initializer'), t.hasOwnProperty(o.name) ? (e = t[o.name], this[o.name] = Z.get_coerce_fn(o.type)(e)) : null != o.initFn ? this[o.name] = o.initFn() : Z.fail('lacks the field ' + o.name, t, 'initializer');
                    return n.Type(this, 'initializer', h, this), this;
                }, n.Type = function (e, r, i, s) {
                    var a, u, l;
                    for (Z.defined(e, r, i, s), Z.check(e instanceof n, function () {
                            return 'is not an instance of ' + t;
                        }, e, r, i, s), u = 0, l = f.length; l > u; u++)
                        o = f[u], Z.check(e.hasOwnProperty(o.name), function () {
                            return 'lacks the field ' + o.name;
                        }, e, r, i, s), Z.get_T_fn(o.type)(e[o.name], o.name, i, s);
                    for (c in e)
                        a = e[c], e.hasOwnProperty(c) && Z.check(null != _[c], 'has an unexpected field', c, r, i, s);
                    return e;
                }, n.coerce = function (t) {
                    return t instanceof n ? (n.Type(t), t) : new n(t);
                }, n.prototype.toString = function () {
                    var t, e, r, n, i;
                    for (e = this, t = [], n = 0, i = f.length; i > n; n++)
                        o = f[n], r = e[o.name], t.push('' + o.name + ': ' + (Z.is_object(r) && Z.is_function(r.toString) ? r.toString() : JSON.stringify(r)));
                    return '{' + t.join(', ') + '}';
                }, n.prototype.toJSON = function () {
                    var t, e, r, n;
                    for (t = this, e = function () {
                            return '' + t;
                        }, r = 0, n = f.length; n > r; r++)
                        o = f[r], Z.get_T_fn(o.type)(this[o.name], o.name, null, e);
                    return this;
                }, n.fromJSON = function (t) {
                    var e, r;
                    Z.simple_map(t, 'input'), e = {};
                    for (l in t)
                        r = t[l], o = _[l], null != o && (p = o.type, e[l] = null != p.fromJSON ? p.fromJSON(r) : r);
                    return new n(e);
                }, n.toString = function () {
                    return 'struct ' + t;
                }, n;
            }, J = ee.define('StructField', [
                [
                    'name',
                    Z.string
                ],
                [
                    'type',
                    Z.defined
                ],
                [
                    'initFn',
                    Z.defined
                ]
            ]), ee.toJSO = function (t) {
                var e, r, n, i;
                if ('object' != typeof t)
                    return t;
                if (Z.is_array(t))
                    return function () {
                        var r, n, i;
                        for (i = [], r = 0, n = t.length; n > r; r++)
                            e = t[r], i.push(ee.toJSO(e));
                        return i;
                    }();
                n = {};
                for (r in t)
                    i = t[r], t.hasOwnProperty(r) && (n[r] = ee.toJSO(i));
                return n;
            }, ee.union_as_list = function (t, e) {
                var r, n, i, o, s, a, u, l, h, c, d;
                for (Z.string(t, 'union name'), Z.array(e, 'variants'), n = function () {
                        throw new Error('Use ' + t + '.from_array instead');
                    }, l = {}, u = [], h = function (e, r, i) {
                        var o;
                        return o = ee.define('' + t + '.' + e, i), o.prototype.tag = function () {
                            return e;
                        }, o.prototype.toString = function () {
                            return '' + t + '.' + e + '(' + JSON.stringify(this) + ')';
                        }, o.prototype.toJSON = function () {
                            var t, n, i, o, s, a;
                            for (t = [e], s = 0, a = r.length; a > s; s++)
                                n = r[s], i = n[0], o = n[1], Z.get_T_fn(o)(this[i], i), t.push(this[i]);
                            return t;
                        }, o.from_array = function (n) {
                            var i, s, a, u, l, h, c;
                            for (l = 'initializer for ' + t, Z.array(n, 'initializer', l), Z.check(n.length === r.length + 1, 'does not have length ' + (r.length + 1), n, 'initializer', l), Z.check(n[0] === e, 'does not have tag ' + e, n, 'initializer', l), i = { _tag: e }, a = h = 0, c = r.length; c > h; a = ++h)
                                s = r[a], u = s[0], i[u] = n[a + 1];
                            return new o(i);
                        }, o.fromJSON = function (t) {
                            return t.length > r.length + 1 && (t = t.slice(0, r.length + 1)), o.from_array(t);
                        }, o.coerce = function (t) {
                            return t instanceof o ? (o.Type(t), t) : o.from_array(t);
                        }, l[e] = o, n[e] = o;
                    }, c = 0, d = e.length; d > c; c++)
                    i = e[c], Z.array(i, 'variant', 'variant descriptor', e), Z.check(2 === i.length, 'does not have length 2', i, 'variant descriptor', e), a = Z.string(i[0], 'tag', 'tag', e), o = Z.array(i[1], 'fields', 'variant descriptor', e), s = o.slice(0), s.unshift([
                        '_tag',
                        Z.member([a])
                    ]), h(a, o, s), u.push(a);
                return r = 'initializer for ' + t + ' (variants ' + u.join(', ') + ')', n.from_array = function (e) {
                    var r, n;
                    return n = 'initializer for ' + t, Z.array(e, 'initializer', n), Z.check(e.length >= 1, 'lacks a tag', e, 'initializer', n), r = e[0], Z.string(r, 'tag', n, e), Z.member(u)(r), l[r].from_array(e);
                }, n.fromJSON = function (e) {
                    var r, n;
                    return n = 'initializer for ' + t, Z.array(e, 'initializer', n), Z.check(e.length >= 1, 'lacks a tag', e, 'initializer', n), r = e[0], Z.string(r, 'tag', n, e), Z.member(u)(r), l[r].fromJSON(e);
                }, n.Type = function (e, r, n, i) {
                    var o;
                    return null == n && (n = '' + t + '.Type'), Z.defined(e, r, n, i), Z.defined(e.tag, 'tag', n, i), o = e.tag(), Z.string(o, 'tag', 'initializer', e), Z.member(u)(o), l[o].Type(e, null, 'object of type ' + t), e;
                }, n.coerce = function (t) {
                    var e, r;
                    for (r in l)
                        if (e = l[r], t instanceof e)
                            return e.Type(t), t;
                    return n.from_array(t);
                }, n.toString = function () {
                    return 'union ' + t;
                }, n;
            }, te.nonzero_int64_approximate_regex = new RegExp('^-?[1-9][0-9]{0,18}$'), te.int64_max_str = '9223372036854775807', te.int64_min_str = '-9223372036854775808', te.int64_string_less_than = function (t, e) {
                var r, n, i;
                return t === e ? !1 : (n = '0' === t.charAt(0), i = '0' === e.charAt(0), n && !i ? !0 : i && !n ? !1 : (r = t.length === e.length ? t > e : t.length > e.length, n && i ? r : !r));
            }, te.is_valid_int64_string = function (t) {
                return Z.is_string(t) ? '0' === t ? !0 : te.nonzero_int64_approximate_regex.test(t) ? '-' === t.charAt(0) ? t.length < te.int64_min_str.length || t <= te.int64_min_str : t.length < te.int64_max_str.length || t <= te.int64_max_str : !1 : !1;
            }, te.is_wrapped_atomic_field_value = function (t) {
                var e, r, n, i;
                if (!Z.is_simple_map(t))
                    return !1;
                if (e = Object.keys(t), 1 !== e.length)
                    return !1;
                switch (e[0]) {
                case 'B':
                    return Z.is_string(t.B);
                case 'N':
                    return 'nan' === (n = t.N) || '+inf' === n || '-inf' === n;
                case 'I':
                case 'T':
                    return r = null != (i = t.I) ? i : t.T, te.is_valid_int64_string(r);
                default:
                    return !1;
                }
            }, te.is_atomic_field_value = function (t) {
                return Z.is_bool(t) || Z.is_json_number(t) || Z.is_string(t) || te.is_wrapped_atomic_field_value(t);
            }, te.is_list_value = function (t) {
                var e, r, n;
                if (Z.is_array(t)) {
                    for (r = 0, n = t.length; n > r; r++)
                        if (e = t[r], !te.is_atomic_field_value(e))
                            return !1;
                    return !0;
                }
                return !1;
            }, te.is_compound_field_value = function (t) {
                return te.is_atomic_field_value(t) || te.is_list_value(t);
            }, te.atomic_field_value = function (t, e, r, n) {
                return null == r && (r = 'atomic field value'), Z.check(te.is_atomic_field_value(t), 'is not an atomic field value', t, e, r, n), t;
            }, te.list_value = function (t, e, r, n) {
                return null == r && (r = 'list value'), Z.arrayOf(te.atomic_field_value)(t, e, r, n), t;
            }, te.compound_field_value = function (t, e, r, n) {
                return null == r && (r = 'field value'), Z.is_array(t) ? te.list_value(t, e, r, n) : te.atomic_field_value(t, e, r, n);
            }, te.FieldOp = I = ee.union_as_list('FieldOp', [
                [
                    'P',
                    [[
                            'value',
                            te.compound_field_value
                        ]]
                ],
                [
                    'D',
                    []
                ],
                [
                    'LC',
                    []
                ],
                [
                    'LP',
                    [
                        [
                            'at',
                            Z.uint
                        ],
                        [
                            'value',
                            te.atomic_field_value
                        ]
                    ]
                ],
                [
                    'LI',
                    [
                        [
                            'before',
                            Z.uint
                        ],
                        [
                            'value',
                            te.atomic_field_value
                        ]
                    ]
                ],
                [
                    'LD',
                    [[
                            'at',
                            Z.uint
                        ]]
                ],
                [
                    'LM',
                    [
                        [
                            'from',
                            Z.uint
                        ],
                        [
                            'to',
                            Z.uint
                        ]
                    ]
                ]
            ]), te.datadict = Z.simple_typed_map('datadict', Z.field_name, te.compound_field_value), te.update_datadict = Z.simple_typed_map('update_datadict', Z.field_name, I), te.Change = n = ee.union_as_list('Change', [
                [
                    'I',
                    [
                        [
                            'tid',
                            Z.tid
                        ],
                        [
                            'rowid',
                            Z.rowid
                        ],
                        [
                            'fields',
                            te.datadict
                        ]
                    ]
                ],
                [
                    'U',
                    [
                        [
                            'tid',
                            Z.tid
                        ],
                        [
                            'rowid',
                            Z.rowid
                        ],
                        [
                            'updates',
                            te.update_datadict
                        ]
                    ]
                ],
                [
                    'D',
                    [
                        [
                            'tid',
                            Z.tid
                        ],
                        [
                            'rowid',
                            Z.rowid
                        ]
                    ]
                ]
            ]), te.Delta = S = ee.define('Delta', [
                [
                    'rev',
                    Z.uint
                ],
                [
                    'changes',
                    Z.arrayOf(n)
                ],
                [
                    'nonce',
                    Z.string
                ]
            ]), P = ee.define('ListDatastoresResponseItem', [
                [
                    'dsid',
                    Z.string
                ],
                [
                    'handle',
                    Z.string
                ],
                [
                    'rev',
                    Z.uint
                ],
                [
                    'info',
                    Z.nullable(te.datadict),
                    { init: null }
                ]
            ]), te.ListDatastoresResponse = k = ee.define('ListDatastoresResponse', [
                [
                    'token',
                    Z.string
                ],
                [
                    'datastores',
                    Z.arrayOf(P)
                ]
            ]), R = ee.define('GetSnapshotResponseRow', [
                [
                    'tid',
                    Z.string
                ],
                [
                    'rowid',
                    Z.string
                ],
                [
                    'data',
                    te.datadict
                ]
            ]), C = ee.define('GetSnapshotResponse', [
                [
                    'rev',
                    Z.uint
                ],
                [
                    'rows',
                    Z.arrayOf(R)
                ]
            ]), s = ee.define('CreateDatastoreResponse', [
                [
                    'handle',
                    Z.string
                ],
                [
                    'rev',
                    Z.uint
                ],
                [
                    'created',
                    Z.bool
                ]
            ]), T = ee.define('GetDatastoreResponse', [
                [
                    'handle',
                    Z.nullable(Z.string),
                    { init: null }
                ],
                [
                    'rev',
                    Z.nullable(Z.uint),
                    { init: null }
                ],
                [
                    'notfound',
                    Z.nullable(Z.string),
                    { init: null }
                ]
            ]), b = ee.define('DeleteDatastoresResponse', [[
                    'ok',
                    Z.string
                ]]), X = ee.define('PutDeltaResponse', [
                [
                    'rev',
                    Z.nullable(Z.uint),
                    { init: null }
                ],
                [
                    'conflict',
                    Z.nullable(Z.string),
                    { init: null }
                ]
            ]), U = ee.define('GetDeltasResponse', [
                [
                    'deltas',
                    Z.nullable(Z.arrayOf(S)),
                    { init: null }
                ],
                [
                    'notfound',
                    Z.nullable(Z.string),
                    { init: null }
                ]
            ]), e = ee.define('AwaitResponseDeltas', [[
                    'deltas',
                    Z.simple_typed_map('deltas map', Z.string, U)
                ]]), te.AwaitResponse = t = ee.define('AwaitResponse', [
                [
                    'get_deltas',
                    Z.nullable(e),
                    { init: null }
                ],
                [
                    'list_datastores',
                    Z.nullable(k),
                    { init: null }
                ]
            ]), r = function () {
                function t() {
                    this.min_delay_millis = 500, this.max_delay_millis = 90000, this.base = 1.5, this._failures = 0, this.log = !1;
                }
                return t.prototype.set_log = function (t) {
                    this.log = t;
                }, t.prototype.set_max_delay_millis = function (t) {
                    this.max_delay_millis = t;
                }, t.prototype.get_backoff_millis = function () {
                    var t, e;
                    return this._failures += 1, e = Math.min(this.max_delay_millis, this.min_delay_millis * Math.pow(this.base, this._failures - 1)), t = (0.5 + Math.random()) * e, this.log && console.log('get_backoff_millis: failures=' + this._failures + ', target_delay_millis=' + e + ', delay_millis=' + t), t;
                }, t.prototype.reset = function () {
                    return this._failures = 0;
                }, t;
            }(), G = function () {
                function t() {
                    this.backoff = new r();
                }
                var e, n;
                return n = 60000, e = 0, t.prototype.run = function (t, e, r) {
                    var i, o, s, a, u, l, h, c = this;
                    return s = null != (l = e.do_retry) ? l : function () {
                        return !0;
                    }, a = null != (h = e.giveup_after_ms) ? h : n, u = Date.now() + a, o = !1, i = function () {
                        return o ? void 0 : t(function () {
                            var t, e, n;
                            return t = arguments[0], e = 2 <= arguments.length ? oe.call(arguments, 1) : [], o ? void 0 : t && s(t) ? Date.now() > u ? (console.error('Giving up due to error', t), r(t)) : (n = c.backoff.get_backoff_millis(), console.warn('Retrying in ' + n + ' ms due to error', t), setTimeout(i, n)) : r.apply(null, [t].concat(oe.call(e)));
                        });
                    }, i(), function () {
                        return o = !0;
                    };
                }, t;
            }(), x = function () {
                function t(t) {
                    this.client = t, this._retry = new G();
                }
                var e, r;
                return r = 10, e = 2419200, t.prototype._run_with_retries = function (t, e, r) {
                    var n;
                    return n = {
                        giveup_after_ms: 1000 * t,
                        do_retry: function (t) {
                            var e;
                            return 0 === t.status || 500 <= (e = t.status) && 600 > e;
                        }
                    }, this._retry.run(r, n, e);
                }, t.prototype.delete_db = function (t, e) {
                    var n = this;
                    return this._run_with_retries(r, e, function (e) {
                        return n.client._deleteDatastore(t, function (t, r) {
                            return null != t ? e(t) : e(null, r);
                        });
                    });
                }, t.prototype.list_dbs = function (t) {
                    var r = this;
                    return this._run_with_retries(e, t, function (t) {
                        return r.client._listDatastores(function (e, r) {
                            return null != e ? t(e) : t(null, r);
                        });
                    });
                }, t.prototype.get_or_create_db = function (t, e) {
                    var n = this;
                    return this._run_with_retries(r, e, function (e) {
                        return n.client._getOrCreateDatastore(t, function (t, r) {
                            return null != t ? e(t) : e(null, r);
                        });
                    });
                }, t.prototype.create_db = function (t, e, n) {
                    var i = this;
                    return this._run_with_retries(r, n, function (r) {
                        return i.client._createDatastore(t, e, function (t, e) {
                            return null != t ? r(t) : r(null, e);
                        });
                    });
                }, t.prototype.get_db = function (t, e) {
                    var n = this;
                    return this._run_with_retries(r, e, function (e) {
                        return n.client._getDatastore(t, function (t, r) {
                            return null != t ? e(t) : e(null, r);
                        });
                    });
                }, t.prototype.await = function (t, r, n) {
                    var i, o = this;
                    return i = this._run_with_retries(e, n, function (e) {
                        return o.client._datastoreAwait(t, r, function (t, r) {
                            return null != t ? e(t) : e(null, r);
                        });
                    });
                }, t.prototype.put_delta = function (t, r, n) {
                    var i = this;
                    return this._run_with_retries(e, n, function (e) {
                        return i.client._putDelta(t, r, function (t, r) {
                            return null != t ? e(t) : e(null, r);
                        });
                    });
                }, t.prototype.get_snapshot = function (t, e) {
                    var n = this;
                    return this._run_with_retries(r, e, function (e) {
                        return n.client._getSnapshot(t, function (t, r) {
                            return null != t ? e(t) : e(null, r);
                        });
                    });
                }, t;
            }(), te.LocalDelta = L = function () {
                function t(t, e) {
                    var r, n, i;
                    for (Z.assert(t.length === e.length, function () {
                            return '' + t.length + ' changes, ' + e.length + ' undo_extras';
                        }), this.changes = [], this.undo_extras = [], this._last_simple_mtime_update = null, r = n = 0, i = t.length; i >= 0 ? i > n : n > i; r = i >= 0 ? ++n : --n)
                        this.add_change(t[r], e[r]);
                }
                var e;
                return e = function (t, e) {
                    var r, i, o, s, a;
                    switch (s = null, i = null, t.tag()) {
                    case 'I':
                        s = 'D';
                        break;
                    case 'U':
                        s = 'U', i = {};
                        for (o in e)
                            a = e[o], i[o] = null == a ? ['D'] : [
                                'P',
                                a
                            ];
                        break;
                    case 'D':
                        s = 'I', i = te.clone(e);
                        break;
                    default:
                        throw new Error('Unknown change tag: ' + t.tag());
                    }
                    return r = [
                        s,
                        t.tid,
                        t.rowid
                    ], null != i && r.push(i), n.from_array(r);
                }, t._is_simple_mtime_update = function (t) {
                    var e, r;
                    switch (t.tag()) {
                    case 'I':
                    case 'D':
                        return !1;
                    case 'U':
                        if (':info' !== t.tid || 'info' !== t.rowid)
                            return !1;
                        if (r = Object.keys(t.updates), 1 !== r.length)
                            return !1;
                        if ('mtime' !== r[0])
                            return !1;
                        switch (e = t.updates.mtime, e.tag()) {
                        case 'P':
                            return !0;
                        case 'D':
                        case 'LC':
                        case 'LP':
                        case 'LI':
                        case 'LD':
                        case 'LM':
                            return !1;
                        default:
                            throw new Error('Unknown field op: ' + e.tag());
                        }
                        break;
                    default:
                        throw new Error('Unknown change tag: ' + t.tag());
                    }
                }, t._affects_mtime = function (t) {
                    if (':info' !== t.tid || 'info' !== t.rowid)
                        return !1;
                    switch (t.tag()) {
                    case 'I':
                    case 'D':
                        return !0;
                    case 'U':
                        return 'mtime' in t.updates ? !0 : !1;
                    default:
                        throw new Error('Unknown change tag: ' + t.tag());
                    }
                }, t.prototype.add_change = function (e, r) {
                    return this.changes.push(e), this.undo_extras.push(r), t._affects_mtime(e) && (t._is_simple_mtime_update(e) ? (null != this._last_simple_mtime_update && (this.changes.splice(this._last_simple_mtime_update, 1), this.undo_extras.splice(this._last_simple_mtime_update, 1)), this._last_simple_mtime_update = this.changes.length - 1) : this._last_simple_mtime_update = null), void 0;
                }, t.prototype.inverse_changes = function () {
                    var t, r, n, i, o, s;
                    for (n = [], s = this.changes, r = i = 0, o = s.length; o > i; r = ++i)
                        t = s[r], n.push(e(t, this.undo_extras[r]));
                    return n.reverse(), n;
                }, t;
            }(), F = 10, B = F, te.make_nonce = function () {
                return te.randomWeb64String(F);
            }, te.value_size = function (t) {
                var e, r, n, i;
                if (Z.is_string(t))
                    return D.Util.countUtf8Bytes(t);
                if (Z.is_bool(t))
                    return 0;
                if (Z.is_number(t))
                    return 0;
                if (Z.is_array(t)) {
                    for (e = D.Datastore.List.BASE_ITEM_SIZE * t.length, n = 0, i = t.length; i > n; n++)
                        r = t[n], e += te.value_size(r);
                    return e;
                }
                if ('object' != typeof t)
                    throw new Error('Unexpected value: ' + t);
                if (null != t.I)
                    return 0;
                if (null != t.N)
                    return 0;
                if (null != t.B)
                    return Math.ceil(3 * t.B.length / 4);
                if (null != t.T)
                    return 0;
                throw new Error('Unexpected object: ' + JSON.stringify(t));
            }, te.size_difference_for_field_op = function (t, e, r) {
                var n, i, o, s;
                switch (n = t.get(e), r.tag()) {
                case 'P':
                    return i = r.value, n ? te.value_size(i) - te.value_size(n) : D.Datastore.Record.BASE_FIELD_SIZE + te.value_size(i);
                case 'D':
                    return null != n ? -(D.Datastore.Record.BASE_FIELD_SIZE + te.value_size(n)) : 0;
                case 'LC':
                    return Y(null == n, 'can\'t create list for field that already exists'), D.Datastore.Record.BASE_FIELD_SIZE;
                case 'LP':
                    return Y(Z.is_array(n), 'LP on non-list'), Y(0 <= (o = r.at) && o < n.length, 'bad index for LP'), te.value_size(r.value) - te.value_size(n[r.at]);
                case 'LI':
                    return (null != n ? 0 : D.Datastore.Record.BASE_FIELD_SIZE) + D.Datastore.List.BASE_ITEM_SIZE + te.value_size(r.value);
                case 'LD':
                    return Y(Z.is_array(n), 'LD on non-list'), Y(0 <= (s = r.at) && s < n.length, 'bad index for LD'), -(D.Datastore.List.BASE_ITEM_SIZE + te.value_size(n[r.at]));
                case 'LM':
                    return 0;
                default:
                    throw new Error('unexpected field op type ' + r.tag());
                }
            }, te.size_difference_for_change = function (t, e) {
                var r, n, i, o, s, a, u;
                return s = function () {
                    var s, l;
                    switch (e.tag()) {
                    case 'I':
                        o = D.Datastore.Record.BASE_RECORD_SIZE, s = e.fields;
                        for (r in s)
                            u = s[r], o += D.Datastore.Record.BASE_FIELD_SIZE + te.value_size(u);
                        return o;
                    case 'U':
                        i = t.get_record(e.tid, e.rowid), Z.assert(null != i, function () {
                            return 'record not found: ' + JSON.stringify(e);
                        }), a = 0, l = e.updates;
                        for (r in l)
                            n = l[r], a += te.size_difference_for_field_op(i, r, n);
                        return a;
                    case 'D':
                        return -t.get_record(e.tid, e.rowid)._size;
                    default:
                        throw new Error('unrecognized tag ' + e.tag());
                    }
                }();
            }, q = function () {
                function t(t, e, r) {
                    var n, i;
                    this._tid = t, this._rid = e, null == r && (r = {}), this._fields = {}, this._size = D.Datastore.Record.BASE_RECORD_SIZE;
                    for (n in r)
                        i = r[n], this._fields[n] = te.clone(i), this._size += D.Datastore.Record.BASE_FIELD_SIZE + te.value_size(i);
                }
                return t.prototype.get = function (t) {
                    return this._fields[t];
                }, t.prototype.get_all = function () {
                    return this._fields;
                }, t.prototype.put = function (t, e) {
                    return null != e ? this._fields[t] = te.clone(e) : delete this._fields[t], void 0;
                }, t.prototype.apply_field_op = function (t, e) {
                    var r, n, i, o, s, a, u;
                    switch (r = this._fields[t], e.tag()) {
                    case 'P':
                        this._fields[t] = te.clone(e.value);
                        break;
                    case 'D':
                        delete this._fields[t];
                        break;
                    case 'LC':
                        Y(null == r, 'can\'t create list for field that already exists'), this._fields[t] = [];
                        break;
                    case 'LP':
                        Y(Z.is_array(r), 'LP on non-list'), Y(0 <= (i = e.at) && i < r.length, 'bad index for LP'), r[e.at] = te.clone(e.value);
                        break;
                    case 'LI':
                        null != r ? (Y(Z.is_array(r), 'LI on non-list'), Y(0 <= (o = e.before) && o <= r.length, 'bad index for LI'), r.splice(e.before, 0, te.clone(e.value))) : (Y(0 === e.before, 'bad index for LI on nonexistent field'), this._fields[t] = [te.clone(e.value)]);
                        break;
                    case 'LD':
                        Y(Z.is_array(r), 'LD on non-list'), Y(0 <= (s = e.at) && s < r.length, 'bad index for LD'), r.splice(e.at, 1);
                        break;
                    case 'LM':
                        Y(Z.is_array(r), 'LM on non-list'), Y(0 <= (a = e.from) && a < r.length, 'bad from index for LM'), Y(0 <= (u = e.to) && u < r.length, 'bad to index for LM'), n = r[e.from], r.splice(e.from, 1), r.splice(e.to, 0, n);
                        break;
                    default:
                        throw new Error('unexpected field op type ' + e.tag());
                    }
                    return void 0;
                }, t.prototype.size = function () {
                    return this._size;
                }, t;
            }(), $ = function () {
                function t() {
                    this._records = {};
                }
                return t.prototype.get = function (t) {
                    return this._records[t];
                }, t.prototype.put = function (t, e) {
                    return null != e ? this._records[t] = e : delete this._records[t], void 0;
                }, t.prototype.has = function (t) {
                    return null != this._records[t];
                }, t.prototype.is_empty = function () {
                    var t;
                    for (t in this._records)
                        return !1;
                    return !0;
                }, t.prototype.list_record_ids = function () {
                    var t, e;
                    e = [];
                    for (t in this._records)
                        e.push(t);
                    return e;
                }, t;
            }(), l = function () {
                function t(t, e) {
                    var r, n, i, o, s, a;
                    this._tables = {}, this._record_count = 0, this._size = D.Datastore.BASE_DATASTORE_SIZE;
                    for (a in e) {
                        i = e[a], s = this._get_table(a);
                        for (o in i)
                            r = i[o], n = new q(a, o, r), this._check_record_size(t, a, o, n._size), s.put(o, n), this._record_count += 1, this._size += n._size;
                    }
                    this._check_datastore_size(t, this._size), this._changedInfoFields = {};
                }
                return t.from_get_snapshot_resp = function (e) {
                    var r, n, i, o, s, a;
                    for (r = {}, a = e.rows, i = 0, o = a.length; o > i; i++)
                        n = a[i], r[s = n.tid] || (r[s] = {}), r[n.tid][n.rowid] = n.data;
                    return new t(!1, r);
                }, t.prototype._size_limit_exceeded = function (t, e) {
                    var r;
                    if (t)
                        throw r = new Error(e), r.code = 'SIZE_LIMIT_EXCEEDED', r;
                    return console.warn(e), void 0;
                }, t.prototype._check_record_size = function (t, e, r, n) {
                    return n > D.Datastore.Record.RECORD_SIZE_LIMIT && this._size_limit_exceeded(t, 'Record (' + e + ', ' + r + ') too large: ' + n + ' bytes'), void 0;
                }, t.prototype._check_datastore_size = function (t, e) {
                    return e > D.Datastore.DATASTORE_SIZE_LIMIT && this._size_limit_exceeded(t, 'Datastore too large: ' + e + ' bytes'), void 0;
                }, t.prototype._TEST_calculate_size_from_scratch = function () {
                    var t, e, r, n, i, o, s, a, u, l, h, c;
                    n = 0, l = this._tables;
                    for (o in l)
                        for (i = l[o], h = i.list_record_ids(), a = 0, u = h.length; u > a; a++) {
                            r = h[a], e = i.get(r), n += D.Datastore.Record.BASE_RECORD_SIZE, c = e.get_all();
                            for (t in c)
                                s = c[t], n += D.Datastore.Record.BASE_FIELD_SIZE + te.value_size(s);
                        }
                    return n;
                }, t.prototype.raw_data = function () {
                    var t, e, r, n, i, o, s, a;
                    t = {}, s = this._tables;
                    for (n in s)
                        for (r = s[n], t[n] = {}, a = r.list_record_ids(), i = 0, o = a.length; o > i; i++)
                            e = a[i], t[n][e] = te.clone(r.get(e).get_all());
                    return t;
                }, t.prototype.get_record = function (t, e) {
                    var r;
                    return null != (r = this._tables[t]) ? r.get(e) : void 0;
                }, t.prototype.clearInfoFields = function () {
                    return this._changedInfoFields = {};
                }, t.prototype.updateInfoFieldsFromChange = function (t) {
                    var e, r, n, i, o, s, a, u, l;
                    switch (Z.assert(':info' === t.tid, function () {
                            return 'updateInfoField: table must be :info, got ' + t.tid;
                        }), Z.assert('info' === t.rowid, function () {
                            return 'updateInfoField: row must be info, got ' + t.rowid;
                        }), t.tag()) {
                    case 'I':
                        o = t.fields, a = [];
                        for (e in o)
                            n = o[e], a.push(this._changedInfoFields[e] = !0);
                        return a;
                    case 'U':
                        s = t.updates, u = [];
                        for (e in s)
                            i = s[e], u.push(this._changedInfoFields[e] = !0);
                        return u;
                    case 'D':
                        if (r = this.get_record(':info', 'info'), null != r) {
                            l = [];
                            for (e in r.get_all())
                                l.push(this._changedInfoFields[e] = !0);
                            return l;
                        }
                        break;
                    default:
                        throw new Error('Unknown change tag: ' + t.tag());
                    }
                }, t.prototype.updateDatastoreInfo = function (t) {
                    var e, r;
                    t = te.clone(t || {}), e = this.query(':info', 'info') || {};
                    for (r in this._changedInfoFields)
                        r in e ? t[r] = e[r] : delete t[r];
                    return t;
                }, t.prototype.getLocalInfoData = function () {
                    return te.clone(this.query(':info', 'info') || {});
                }, t.prototype.apply_change = function (t, e) {
                    var r, n, i;
                    switch (r = te.size_difference_for_change(this, e), r >= 0 && this._check_datastore_size(t, this._size + r), ':info' === e.tid && 'info' === e.rowid && this.updateInfoFieldsFromChange(e), e.tag()) {
                    case 'I':
                        this._check_record_size(t, e.tid, e.rowid, r), this._record_count += 1, i = this._apply_insert(e);
                        break;
                    case 'U':
                        n = this.get_record(e.tid, e.rowid), Z.assert(null != n, function () {
                            return 'apply_change: record does not exist: ' + JSON.stringify(e);
                        }), r >= 0 && this._check_record_size(t, e.tid, e.rowid, n._size + r), i = this._apply_update(n, e), n._size += r;
                        break;
                    case 'D':
                        this._record_count -= 1, i = this._apply_delete(e);
                        break;
                    default:
                        throw new Error('unrecognized tag ' + e.tag());
                    }
                    return this._size += r, i;
                }, t.prototype._get_table = function (t) {
                    return null == this._tables[t] && (this._tables[t] = new $()), this._tables[t];
                }, t.prototype._apply_insert = function (t) {
                    var e, r;
                    return r = this._get_table(t.tid), Z.assert(!r.has(t.rowid), function () {
                        return '_apply_insert: record already exists: ' + JSON.stringify(t);
                    }), e = new q(t.tid, t.rowid, t.fields), r.put(t.rowid, e), null;
                }, t.prototype._apply_update = function (t, e) {
                    var r, n, i, o, s, a, u;
                    o = {};
                    try {
                        a = e.updates;
                        for (n in a)
                            i = a[n], s = te.clone(null != (u = t.get(n)) ? u : null), t.apply_field_op(n, i), o[n] = s;
                    } catch (l) {
                        r = l;
                        for (n in o)
                            s = o[n], t.put(!1, n, s);
                        throw r;
                    }
                    return o;
                }, t.prototype._apply_delete = function (t) {
                    var e, r, n;
                    return n = this._get_table(t.tid), Z.assert(n.has(t.rowid), function () {
                        return '_apply_delete: record does not exist: ' + JSON.stringify(t);
                    }), r = n.get(t.rowid), e = te.clone(r.get_all()), n.put(t.rowid, null), n.is_empty() && delete this._tables[t.tid], e;
                }, t.prototype.query = function (t, e) {
                    var r, n;
                    return n = this._tables[t], null == n ? null : (r = n.get(e), null == r ? null : te.clone(r.get_all()));
                }, t.prototype.list_tables = function () {
                    var t, e;
                    return t = function () {
                        var t;
                        t = [];
                        for (e in this._tables)
                            t.push(e);
                        return t;
                    }.call(this), t.sort(), t;
                }, t.prototype.list_rows_for_table = function (t) {
                    var e, r;
                    return r = this._tables[t], null == r ? [] : (e = r.list_record_ids(), e.sort(), e);
                }, t.prototype.record_count = function () {
                    return this._record_count;
                }, t.prototype.size = function () {
                    return this._size;
                }, t;
            }(), N = function () {
                function t(t, e, r, n, i, o, s) {
                    this.dbid = t, this.handle = e, this.datastore_model = r, this.resolver = n, this.sync_state = i, this.flob_client = o, this._dslist_listener = s, this.syncStateChanged = new D.Util.EventSource(), this._deleted = !1, this._open = !0, this._put_delta_queue = new W(), this._update_mtime_on_change = !0;
                }
                return t.fresh_managed_datastore = function (e, r, n, i, o, s, a) {
                    var u;
                    return u = new K(i), new t(e, r, n, o, u, s, a);
                }, t.prototype.get_dsid = function () {
                    return this.dbid;
                }, t.prototype.get_handle = function () {
                    return this.handle;
                }, t.prototype.is_deleted = function () {
                    return this._deleted;
                }, t.prototype.mark_deleted = function () {
                    return this._deleted = !0;
                }, t.prototype.open = function () {
                    if (this._open)
                        throw new Error('Attempt to open datastore multiple times');
                    return this._open = !0;
                }, t.prototype.close = function () {
                    if (!this._open)
                        throw new Error('Attempt to close datastore multiple times');
                    return this._open = !1;
                }, t.prototype._updateInfoFieldsAfterSync = function () {
                    var t, e, r, n, i, o;
                    for (this.datastore_model.clearInfoFields(), i = this.sync_state.unsynced_deltas, o = [], r = 0, n = i.length; n > r; r++)
                        e = i[r], o.push(function () {
                            var r, n, i, o;
                            for (i = e.changes, o = [], r = 0, n = i.length; n > r; r++)
                                t = i[r], ':info' === t.tid && 'info' === t.rowid ? o.push(this.datastore_model.updateInfoFieldsFromChange(t)) : o.push(void 0);
                            return o;
                        }.call(this));
                    return o;
                }, t.prototype._should_notify_dslist_listener_for = function (t) {
                    var e, r;
                    if (e = function (t) {
                            var e;
                            for (e in t)
                                if ('mtime' !== e)
                                    return !0;
                            return !1;
                        }, ':info' !== t.tid || 'info' !== t.rowid)
                        return !1;
                    switch (t.tag()) {
                    case 'D':
                        if (r = this.datastore_model.get_record(t.tid, t.rowid), null == r)
                            throw new Error('Record not found: ' + t.tid + ' ' + t.rowid);
                        return e(r.get_all());
                    case 'U':
                        return e(t.updates);
                    case 'I':
                        return e(t.fields);
                    default:
                        throw new Error('unknown change tag: ' + t.tag());
                    }
                }, t.prototype._do_sync = function () {
                    var t, e, r, n, i, o, s, a, u, l, h, c, d, p, _, f, g, y, m, v, w, b, S, D;
                    if (s = this.sync_state.get_server_deltas(), 0 === s.length)
                        return {};
                    for (i = this.resolver.resolve(this.sync_state.unsynced_deltas, s), n = i.rebased_deltas, t = i.affected_records, a = !1, o = this.sync_state.unsynced_deltas.slice().reverse(), l = 0, p = o.length; p > l; l++)
                        for (r = o[l], b = r.inverse_changes(), h = 0, _ = b.length; _ > h; h++)
                            e = b[h], this.datastore_model.apply_change(!1, e);
                    for (c = 0, f = s.length; f > c; c++)
                        for (r = s[c], S = r.changes, d = 0, g = S.length; g > d; d++)
                            e = S[d], a |= this._should_notify_dslist_listener_for(e), this.datastore_model.apply_change(!1, e);
                    for (v = 0, y = n.length; y > v; v++)
                        for (r = n[v], r.undo_extras = [], D = r.changes, w = 0, m = D.length; m > w; w++)
                            e = D[w], a |= this._should_notify_dslist_listener_for(e), u = this.datastore_model.apply_change(!1, e), r.undo_extras.push(u);
                    return this.sync_state.update_unsynced_deltas(n), a && this._dslist_listener(), t;
                }, t.prototype._do_put_delta = function () {
                    var t, e = this;
                    if (!this.sync_state.delta_pending() && (t = this.sync_state.get_delta_to_put(), null != t))
                        return this._put_delta_queue.request(function () {
                            return e.flob_client.put_delta(e.handle, t, function (r, n) {
                                return null == r && null != n.rev && (e.sync_state.put_succeeded(t), e.syncStateChanged.dispatch(null)), e._put_delta_queue.finish();
                            });
                        });
                }, t.prototype._apply_and_queue_local_change = function (t, e) {
                    var r, n;
                    return r = this._should_notify_dslist_listener_for(e), n = this.datastore_model.apply_change(t, e), this.sync_state.add_unsynced_change(e, n), r && this._dslist_listener(), void 0;
                }, t.prototype._clock = function () {
                    return new Date();
                }, t.prototype._update_mtime = function () {
                    var t;
                    return this._update_mtime_on_change ? (t = null != this.datastore_model.query(':info', 'info') ? n.from_array([
                        'U',
                        ':info',
                        'info',
                        {
                            mtime: [
                                'P',
                                te.toDsValue(this._clock())
                            ]
                        }
                    ]) : n.from_array([
                        'I',
                        ':info',
                        'info',
                        { mtime: te.toDsValue(this._clock()) }
                    ]), this._apply_and_queue_local_change(!1, t)) : null;
                }, t.prototype.perform_local_change = function (t) {
                    return this._apply_and_queue_local_change(!0, t), this._update_mtime(), this.syncStateChanged.dispatch(null);
                }, t.prototype.sync = function () {
                    var t;
                    return this.has_unfinalized_changes() && this.sync_state.finalize(), t = this._do_sync(), this._do_put_delta(), this._updateInfoFieldsAfterSync(), t;
                }, t.prototype.get_outgoing_delta_count = function () {
                    return this.sync_state.unsynced_deltas.length;
                }, t.prototype.get_incoming_delta_count = function () {
                    return this.sync_state.get_server_deltas().length;
                }, t.prototype.has_unfinalized_changes = function () {
                    return this.sync_state.has_unfinalized_changes();
                }, t.prototype.receive_server_delta = function (t) {
                    return this.sync_state.receive_server_delta(t), this.syncStateChanged.dispatch(null), void 0;
                }, t.prototype.query = function (t, e) {
                    return this.datastore_model.query(t, e);
                }, t.prototype.list_tables = function () {
                    var t;
                    return function () {
                        var e, r, n, i;
                        for (n = this.datastore_model.list_tables(), i = [], e = 0, r = n.length; r > e; e++)
                            t = n[e], ':info' !== t && i.push(t);
                        return i;
                    }.call(this);
                }, t.prototype.list_rows_for_table = function (t) {
                    return this.datastore_model.list_rows_for_table(t);
                }, t.prototype.get_record_count = function () {
                    return this.datastore_model.record_count();
                }, t.prototype.get_record_size = function (t, e) {
                    return this.datastore_model.get_record(t, e).size();
                }, t.prototype.get_size = function () {
                    return this.datastore_model.size();
                }, t;
            }(), K = function () {
                function t(t) {
                    this._server_rev = t, Z.uint(this._server_rev, '_server_rev'), this._pending_delta = null, this._server_deltas = [], this.unsynced_deltas = [], this._last_unsynced_delta_unfinalized = !1;
                }
                return t.prototype.get_server_rev = function () {
                    return this._server_rev;
                }, t.prototype.is_current = function () {
                    return 0 === this.unsynced_deltas.length && 0 === this._server_deltas.length;
                }, t.prototype.get_server_deltas = function () {
                    return this._server_deltas;
                }, t.prototype.add_unsynced_change = function (t, e) {
                    var r;
                    return r = this.unsynced_deltas.length, this._last_unsynced_delta_unfinalized ? this.unsynced_deltas[r - 1].add_change(t, e) : (this.unsynced_deltas.push(new L([t], [e])), this._last_unsynced_delta_unfinalized = !0), void 0;
                }, t.prototype._compact_deltas = function () {
                    var t, e, r, n, i, o, s, a, u, l, h, c, d, p, _, f;
                    if (Y(null == this._pending_delta, 'delta pending'), n = this.unsynced_deltas.length, !(1 >= n)) {
                        for (s = this._last_unsynced_delta_unfinalized ? this.unsynced_deltas.pop() : null, e = [], o = [], p = this.unsynced_deltas, a = 0, h = p.length; h > a; a++) {
                            for (r = p[a], _ = r.changes, u = 0, c = _.length; c > u; u++)
                                t = _[u], e.push(t);
                            for (f = r.undo_extras, l = 0, d = f.length; d > l; l++)
                                i = f[l], o.push(i);
                        }
                        return this.unsynced_deltas = [new L(e, o)], null != s && this.unsynced_deltas.push(s), void 0;
                    }
                }, t.prototype.get_delta_to_put = function () {
                    var t, e;
                    return Y(null == this._pending_delta, 'delta pending'), t = this.unsynced_deltas.length, 0 === t || 1 === t && this._last_unsynced_delta_unfinalized ? null : (this._compact_deltas(), this._last_unsynced_delta_unfinalized && Y(this.unsynced_deltas.length > 1, 'the only delta is unfinalized'), e = this.unsynced_deltas[0], this._pending_delta = new S({
                        changes: e.changes.slice(),
                        nonce: te.make_nonce(),
                        rev: this._server_rev
                    }), this._pending_delta);
                }, t.prototype.delta_pending = function () {
                    return null != this._pending_delta;
                }, t.prototype.has_unfinalized_changes = function () {
                    return this._last_unsynced_delta_unfinalized;
                }, t.prototype.finalize = function () {
                    return this._last_unsynced_delta_unfinalized = !1, void 0;
                }, t.prototype.update_unsynced_deltas = function (t) {
                    return this.unsynced_deltas = t, this._server_rev += this._server_deltas.length, this._server_deltas = [];
                }, t.prototype._is_our_pending = function (t) {
                    return null != this._pending_delta && this._pending_delta.nonce === t.nonce;
                }, t.prototype._ack = function (t) {
                    return Y(this._is_our_pending(t), 'not ours'), Y(0 === this._server_deltas.length, 'server deltas exist'), this._pending_delta = null, this.unsynced_deltas.shift(), this._server_rev++;
                }, t.prototype.put_succeeded = function (t) {
                    return this._is_our_pending(t) ? this._ack(t) : void 0;
                }, t.prototype.receive_server_delta = function (t) {
                    var e, r;
                    return r = this._server_deltas.length, e = r > 0 ? this._server_deltas[r - 1].rev + 1 : this._server_rev, Y(t.rev <= e, 'was expecting rev ' + e + ', but got ' + t.rev + ' instead!'), t.rev < e ? void 0 : (this._is_our_pending(t) ? this._ack(t) : (this._server_deltas.push(t), this._pending_delta = null), void 0);
                }, t;
            }(), te.DatastoreModel = l, j = function () {
                function t(t) {
                    this.update_manager = t, this.cancelled = !1, this.cancel_fn = null;
                }
                return t.prototype.cancel = function () {
                    return null != this.cancel_fn && this.cancel_fn(), this.cancelled = !0;
                }, t.prototype.poll = function () {
                    var t, e = this;
                    return t = function () {
                        var r;
                        if (!e.cancelled)
                            return r = te.clone(e.update_manager._handle_version_map), e.cancel_fn = e.update_manager.flob_client.await(r, e.update_manager._last_dslist_token, function (n, i) {
                                var o, s, a, u, l, h, c, d, p, _;
                                if (e.cancel_fn = null, n)
                                    return 0 === n.status ? (console.log('await deltas failed (offline):', n), setTimeout(t, 10000)) : n.status && 500 <= (d = n.status) && 599 >= d ? (console.log('server error:', n), setTimeout(t, 2000)) : (console.error('Got error in longpoll:', n), setTimeout(t, 10000));
                                if (null != i.get_deltas) {
                                    p = i.get_deltas.deltas;
                                    for (u in p)
                                        if (s = p[u], null != s.notfound)
                                            e.update_manager._data_queue.push({
                                                handle: u,
                                                notfound: s.notfound
                                            }), delete e.update_manager._handle_version_map[u];
                                        else if (null != s.deltas) {
                                            for (_ = s.deltas, h = 0, c = _.length; c > h; h++)
                                                a = _[h], e.update_manager._data_queue.push({
                                                    handle: u,
                                                    delta: a
                                                });
                                            l = r[u] + s.deltas.length, o = e.update_manager._handle_version_map[u], null != o && (e.update_manager._handle_version_map[u] = Math.max(o, l));
                                        }
                                }
                                return null != i.list_datastores && (e.update_manager._last_dslist_token = i.list_datastores.token, e.update_manager._data_queue.push({ dslist: i.list_datastores })), setTimeout(t, 0);
                            });
                    }, t();
                }, t;
            }(), A = function () {
                function t(t) {
                    this.flob_client = t, this._data_queue = null, this._handle_version_map = {}, this._last_dslist_token = '.', this._pending_poll = null, this._running = !1;
                }
                return t.prototype.run = function (t) {
                    return this._data_queue = new o(t), this._running = !0, this._do_longpoll();
                }, t.prototype.stop = function () {
                    return this._pending_poll ? this._pending_poll.cancel() : void 0;
                }, t.prototype.add_poll = function (t, e) {
                    var r, n;
                    return Y(this._running, 'update manager is not running'), r = this._handle_version_map[t], n = e, null != r && (n = Math.max(e, r)), this._handle_version_map[t] = n, this._do_longpoll();
                }, t.prototype.remove_poll = function (t) {
                    return Y(this._running, 'update manager is not running'), t in this._handle_version_map ? (delete this._handle_version_map[t], this._do_longpoll()) : void 0;
                }, t.prototype._do_longpoll = function () {
                    return Y(this._running, 'update manager is not running'), this._pending_poll && (this._pending_poll.cancel(), this._pending_poll = null), this._pending_poll = new j(this), this._pending_poll.poll();
                }, t;
            }(), z = function () {
                function t(t, e, r, n) {
                    this.update_manager = t, this.flob_client = e, this._dslist_listener_server = r, this._dslist_listener_local = n, this.update_manager.run(this._handle_server_update.bind(this)), this._cached_objects = {}, this._handle_to_dsid_map = {};
                }
                return t.prototype.destroy = function () {
                    var t;
                    for (t in this._cached_objects)
                        this._cached_objects[t].close();
                    return this.update_manager.stop();
                }, t.prototype.getAllCachedDatastoreIDs = function () {
                    var t, e;
                    return function () {
                        var r, n;
                        r = this._cached_objects, n = [];
                        for (e in r)
                            t = r[e], n.push(e);
                        return n;
                    }.call(this);
                }, t.prototype.getCachedDatastore = function (t) {
                    return this._cached_objects[t];
                }, t.prototype._evict = function (t) {
                    var e;
                    return e = this._handle_to_dsid_map[t], null != e ? (delete this._handle_to_dsid_map[t], e in this._cached_objects && this._cached_objects[e].mark_deleted(), this.update_manager.remove_poll(t)) : void 0;
                }, t.prototype.close = function (t) {
                    var e;
                    if (t in this._cached_objects)
                        return e = this._cached_objects[t].get_handle(), this._cached_objects[t].close();
                    throw new Error('Attempt to close unknown datastore: ' + t);
                }, t.prototype._handle_server_update = function (t, e) {
                    var r, n, i;
                    return t.dslist ? (this._dslist_listener_server && this._dslist_listener_server(t.dslist), e(null)) : (i = t.handle, r = this._handle_to_dsid_map[i], null == r ? (console.log('unknown handle ' + i + ' (maybe datastore was evicted)', t, this._handle_to_dsid_map, this._cached_objects), e(null)) : (n = t.delta, null != t.notfound ? (this._evict(i), e(null)) : this._retrieve(r, i, function (t, r) {
                        return t ? e(t) : (r.receive_server_delta(n), e(null));
                    })));
                }, t.prototype.open = function (t, e, r) {
                    return this._cached_objects[t] && this._cached_objects[t].open(), this._retrieve(t, e, r);
                }, t.prototype._retrieve = function (t, e, r) {
                    var n, i = this;
                    return n = this._cached_objects[t], null != n ? r(null, n) : (this._handle_to_dsid_map[e] = t, this.flob_client.get_snapshot(e, function (n, o) {
                        var s, a, u;
                        return null != n ? r(n) : null != i._cached_objects[t] ? r(null, i._cached_objects[t]) : (s = l.from_get_snapshot_resp(o), u = new w(), a = N.fresh_managed_datastore(t, e, s, o.rev, u, i.flob_client, i._dslist_listener_local), i.update_manager.add_poll(e, a.sync_state.get_server_rev()), i._cached_objects[t] = a, r(null, a));
                    }));
                }, t;
            }(), te.FieldOpTransformer = O = function () {
                function t(t) {
                    var i, o, s, a, l, h, c, d, p, y, m, v = this;
                    for (this.rule_name = null != t ? t : 'default', this.precedence = n[this.rule_name], this._transforms = {}, s = 0, h = r.length; h > s; s++)
                        o = r[s], this._transforms[o] = {};
                    for (m = [
                            'P',
                            'D'
                        ], a = 0, c = m.length; c > a; a++)
                        for (o = m[a], l = 0, d = e.length; d > l; l++)
                            i = e[l], this._transforms[o][i] = _, this._transforms[i][o] = f;
                    for (y = 0, p = e.length; p > y; y++)
                        i = e[y], 'LC' === i ? this._transforms.LC.LC = function () {
                            return [
                                null,
                                null
                            ];
                        } : (this._transforms.LC[i] = f, this._transforms[i].LC = _);
                    this._transforms.P.P = function (t, e) {
                        var r;
                        return r = v.precedence(t.value, e.value), 'left' === r ? [
                            t,
                            null
                        ] : [
                            null,
                            e
                        ];
                    }, this._transforms.P.D = function (t, e) {
                        var r;
                        return r = v.precedence(t.value, null), 'left' === r ? [
                            t,
                            null
                        ] : [
                            null,
                            e
                        ];
                    }, this._transforms.D.P = function (t, e) {
                        var r;
                        return r = v.precedence(null, e.value), 'left' === r ? [
                            t,
                            null
                        ] : [
                            null,
                            e
                        ];
                    }, this._transforms.D.D = function (t, e) {
                        var r;
                        return r = v.precedence(null, null), 'left' === r ? [
                            t,
                            null
                        ] : [
                            null,
                            e
                        ];
                    }, this._transforms.LP.LP = function (t, e) {
                        var r;
                        return t.at !== e.at ? [
                            t,
                            e
                        ] : (r = v.precedence(t.value, e.value), 'left' === r ? [
                            t,
                            null
                        ] : [
                            null,
                            e
                        ]);
                    }, this._transforms.LP.LI = function (t, e) {
                        var r;
                        return r = u(t), r.at += e.before <= t.at ? 1 : 0, [
                            r,
                            e
                        ];
                    }, this._transforms.LP.LD = function (t, e) {
                        var r;
                        return t.at === e.at ? [
                            null,
                            e
                        ] : (r = u(t), r.at -= e.at < t.at ? 1 : 0, [
                            r,
                            e
                        ]);
                    }, this._transforms.LP.LM = function (t, e) {
                        var r;
                        return r = u(t), t.at === e.from ? r.at = e.to : (r.at -= e.from < r.at ? 1 : 0, r.at += e.to <= r.at ? 1 : 0), [
                            r,
                            e
                        ];
                    }, this._transforms.LI.LP = g(this._transforms.LP.LI), this._transforms.LI.LI = function (t, e) {
                        var r, n, i;
                        return i = [
                            u(t),
                            u(e)
                        ], r = i[0], n = i[1], t.before < e.before ? n.before += 1 : r.before += 1, [
                            r,
                            n
                        ];
                    }, this._transforms.LI.LD = function (t, e) {
                        var r, n, i;
                        return i = [
                            u(t),
                            u(e)
                        ], r = i[0], n = i[1], r.before -= e.at < t.before ? 1 : 0, n.at += t.before <= e.at ? 1 : 0, [
                            r,
                            n
                        ];
                    }, this._transforms.LI.LM = function (t, e) {
                        var r, n, i, o;
                        return o = [
                            u(t),
                            u(e)
                        ], n = o[0], i = o[1], t.before === e.to + 1 && e.from <= e.to ? [
                            t,
                            e
                        ] : t.before === e.to && e.from > e.to ? (n.before++, i.from++, [
                            n,
                            i
                        ]) : (r = e.from < t.before ? t.before - 1 : t.before, i.from += t.before <= e.from ? 1 : 0, n.before = e.to < r ? r + 1 : r, i.to += r <= e.to ? 1 : 0, [
                            n,
                            i
                        ]);
                    }, this._transforms.LD.LP = g(this._transforms.LP.LD), this._transforms.LD.LI = g(this._transforms.LI.LD), this._transforms.LD.LD = function (t, e) {
                        var r, n, i;
                        return t.at === e.at ? [
                            null,
                            null
                        ] : (i = [
                            u(t),
                            u(e)
                        ], r = i[0], n = i[1], t.at < e.at ? n.at -= 1 : r.at -= 1, [
                            r,
                            n
                        ]);
                    }, this._transforms.LD.LM = function (t, e) {
                        var r, n, i;
                        return t.at === e.from ? (r = u(t), r.at = e.to, [
                            r,
                            null
                        ]) : (i = [
                            u(t),
                            u(e)
                        ], r = i[0], n = i[1], r.at -= e.from < r.at ? 1 : 0, r.at += e.to <= r.at ? 1 : 0, n.to += n.from < n.to ? 1 : 0, n.from -= t.at < n.from ? 1 : 0, n.to -= t.at < n.to ? 1 : 0, n.to -= n.from < n.to ? 1 : 0, [
                            r,
                            n
                        ]);
                    }, this._transforms.LM.LP = g(this._transforms.LP.LM), this._transforms.LM.LI = function (t, e) {
                        var r, n, i, o;
                        return o = [
                            u(t),
                            u(e)
                        ], n = o[0], i = o[1], e.before === t.to + 1 && t.from <= t.to ? [
                            t,
                            e
                        ] : e.before === t.to && t.from > t.to ? (n.from++, n.to++, [
                            n,
                            i
                        ]) : (r = t.from < e.before ? e.before - 1 : e.before, n.from += e.before <= t.from ? 1 : 0, i.before = t.to < r ? r + 1 : r, n.to += r <= t.to ? 1 : 0, [
                            n,
                            i
                        ]);
                    }, this._transforms.LM.LD = g(this._transforms.LD.LM), this._transforms.LM.LM = function (t, e) {
                        var r, n, i, o, s, a, l, h, c, d, p;
                        return t.from === e.from ? t.to === e.to ? [
                            null,
                            null
                        ] : e.from === e.to ? [
                            t,
                            e
                        ] : (o = u(e), o.from = t.to, [
                            null,
                            o
                        ]) : t.to === t.from ? (i = u(t), i.from += (e.to <= t.from) - (e.from < t.from), t.from === e.to && e.from < e.to && i.from--, i.to = i.from, [
                            i,
                            e
                        ]) : e.to === e.from ? (o = u(e), o.from += (t.to <= e.from) - (t.from < e.from), o.to = o.from, [
                            t,
                            o
                        ]) : (l = [
                            u(t),
                            u(e)
                        ], i = l[0], o = l[1], t.to === e.to && t.from > t.to && e.from > e.to ? (i.to++, e.from > t.from ? i.from++ : o.from++, [
                            i,
                            o
                        ]) : t.from === e.to && e.from === t.to && t.from < t.to ? (o.from--, i.from++, [
                            i,
                            o
                        ]) : t.from > t.to && e.from < e.to && e.to + 1 === t.to ? [
                            t,
                            e
                        ] : (h = [
                            t.to,
                            t.from
                        ], s = h[0], r = h[1], s += t.from < s ? 1 : 0, s -= e.from < s ? 1 : 0, s += e.to < s ? 1 : 0, r -= e.from < r ? 1 : 0, r += e.to <= r ? 1 : 0, s -= s > r ? 1 : 0, c = [
                            e.to,
                            e.from
                        ], a = c[0], n = c[1], a += e.from < a ? 1 : 0, a -= t.from < a ? 1 : 0, a += t.to <= a ? 1 : 0, n -= t.from < n ? 1 : 0, n += t.to <= n ? 1 : 0, a -= a > n ? 1 : 0, d = [
                            s,
                            r
                        ], i.to = d[0], i.from = d[1], p = [
                            a,
                            n
                        ], o.to = p[0], o.from = p[1], [
                            i,
                            o
                        ]));
                    };
                }
                var e, r, n, i, o, s, a, u, l, h, c, d, p, _, f, g, y, m, v;
                for (g = function (t) {
                        return Y(null != t), function (e, r) {
                            var n, i, o;
                            return o = t(r, e), n = o[0], i = o[1], [
                                i,
                                n
                            ];
                        };
                    }, i = [
                        'null',
                        'bool',
                        'num',
                        'str',
                        'blob',
                        'ts',
                        'list'
                    ], o = {}, h = m = 0, v = i.length; v > m; h = ++m)
                    y = i[h], o[y] = h;
                return l = function (t) {
                    if (null == t)
                        return 'null';
                    if (Z.is_bool(t))
                        return 'bool';
                    if (null != t.I || Z.is_number(t))
                        return 'num';
                    if (Z.is_string(t))
                        return 'str';
                    if (null != t.B)
                        return 'blob';
                    if (null != t.T)
                        return 'ts';
                    if (Z.is_array(t))
                        return 'list';
                    throw new Error('Unrecognized value ' + t);
                }, p = function (t) {
                    return Z.is_number(t) || null != t.I;
                }, s = function (t) {
                    return null != t.I ? parseInt(t.I) : t;
                }, d = function (t, e) {
                    var r, n, i;
                    for (r = n = 0, i = t.length; i >= 0 ? i > n : n > i; r = i >= 0 ? ++n : --n) {
                        if (r >= e.length)
                            return !1;
                        if (c(t[r], e[r]))
                            return !0;
                        if (c(e[r], t[r]))
                            return !1;
                    }
                    return e.length > t.length;
                }, t._is_less_than = c = function (t, e) {
                    var r, n;
                    if (r = l(t), n = l(e), r !== n)
                        return o[r] < o[n];
                    if ('null' === r)
                        return !1;
                    if ('bool' === r)
                        return e && !t;
                    if ('num' === r)
                        return null != t.I && null != e.I ? te.int64_string_less_than(t.I, e.I) : s(t) < s(e);
                    if ('str' === r)
                        return e > t;
                    if ('blob' === r)
                        return t.B < e.B;
                    if ('ts' === r)
                        return parseInt(t.T, 10) < parseInt(e.T, 10);
                    if ('list' === r)
                        return d(t, e);
                    throw new Error('unknown type ' + r);
                }, t._compute_sum = a = function (t, e, r) {
                    var n, i, o, s, a, u;
                    return n = null != t.I && null != e.I && null != r.I, null != t.I && (t = parseInt(t.I)), null != e.I && (e = parseInt(e.I)), null != r.I && (r = parseInt(r.I)), s = 9223372036854776000, a = 18446744073709552000, u = 18446744073709550000, i = e - t, o = r + i, n && (o >= s && (o -= u), -s > o && (o += u), o = { I: '' + o }), o;
                }, f = function (t, e) {
                    return [
                        null,
                        e
                    ];
                }, _ = function (t) {
                    return [
                        t,
                        null
                    ];
                }, r = [
                    'P',
                    'D',
                    'LC',
                    'LP',
                    'LI',
                    'LD',
                    'LM'
                ], e = [
                    'LC',
                    'LP',
                    'LI',
                    'LD',
                    'LM'
                ], t.copy = u = function (t) {
                    return I.from_array(JSON.parse(JSON.stringify(t)));
                }, n = {
                    'default': function () {
                        return 'right';
                    },
                    remote: function () {
                        return 'right';
                    },
                    local: function () {
                        return 'left';
                    },
                    min: function (t, e) {
                        return c(t, e) ? 'left' : 'right';
                    },
                    max: function (t, e) {
                        return c(t, e) ? 'right' : 'left';
                    },
                    sum: function () {
                        return 'right';
                    }
                }, t.prototype.transform = function (t, e, r) {
                    var n, i, o, s, u;
                    return null == r && (r = null), 'sum' === this.rule_name && 'P' === t.tag() && 'P' === e.tag() && (null == r && (r = { I: '0' }), p(r) && p(t.value) && p(e.value)) ? (o = a(r, t.value, e.value), n = i = I.from_array([
                        'P',
                        o
                    ]), [
                        n,
                        i,
                        e.value
                    ]) : (s = this._transforms[t.tag()][e.tag()](t, e), u = function () {
                        switch (e.tag()) {
                        case 'P':
                            return e.value;
                        case 'D':
                            return null;
                        default:
                            return { L: !0 };
                        }
                    }(), s.push(u), s);
                }, t;
            }(), te.ChangeTransformer = i = function () {
                function t() {
                    this._transform_rules = {}, this._default_transformer = new O();
                }
                var e, r, i, o, s, a, u, l;
                for (e = {}, l = [
                        'default',
                        'local',
                        'remote',
                        'min',
                        'max',
                        'sum'
                    ], a = 0, u = l.length; u > a; a++)
                    i = l[a], e[i] = new O(i);
                return s = function (t) {
                    return Y(null != t), function (e, r) {
                        var n, i, o;
                        return o = t(r, e), n = o[0], i = o[1], [
                            i,
                            n
                        ];
                    };
                }, r = function (t) {
                    return t instanceof Array ? t.slice() : t;
                }, o = function (t, e) {
                    return t.tid === e.tid && t.rowid === e.rowid;
                }, t.is_no_op = function (t) {
                    var e, r, n;
                    if ('U' !== t.tag())
                        return !1;
                    n = t.updates;
                    for (r in n)
                        return e = n[r], !1;
                    return !0;
                }, t.compact = function (t) {
                    var e, r, n, i;
                    for (e = [], n = 0, i = t.length; i > n; n++)
                        r = t[n], this.is_no_op(r) || e.push(r);
                    return e;
                }, t.prototype.set_field_transformer = function (t, r, n) {
                    var i;
                    return null == (i = this._transform_rules)[t] && (i[t] = {}), this._transform_rules[t][r] = e[n];
                }, t.prototype.get_field_transformer = function (t, r) {
                    var n;
                    return t in this._transform_rules ? null != (n = this._transform_rules[t][r]) ? n : this._default_transformer : e['default'];
                }, t.prototype.transform_ii = function (t, e) {
                    var i, s, a;
                    return o(t, e) ? (i = function (t) {
                        var e, i, o, s, a;
                        o = {}, a = t.fields;
                        for (i in a)
                            s = a[i], o[i] = I.from_array([
                                'P',
                                r(s)
                            ]);
                        return e = n.from_array([
                            'U',
                            t.tid,
                            t.rowid,
                            o
                        ]), e.undo_extra = {}, e;
                    }, s = i(t), a = i(e), this.transform_uu(s, a)) : [
                        [t],
                        [e]
                    ];
                }, t.prototype.transform_iu = function (t, e) {
                    return o(t, e) ? Y(!1, 'Couldn\'t have updated a row that hasn\'t been inserted yet!') : [
                        [t],
                        [e]
                    ];
                }, t.prototype.transform_id = function (t, e) {
                    return o(t, e) ? Y(!1, 'Couldn\'t have deleted a row that hasn\'t been inserted yet!') : [
                        [t],
                        [e]
                    ];
                }, t.prototype.transform_ui = s(t.prototype.transform_iu), t.prototype.transform_uu = function (t, e) {
                    var r, i, s, a, u, l, h, c, d, p, _, f, g, y, m, v, w, b, S;
                    if (!o(t, e))
                        return [
                            [t],
                            [e]
                        ];
                    y = [
                        {},
                        {}
                    ], d = y[0], p = y[1], c = {}, m = t.updates;
                    for (s in m)
                        r = m[s], s in e.updates ? (i = e.updates[s], _ = null != (w = t.undo_extra[s]) ? w : null, f = this.get_field_transformer(t.tid, s), b = f.transform(r, i, _), a = b[0], u = b[1], g = b[2], null != a && (d[s] = a, c[s] = null != g ? g : null), null != u && (p[s] = u)) : (d[s] = r, c[s] = null != (v = t.undo_extra[s]) ? v : null);
                    S = e.updates;
                    for (s in S)
                        i = S[s], s in t.updates || (p[s] = i);
                    return l = n.from_array([
                        'U',
                        t.tid,
                        t.rowid,
                        d
                    ]), l.undo_extra = c, h = n.from_array([
                        'U',
                        e.tid,
                        e.rowid,
                        p
                    ]), [
                        [l],
                        [h]
                    ];
                }, t.prototype.transform_ud = function (t, e) {
                    return o(t, e) ? [
                        [],
                        [e]
                    ] : [
                        [t],
                        [e]
                    ];
                }, t.prototype.transform_di = s(t.prototype.transform_id), t.prototype.transform_du = s(t.prototype.transform_ud), t.prototype.transform_dd = function (t, e) {
                    return o(t, e) ? [
                        [],
                        []
                    ] : [
                        [t],
                        [e]
                    ];
                }, t;
            }(), te.DefaultResolver = w = function () {
                function t() {
                    this._change_transformer = new i();
                }
                return t.prototype.add_resolution_rule = function (t, e, r) {
                    return this._change_transformer.set_field_transformer(t, e, r);
                }, t.prototype._transform_one = function (t, e) {
                    var r, n, o, s, a;
                    return r = function (t) {
                        switch (t.tag()) {
                        case 'I':
                            return 'i';
                        case 'U':
                            return 'u';
                        case 'D':
                            return 'd';
                        default:
                            throw new Error('unrecognized op type ' + t.tag());
                        }
                    }, s = 'transform_' + r(t) + r(e), a = this._change_transformer[s](t, e), n = a[0], o = a[1], n = i.compact(n), o = i.compact(o), [
                        n,
                        o
                    ];
                }, t.prototype._transform_list = function (t, e) {
                    var r, n, i, o, s, a, u, l, h, c, d, p, _, f;
                    if (0 === t.length)
                        return [
                            [],
                            e
                        ];
                    if (0 === e.length)
                        return [
                            t,
                            []
                        ];
                    for (r = t[0], n = e[0], p = this._transform_one(r, n), o = p[0], s = p[1], _ = this._transform_list(t.slice(1), s), i = _[0], s = _[1], l = 0, c = i.length; c > l; l++)
                        a = i[l], o.push(a);
                    for (f = this._transform_list(o, e.slice(1)), o = f[0], u = f[1], h = 0, d = u.length; d > h; h++)
                        a = u[h], s.push(a);
                    return [
                        o,
                        s
                    ];
                }, t.prototype._resolve = function (t, e) {
                    var r, n, i, o, s, a, u;
                    for (o = e.slice(), n = [], s = 0, a = t.length; a > s; s++)
                        i = t[s], u = this._transform_list(i, o), r = u[0], o = u[1], n.push(r);
                    return [
                        n,
                        o
                    ];
                }, t.prototype.resolve = function (t, e) {
                    var r, i, o, s, a, u, l, h, c, d, p, _, f, g, y, m, v, w, b, S, D, E, A, I, O, x, T, U, C, R, k;
                    for (d = [], y = 0, b = t.length; b > y; y++) {
                        for (h = t[y], i = [], C = h.changes, c = m = 0, S = C.length; S > m; c = ++m)
                            s = C[c], u = n.from_array(JSON.parse(JSON.stringify(s))), u.undo_extra = te.clone(h.undo_extras[c]), i.push(u);
                        d.push(i);
                    }
                    for (f = [], v = 0, D = e.length; D > v; v++)
                        for (h = e[v], R = h.changes, w = 0, E = R.length; E > w; w++)
                            o = R[w], f.push(o);
                    for (k = this._resolve(d, f), p = k[0], l = k[1], _ = [], c = x = 0, A = p.length; A > x; c = ++x) {
                        for (a = p[c], g = function () {
                                var t, e, r;
                                for (r = [], e = 0, t = a.length; t > e; e++)
                                    s = a[e], r.push(null);
                                return r;
                            }(), T = 0, I = a.length; I > T; T++)
                            s = a[T], delete s.undo_extra;
                        a.length > 0 && _.push(new L(a, g));
                    }
                    for (r = {}, U = 0, O = l.length; O > U; U++)
                        o = l[U], o.tid in r || (r[o.tid] = {}), r[o.tid][o.rowid] = !0;
                    return {
                        rebased_deltas: _,
                        affected_records: r
                    };
                }, t;
            }(), W = function () {
                function t() {
                    this._waiting = [], this._running = !1;
                }
                return t.prototype._run_next = function () {
                    var t;
                    this._running || this._waiting.length > 0 && (t = this._waiting[0], this._waiting.shift(), this._running = !0, t());
                }, t.prototype.request = function (t) {
                    return this._waiting.push(t), this._run_next();
                }, t.prototype.finish = function () {
                    return this._running = !1, setTimeout(this._run_next.bind(this), 0);
                }, t;
            }(), o = function () {
                function t(t) {
                    this.consumer = t, this.items = [], this.sync_queue = new W();
                }
                return t.prototype.consume = function () {
                    var t = this;
                    return this.sync_queue.request(function () {
                        var e;
                        return 0 === t.items.length ? t.sync_queue.finish() : (e = t.items.shift(), t.consumer(e, function (e) {
                            if (e)
                                throw e;
                            return t.sync_queue.finish(), t.consume();
                        }));
                    });
                }, t.prototype.push = function (t) {
                    return this.items.push(t), this.consume();
                }, t.prototype.run = function () {
                    return this.consume();
                }, t;
            }(), te.clone = function (t) {
                var e, r, n, i, o, s, a;
                if (t instanceof Array) {
                    for (a = [], o = 0, s = t.length; s > o; o++)
                        e = t[o], a.push(te.clone(e));
                    return a;
                }
                if (null != t && 'object' == typeof t) {
                    n = {};
                    for (r in t)
                        i = t[r], n[r] = te.clone(i);
                    return n;
                }
                return t;
            }, te.WEB64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_', te.randomElement = function (t) {
                return t[Math.floor(Math.random() * t.length)];
            }, te.randomWeb64String = function (t) {
                var e;
                return function () {
                    var r, n;
                    for (n = [], e = r = 0; t >= 0 ? t > r : r > t; e = t >= 0 ? ++r : --r)
                        n.push(te.randomElement(te.WEB64_ALPHABET));
                    return n;
                }().join('');
            }, te.uint8ArrayFromBase64String = function (t) {
                var e, r, n, i, o;
                for (t = t.replace(/-/g, '+').replace(/_/g, '/'), e = D.Util.atob(t), n = e.length, i = new Uint8Array(n), r = o = 0; n >= 0 ? n > o : o > n; r = n >= 0 ? ++o : --o)
                    i[r] = e.charCodeAt(r);
                return i;
            }, te.dbase64FromBase64 = function (t) {
                return t.replace(/[+]/g, '-').replace(/[/]/g, '_').replace(/[\=]+$/g, '');
            }, te.base64StringFromUint8Array = function (t) {
                var e, r, n, i, o;
                for (r = '', i = 0, o = t.length; o > i; i++)
                    e = t[i], r += String.fromCharCode(e);
                return n = D.Util.btoa(r), te.dbase64FromBase64(n);
            }, te.INT64_TAG = 'dbxInt64', te.isInt64 = function (t) {
                var e;
                return t && 'object' == typeof t && t.constructor === Number && isFinite(t) ? (e = t[te.INT64_TAG], !Z.is_string(e) || '0' !== e && !te.nonzero_int64_approximate_regex.test(e) ? !1 : !0) : !1;
            }, te.validateInt64 = function (t) {
                var e, r;
                if (!t && 'object' == typeof t && t.constructor === Number && isFinite(t))
                    throw new Error('Not a finite boxed number: ' + t);
                if (r = t[te.INT64_TAG], !Z.is_string(r) || '0' !== r && !te.nonzero_int64_approximate_regex.test(r))
                    throw new Error('Missing or invalid tag in int64: ' + r);
                if (e = parseInt(r, 10), e !== Number(t))
                    throw new Error('Tag in int64 does not match value ' + Number(t) + ': ' + r);
                return t;
            }, te.toDsValue = function (t, e) {
                var r, n;
                if (null == e && (e = !0), null === t || 'undefined' == typeof t)
                    throw new Error('Bad value: ' + t);
                if (Z.is_string(t))
                    return t;
                if (Z.is_bool(t))
                    return t;
                if (Z.is_number(t)) {
                    if (null != t[te.INT64_TAG])
                        return te.validateInt64(t), { I: t[te.INT64_TAG] };
                    if (isFinite(t))
                        return t;
                    if (isNaN(t))
                        return { N: 'nan' };
                    if (1 / 0 === Number(t))
                        return { N: '+inf' };
                    if (Number(t) === -1 / 0)
                        return { N: '-inf' };
                    throw new Error('Unexpected number: ' + t);
                }
                if (Z.is_array(t)) {
                    if (e)
                        return function () {
                            var e, r, i;
                            for (i = [], e = 0, r = t.length; r > e; e++)
                                n = t[e], i.push(te.toDsValue(n, !1));
                            return i;
                        }();
                    throw new Error('Nested array not allowed: ' + JSON.stringify(t));
                }
                if (Z.is_date(t))
                    return r = Math.round(t.getTime()), { T: '' + r };
                if (Z.isUint8Array(t))
                    return { B: te.base64StringFromUint8Array(t) };
                throw new Error('Unexpected value: ' + Z.safe_to_string(t));
            }, te.fromDsValue = function (t, e, r, n) {
                if (Z.is_string(n))
                    return n;
                if (Z.is_bool(n))
                    return n;
                if (Z.is_number(n))
                    return n;
                if (Z.is_array(n))
                    return new D.Datastore.List(t, e, r);
                if ('object' != typeof n)
                    throw new Error('Unexpected value: ' + n);
                if (null != n.I)
                    return D.Datastore.int64(n.I);
                if (null == n.N) {
                    if (null != n.B)
                        return te.uint8ArrayFromBase64String(n.B);
                    if (null != n.T)
                        return new Date(parseInt(n.T, 10));
                    throw new Error('Unexpected object: ' + JSON.stringify(n));
                }
                switch (n.N) {
                case 'nan':
                    return 0 / 0;
                case '+inf':
                    return 1 / 0;
                case '-inf':
                    return -1 / 0;
                default:
                    throw new Error('Unexpected object: ' + JSON.stringify(n));
                }
            }, te.matchDsValues = function (t, e) {
                var r, n, i, o, s;
                n = function (t, e) {
                    if (null == t)
                        throw new Error('Unexpected object: ' + t);
                    return null == e ? !1 : r(t, e);
                }, r = function (t, e) {
                    var r, i, o, s, a, u;
                    if (te.toDsValue(t), Z.is_string(t) && Z.is_string(e))
                        return String(t) === String(e);
                    if (Z.is_bool(t) && Z.is_bool(e))
                        return 'object' == typeof t && (t = t.valueOf()), 'object' == typeof e && (e = e.valueOf()), Boolean(t) === Boolean(e);
                    if (Z.is_number(t) && (Z.is_number(e) || null != e.N || null != e.I))
                        return e = te.fromDsValue(void 0, void 0, void 0, e), t[te.INT64_TAG] && e[te.INT64_TAG] ? (s = [
                            D.Datastore.int64(t),
                            D.Datastore.int64(e)
                        ], t = s[0], e = s[1], String(t[te.INT64_TAG]) === String(e[te.INT64_TAG])) : isNaN(t) && isNaN(e) ? !0 : Number(t) === Number(e);
                    if (Z.is_array(t) && Z.is_array(e)) {
                        if (t.length !== e.length)
                            return !1;
                        for (r = i = 0, a = t.length - 1; a >= 0 ? a >= i : i >= a; r = a >= 0 ? ++i : --i)
                            if (!n(t[r], e[r]))
                                return !1;
                        return !0;
                    }
                    if (Z.is_date(t) && (Z.is_date(e) || null != e.T))
                        return null != e.T && (e = te.fromDsValue(void 0, void 0, void 0, e)), t - 0 === e - 0;
                    if (Z.isUint8Array(t) && (Z.isUint8Array(e) || null != e.B)) {
                        if (null != e.B && (e = te.fromDsValue(void 0, void 0, void 0, e)), t.length !== e.length)
                            return !1;
                        for (r = o = 0, u = t.length - 1; u >= 0 ? u >= o : o >= u; r = u >= 0 ? ++o : --o)
                            if (t[r] !== e[r])
                                return !1;
                        return !0;
                    }
                    return !1;
                };
                for (i in t)
                    if (s = t[i], o = n(s, e[i]), !o)
                        return o;
                return !0;
            }, H = function () {
                function t(t) {
                    this._datastore = t, this._cache = {};
                }
                return t.prototype.get = function (t, e) {
                    return null == this._cache[t] ? null : this._cache[t][e];
                }, t.prototype.getOrCreate = function (t, e) {
                    var r;
                    return null == this._cache[t] && (this._cache[t] = {}), r = this._cache[t][e], null == r && (r = this._cache[t][e] = new D.Datastore.Record(this._datastore, t, e)), r;
                }, t.prototype.remove = function (t, e) {
                    return delete this._cache[t][e], Z.is_empty(this._cache[t]) && delete this._cache[t], void 0;
                }, t;
            }(), E = function () {
                function t() {
                    this._registered_handlers = [];
                }
                return t.prototype.register = function (t, e) {
                    return t.addListener(e), this._registered_handlers.push([
                        t,
                        e
                    ]), void 0;
                }, t.prototype.unregister_all = function () {
                    var t, e, r, n, i, o;
                    for (i = this._registered_handlers, r = 0, n = i.length; n > r; r++)
                        o = i[r], e = o[0], t = o[1], e.removeListener(t);
                    return void 0;
                }, t;
            }(), D.Datastore.DatastoreInfo = function () {
                function t(t, e, r) {
                    this._dsid = t, this._handle = e, this._info_record_data = r;
                }
                return t.prototype.toString = function () {
                    return 'Datastore.DatastoreInfo(' + this._dsid + ' ' + JSON.stringify(this._info_record_data || {}) + ')';
                }, t.prototype.getId = function () {
                    return this._dsid;
                }, t.prototype.getHandle = function () {
                    return this._handle;
                }, t.prototype.getTitle = function () {
                    var t;
                    return null == (null != (t = this._info_record_data) ? t.title : void 0) ? null : this._info_record_data.title;
                }, t.prototype.getModifiedTime = function () {
                    var t;
                    return null == (null != (t = this._info_record_data) ? t.mtime : void 0) ? null : this._info_record_data.mtime;
                }, t;
            }(), D.Datastore.DatastoreListChanged = function () {
                function t(t) {
                    this._dsinfos = t;
                }
                return t.prototype.toString = function () {
                    return 'Datastore.DatastoreListChanged(' + this._dsinfos.length + ' datastores)';
                }, t.prototype.getDatastoreInfos = function () {
                    return this._dsinfos;
                }, t;
            }(), D.Datastore.impl.EventSourceWithInitialData = function (t) {
                function e(t) {
                    this.options = t, e.__super__.constructor.call(this, t), this._have_event = !1, this._last_event = null, this._listenersChanged = new D.Util.EventSource();
                }
                return ie(e, t), e.prototype._clearLastEvent = function () {
                    return this._have_event = !1, this._last_event = null;
                }, e.prototype.addListener = function (t) {
                    var r;
                    return r = e.__super__.addListener.call(this, t), this._have_event && t(this._last_event), this._listenersChanged.dispatch(this._listeners), r;
                }, e.prototype.removeListener = function (t) {
                    var r;
                    return r = e.__super__.removeListener.call(this, t), this._listenersChanged.dispatch(this._listeners), r;
                }, e.prototype.dispatch = function (t) {
                    return this._last_event = t, this._have_event = !0, e.__super__.dispatch.call(this, t);
                }, e;
            }(D.Util.EventSource), a = 'default', D.Datastore.DatastoreManager = function () {
                function t(t) {
                    var e = this;
                    if (!t.isAuthenticated())
                        throw new Error('DatastoreManager requires an authenticated Dropbox.Client!');
                    this.datastoreListChanged = new D.Datastore.impl.EventSourceWithInitialData(), this._flob_client = new x(t), this._lastListDsServerResponse = null, this._obj_manager = new z(new A(this._flob_client), this._flob_client, function (t) {
                        return e._handleRemoteDslistUpdate(t);
                    }, function () {
                        return e._handleLocalDslistUpdate();
                    });
                }
                return t.prototype.datastoreListChanged = null, t.prototype.close = function () {
                    return this._obj_manager.destroy();
                }, t.prototype.toString = function () {
                    return 'Datastore.DatastoreManager()';
                }, t.prototype._dispatchDslistEvent = function () {
                    var t;
                    return t = this._lastListDsServerResponse || new k({
                        datastores: [],
                        token: 'dummy'
                    }), this.datastoreListChanged.dispatch(new D.Datastore.DatastoreListChanged(this._getOverlaidDatastoreInfosFromListResponse(t))), void 0;
                }, t.prototype._handleLocalDslistUpdate = function () {
                    return this._dispatchDslistEvent(), void 0;
                }, t.prototype._handleRemoteDslistUpdate = function (t) {
                    return this._lastListDsServerResponse = t, this._dispatchDslistEvent(), void 0;
                }, t.prototype._getOverlaidDatastoreInfo = function (t, e) {
                    var r, n, i, o, s, a, u;
                    r = this._obj_manager.getCachedDatastore(t), s = (null != e ? e.info : void 0) || {}, o = null == r ? te.clone(s) : null == e || e.rev < r.sync_state.get_server_rev() ? r.datastore_model.getLocalInfoData() : r.datastore_model.updateDatastoreInfo(s);
                    for (n in o)
                        u = o[n], o[n] = Z.is_array(u) ? function () {
                            var t, e, r;
                            for (r = [], t = 0, e = u.length; e > t; t++)
                                a = u[t], r.push(te.fromDsValue(null, null, null, a));
                            return r;
                        }() : te.fromDsValue(null, null, null, u);
                    return Z.is_empty(o) && (o = null), i = null != (null != e ? e.handle : void 0) ? e.handle : r.get_handle(), new D.Datastore.DatastoreInfo(t, i, o);
                }, t.prototype._getOverlaidDatastoreInfosFromListResponse = function (t) {
                    var e, r, n, i, o, s, a, u, l, h, c;
                    for (k.Type(t), e = this._obj_manager.getAllCachedDatastoreIDs(), s = {}, a = 0, l = e.length; l > a; a++)
                        i = e[a], s[i] = null;
                    for (c = t.datastores, u = 0, h = c.length; h > u; u++)
                        n = c[u], s[n.dsid] = n;
                    return function () {
                        var t;
                        t = [];
                        for (o in s)
                            r = s[o], t.push(this._getOverlaidDatastoreInfo(o, r));
                        return t;
                    }.call(this);
                }, t.prototype._wrapDatastore = function (t, e) {
                    return e && (t._update_mtime(), t.sync()), new D.Datastore(this, t);
                }, t.prototype._getOrCreateDatastoreByDsid = function (t, e) {
                    var r = this;
                    return this._flob_client.get_or_create_db(t, function (n, i) {
                        return null != n ? e(n) : null == i.handle ? e(new Error('get_or_create_datastore failed for ' + t)) : r._obj_manager.open(t, i.handle, function (t, n) {
                            return null != t ? e(t) : e(null, r._wrapDatastore(n, i.created));
                        });
                    }), void 0;
                }, t.prototype._createDatastore = function (t, e, r) {
                    var n = this;
                    return this._flob_client.create_db(t, e, function (e, i) {
                        return null != e ? r(e) : null == i.handle ? r(new Error('create_datastore failed for ' + t)) : n._obj_manager.open(t, i.handle, function (t, e) {
                            return null != t ? r(t) : r(null, n._wrapDatastore(e, i.created));
                        });
                    }), void 0;
                }, t.prototype._getExistingDatastoreByDsid = function (t, e) {
                    var r = this;
                    return this._flob_client.get_db(t, function (n, i) {
                        return null != n ? e(n) : null == i.handle ? e(new Error('Datastore ' + t + ' not found or not accessible')) : r._obj_manager.open(t, i.handle, function (t, n) {
                            return null != t ? e(t) : e(null, new D.Datastore(r, n));
                        });
                    }), void 0;
                }, t.prototype.openDefaultDatastore = function (t) {
                    return this._getOrCreateDatastoreByDsid(a, t), void 0;
                }, t.prototype.openOrCreateDatastore = function (t, e) {
                    return this._getOrCreateDatastoreByDsid(t, e), void 0;
                }, t.prototype.openDatastore = function (t, e) {
                    return this._getExistingDatastoreByDsid(t, e), void 0;
                }, t.prototype.createDatastore = function (t) {
                    var e, r;
                    return r = te.randomWeb64String(Math.ceil(256 / 6)), e = '.' + te.dbase64FromBase64(D.Util.sha256(r)), this._createDatastore(e, r, t), void 0;
                }, t.prototype.deleteDatastore = function (t, e) {
                    var r = this;
                    return this._flob_client.get_db(t, function (n, i) {
                        return null != n ? e(n) : null == i.handle ? e(new Error('Datastore ' + t + ' not found or not accessible')) : r._flob_client.delete_db(i.handle, function (t) {
                            return null != t ? e(t) : e(null);
                        });
                    }), void 0;
                }, t.prototype.listDatastores = function (t) {
                    var e = this;
                    return null != this._lastListDsServerResponse ? t(null, this._getOverlaidDatastoreInfosFromListResponse(this._lastListDsServerResponse)) : (this._flob_client.list_dbs(function (r, n) {
                        return null != r ? t(r) : t(null, e._getOverlaidDatastoreInfosFromListResponse(n));
                    }), void 0);
                }, t;
            }(), D.Datastore.List = function () {
                function t(t, e, r) {
                    this._datastore = t, this._record = e, this._field = r;
                }
                return t.BASE_ITEM_SIZE = 20, t.prototype.toString = function () {
                    return 'Datastore.List((' + this._record._tid + ', ' + this._record._rid + ', ' + this._field + '): ' + JSON.stringify(this._array) + ')';
                }, t.prototype._array = function () {
                    return this._record._rawFieldValues()[this._field];
                }, t.prototype._checkValid = function () {
                    if (this._record._checkNotDeleted(), !Z.is_array(this._array()))
                        throw new Error('Attempt to operate on deleted list (' + this._record._tid + ', ' + this._record._rid + ', ' + this._field + ')');
                }, t.prototype._storeUpdate = function (t) {
                    var e;
                    return e = {}, e[this._field] = t, this._record._storeUpdate(e), void 0;
                }, t.prototype._fixInsertionIndex = function (t) {
                    var e, r;
                    if (!Z.is_json_number(t))
                        throw new RangeError('Index not a number: ' + t);
                    if (e = this._array().length, r = t >= 0 ? t : e + t, r >= 0 && e >= r)
                        return r;
                    throw new RangeError('Bad index for list of length ' + e + ': ' + t);
                }, t.prototype._fixIndex = function (t) {
                    var e, r;
                    if (r = this._fixInsertionIndex(t), e = this._array().length, e > r)
                        return r;
                    throw new RangeError('Bad index for list of length ' + e + ': ' + t);
                }, t.prototype.get = function (t) {
                    var e;
                    return this._checkValid(), e = te.clone(this._array()[this._fixIndex(t)]), te.fromDsValue(void 0, void 0, void 0, e);
                }, t.prototype.set = function (t, e) {
                    return this._checkValid(), t = this._fixIndex(t), this._storeUpdate([
                        'LP',
                        t,
                        te.toDsValue(e, !1)
                    ]), void 0;
                }, t.prototype.length = function () {
                    return this._checkValid(), this._array().length;
                }, t.prototype.pop = function () {
                    if (this._checkValid(), 0 === this._array().length)
                        throw new Error('List is empty');
                    return this.remove(this._array.length - 1);
                }, t.prototype.push = function (t) {
                    return this._checkValid(), this.insert(this._array().length, t), void 0;
                }, t.prototype.shift = function () {
                    if (this._checkValid(), 0 === this._array().length)
                        throw new Error('List is empty');
                    return this.remove(0);
                }, t.prototype.unshift = function (t) {
                    return this.insert(0, t), void 0;
                }, t.prototype.splice = function () {
                    var t, e, r, n, i, o, s, a, u;
                    if (n = arguments[0], e = arguments[1], t = 3 <= arguments.length ? oe.call(arguments, 2) : [], this._checkValid(), !Z.is_json_number(e) || 0 > e)
                        throw new RangeError('Bad second arg to splice: ' + n + ', ' + e);
                    for (n = this._fixInsertionIndex(n), i = this.slice(n, n + e), r = s = 0; e >= 0 ? e > s : s > e; r = e >= 0 ? ++s : --s)
                        this.remove(n);
                    for (a = 0, u = t.length; u > a; a++)
                        o = t[a], this.insert(n, o), n++;
                    return i;
                }, t.prototype.move = function (t, e) {
                    return this._checkValid(), t = this._fixIndex(t), e = this._fixIndex(e), t === e ? void 0 : (this._storeUpdate([
                        'LM',
                        t,
                        e
                    ]), void 0);
                }, t.prototype.remove = function (t) {
                    var e;
                    return this._checkValid(), t = this._fixIndex(t), e = this.get(t), this._storeUpdate([
                        'LD',
                        t
                    ]), e;
                }, t.prototype.insert = function (t, e) {
                    return this._checkValid(), t = this._fixInsertionIndex(t), this._storeUpdate([
                        'LI',
                        t,
                        te.toDsValue(e, !1)
                    ]), void 0;
                }, t.prototype.slice = function (t, e) {
                    var r;
                    return this._checkValid(), function () {
                        var n, i, o, s;
                        for (o = this._array().slice(t, e), s = [], n = 0, i = o.length; i > n; n++)
                            r = o[n], s.push(te.fromDsValue(void 0, void 0, void 0, r));
                        return s;
                    }.call(this);
                }, t.prototype.toArray = function () {
                    var t;
                    return this._checkValid(), function () {
                        var e, r, n, i;
                        for (n = this._array().slice(), i = [], e = 0, r = n.length; r > e; e++)
                            t = n[e], i.push(te.fromDsValue(void 0, void 0, void 0, t));
                        return i;
                    }.call(this);
                }, t;
            }(), D.Datastore.Record = function () {
                function t(t, e, r) {
                    this._datastore = t, this._tid = e, this._rid = r, this._deleted = !1, this._record_cache = this._datastore._record_cache, this._managed_datastore = this._datastore._managed_datastore;
                }
                return t.RECORD_SIZE_LIMIT = 102400, t.BASE_RECORD_SIZE = 100, t.BASE_FIELD_SIZE = 100, t.prototype.get = function (t) {
                    var e;
                    return this._checkNotDeleted(), e = this._rawFieldValues(), t in e ? te.fromDsValue(this._datastore, this, t, e[t]) : null;
                }, t.prototype.set = function (t, e) {
                    var r;
                    return r = {}, r[t] = e, this.update(r);
                }, t.prototype.getOrCreateList = function (t) {
                    var e, r;
                    if (this._checkNotDeleted(), r = this._rawFieldValues(), null == r[t])
                        e = {}, e[t] = ['LC'], this._storeUpdate(e), r = this._rawFieldValues();
                    else if (!Z.is_array(r[t]))
                        throw new Error('Can\'t call getOrCreateList on field ' + t + ' for record (' + this.tid + ', ' + this.rid + '): existing value ' + r[t] + ' is not a list');
                    return te.fromDsValue(this._datastore, this, t, r[t]);
                }, t.prototype.getFields = function () {
                    var t, e, r, n;
                    this._checkNotDeleted(), t = {}, n = this._rawFieldValues();
                    for (e in n)
                        r = n[e], t[e] = te.fromDsValue(this._datastore, this, e, r);
                    return t;
                }, t.prototype.getSize = function () {
                    return this._managed_datastore.get_record_size(this._tid, this._rid);
                }, t.prototype.update = function (t) {
                    var e, r, n;
                    this._checkNotDeleted(), e = {};
                    for (r in t)
                        n = t[r], null != n ? e[r] = [
                            'P',
                            te.toDsValue(n)
                        ] : null != this.get(r) && (e[r] = ['D']);
                    return Z.is_empty(e) || this._storeUpdate(e), this;
                }, t.prototype.deleteRecord = function () {
                    var t;
                    return this._checkNotDeleted(), this._deleted = !0, this._record_cache.remove(this._tid, this._rid), t = n.from_array([
                        'D',
                        this._tid,
                        this._rid
                    ]), this._managed_datastore.perform_local_change(t), this._datastore._recordsChangedLocally([this]), this;
                }, t.prototype.has = function (t) {
                    var e;
                    return this._checkNotDeleted(), e = this._rawFieldValues(), t in e;
                }, t.prototype.getId = function () {
                    return this._rid;
                }, t.prototype.getTable = function () {
                    return this._datastore.getTable(this._tid);
                }, t.prototype.isDeleted = function () {
                    return this._deleted;
                }, t.prototype.toString = function () {
                    var t;
                    return t = this.isDeleted() ? 'deleted' : JSON.stringify(this.getFields()), 'Datastore.Record((' + this._tid + ', ' + this._rid + '): ' + t + ')';
                }, t.prototype._rawFieldValues = function () {
                    return this._managed_datastore.query(this._tid, this._rid);
                }, t.prototype._storeUpdate = function (t) {
                    var e;
                    e = n.from_array([
                        'U',
                        this._tid,
                        this._rid,
                        t
                    ]), this._managed_datastore.perform_local_change(e), this._datastore._recordsChangedLocally([this]);
                }, t.isValidId = function (t) {
                    var e;
                    return e = new RegExp(Z.SS_ID_REGEX), Z.is_string(t) && e.test(t);
                }, t.prototype._checkNotDeleted = function () {
                    if (this._deleted)
                        throw new Error('Attempt to operate on deleted record (' + this._tid + ', ' + this._rid + ')');
                }, t;
            }(), D.Datastore.RecordsChanged = function () {
                function t(t, e) {
                    this._recordsByTable = t, this._local = e;
                }
                return t.prototype.toString = function () {
                    var t, e, r, n, i, o, s;
                    i = 0, r = 0, s = this._recordsByTable;
                    for (o in s)
                        t = s[o], i += 1, r += t.length;
                    return n = '' + i + ' ' + (1 === i ? 'table' : 'tables'), e = '' + r + ' ' + (1 === r ? 'record' : 'records'), 'Datastore.RecordsChanged(' + e + ' in ' + n + ' changed ' + (this._local ? 'locally' : 'remotely') + ')';
                }, t._fromRecordList = function (e, r) {
                    var n, i, o, s, a;
                    for (i = {}, s = 0, a = e.length; a > s; s++)
                        n = e[s], o = n._tid, null == i[o] && (i[o] = []), i[o].push(n);
                    return new t(i, r);
                }, t.prototype.affectedRecordsByTable = function () {
                    return this._recordsByTable;
                }, t.prototype.affectedRecordsForTable = function (t) {
                    var e;
                    return null != (e = this._recordsByTable[t]) ? e : [];
                }, t.prototype.isLocal = function () {
                    return this._local;
                }, t;
            }(), V = D.Datastore.RecordsChanged, D.Datastore.Table = function () {
                function t(t, e) {
                    this._datastore = t, this._tid = e, this._record_cache = this._datastore._record_cache, this._managed_datastore = this._datastore._managed_datastore;
                }
                return t.prototype.getId = function () {
                    return this._tid;
                }, t.prototype.get = function (t) {
                    var e, r;
                    if (!D.Datastore.Record.isValidId(t))
                        throw new Error('Invalid record ID: ' + t);
                    return r = this._record_cache.get(this._tid, t), null != r ? (Y(!r._deleted), r) : (e = this._managed_datastore.query(this._tid, t), null == e ? null : this._record_cache.getOrCreate(this._tid, t));
                }, t.prototype.getOrInsert = function (t, e) {
                    var r;
                    return r = this.get(t), r ? r : this._insertWithId(t, e);
                }, t.prototype.insert = function (t) {
                    var e;
                    return e = this._datastore._generateRid(), Y(null == this.get(e)), this._insertWithId(e, t);
                }, t.prototype.query = function (t) {
                    var e, r, n, i, o, s, a;
                    for (o = this._managed_datastore.list_rows_for_table(this._tid), n = [], s = 0, a = o.length; a > s; s++)
                        i = o[s], e = this._managed_datastore.query(this._tid, i), (null == t || te.matchDsValues(t, e)) && (r = this.get(i), Y(null != r), n.push(r));
                    return n;
                }, t.prototype.setResolutionRule = function (t, e) {
                    if ('remote' !== e && 'local' !== e && 'min' !== e && 'max' !== e && 'sum' !== e)
                        throw new Error('' + e + ' is not a valid resolution rule. Valid rules are \'remote\', \'local\', \'min\', \'max\', and \'sum\'.');
                    return this._managed_datastore.resolver.add_resolution_rule(this._tid, t, e), this;
                }, t.isValidId = function (t) {
                    var e;
                    return e = new RegExp(Z.SS_ID_REGEX), Z.is_string(t) && e.test(t);
                }, t.prototype.toString = function () {
                    return 'Datastore.Table(' + this._tid + ')';
                }, t.prototype._insertWithId = function (t, e) {
                    var r, i, o, s, a;
                    i = {};
                    for (o in e)
                        a = e[o], i[o] = te.toDsValue(a);
                    return r = n.from_array([
                        'I',
                        this._tid,
                        t,
                        i
                    ]), this._managed_datastore.perform_local_change(r), s = this._record_cache.getOrCreate(this._tid, t), this._datastore._recordsChangedLocally([s]), s;
                }, t;
            }(), D.File.ShareUrl = function () {
                function t(t, e) {
                    this.url = t.url, this.expiresAt = D.Util.parseDate(t.expires), this.isDirect = e === !0 ? !0 : e === !1 ? !1 : 'direct' in t ? t.direct : Date.now() - this.expiresAt <= 86400000, this.isPreview = !this.isDirect, this._json = null;
                }
                return t.parse = function (t, e) {
                    return t && 'object' == typeof t ? new D.File.ShareUrl(t, e) : t;
                }, t.prototype.url = null, t.prototype.expiresAt = null, t.prototype.isDirect = null, t.prototype.isPreview = null, t.prototype.json = function () {
                    return this._json || (this._json = {
                        url: this.url,
                        expires: this.expiresAt.toUTCString(),
                        direct: this.isDirect
                    });
                }, t;
            }(), D.File.CopyReference = function () {
                function t(t) {
                    'object' == typeof t ? (this.tag = t.copy_ref, this.expiresAt = D.Util.parseDate(t.expires), this._json = t) : (this.tag = t, this.expiresAt = new Date(1000 * Math.ceil(Date.now() / 1000)), this._json = null);
                }
                return t.parse = function (t) {
                    return !t || 'object' != typeof t && 'string' != typeof t ? t : new D.File.CopyReference(t);
                }, t.prototype.tag = null, t.prototype.expiresAt = null, t.prototype.json = function () {
                    return this._json || (this._json = {
                        copy_ref: this.tag,
                        expires: this.expiresAt.toUTCString()
                    });
                }, t;
            }(), D.File.Stat = function () {
                function t(t) {
                    var e, r, n, i;
                    switch (this._json = t, this.path = t.path, '/' !== this.path.substring(0, 1) && (this.path = '/' + this.path), e = this.path.length - 1, e >= 0 && '/' === this.path.substring(e) && (this.path = this.path.substring(0, e)), r = this.path.lastIndexOf('/'), this.name = this.path.substring(r + 1), this.isFolder = t.is_dir || !1, this.isFile = !this.isFolder, this.isRemoved = t.is_deleted || !1, this.typeIcon = t.icon, this.modifiedAt = (null != (n = t.modified) ? n.length : void 0) ? D.Util.parseDate(t.modified) : null, this.clientModifiedAt = (null != (i = t.client_mtime) ? i.length : void 0) ? D.Util.parseDate(t.client_mtime) : null, t.root) {
                    case 'dropbox':
                        this.inAppFolder = !1;
                        break;
                    case 'app_folder':
                        this.inAppFolder = !0;
                        break;
                    default:
                        this.inAppFolder = null;
                    }
                    this.size = t.bytes || 0, this.humanSize = t.size || '', this.hasThumbnail = t.thumb_exists || !1, this.versionTag = t.rev, this.contentHash = t.hash || null, this.mimeType = this.isFolder ? t.mime_type || 'inode/directory' : t.mime_type || 'application/octet-stream';
                }
                return t.parse = function (t) {
                    return t && 'object' == typeof t ? new D.File.Stat(t) : t;
                }, t.prototype.path = null, t.prototype.name = null, t.prototype.inAppFolder = null, t.prototype.isFolder = null, t.prototype.isFile = null, t.prototype.isRemoved = null, t.prototype.typeIcon = null, t.prototype.versionTag = null, t.prototype.contentHash = null, t.prototype.mimeType = null, t.prototype.size = null, t.prototype.humanSize = null, t.prototype.hasThumbnail = null, t.prototype.modifiedAt = null, t.prototype.clientModifiedAt = null, t.prototype.json = function () {
                    return this._json;
                }, t;
            }(), D.Http.AppInfo = function () {
                function t(t, e) {
                    var r;
                    this.name = t.name, this._icons = t.icons, r = t.permissions || {}, this.canUseDatastores = !!r.datastores, this.canUseFiles = !!r.files, this.canUseFullDropbox = 'full_dropbox' === r.files, this.hasAppFolder = 'app_folder' === r.files, this.key = e ? e : t.key || null;
                }
                return t.parse = function (t, e) {
                    return t ? new D.Http.AppInfo(t, e) : t;
                }, t.prototype.name = void 0, t.prototype.key = void 0, t.prototype.canUseDatastores = void 0, t.prototype.canUseFiles = void 0, t.prototype.hasAppFolder = void 0, t.prototype.canUseFullDropbox = void 0, t.prototype.icon = function (t, e) {
                    return e || (e = t), this._icons['' + t + 'x' + e] || null;
                }, t.ICON_SMALL = 64, t.ICON_LARGE = 256, t;
            }(), D.Http.PulledChanges = function () {
                function t(t) {
                    var e;
                    this.blankSlate = t.reset || !1, this.cursorTag = t.cursor, this.shouldPullAgain = t.has_more, this.shouldBackOff = !this.shouldPullAgain, this.changes = t.cursor && t.cursor.length ? function () {
                        var r, n, i, o;
                        for (i = t.entries, o = [], r = 0, n = i.length; n > r; r++)
                            e = i[r], o.push(D.Http.PulledChange.parse(e));
                        return o;
                    }() : [];
                }
                return t.parse = function (t) {
                    return t && 'object' == typeof t ? new D.Http.PulledChanges(t) : t;
                }, t.prototype.blankSlate = void 0, t.prototype.cursorTag = void 0, t.prototype.changes = void 0, t.prototype.shouldPullAgain = void 0, t.prototype.shouldBackOff = void 0, t.prototype.cursor = function () {
                    return this.cursorTag;
                }, t;
            }(), D.Http.PulledChange = function () {
                function t(t) {
                    this.path = t[0], this.stat = D.File.Stat.parse(t[1]), this.stat ? this.wasRemoved = !1 : (this.stat = null, this.wasRemoved = !0);
                }
                return t.parse = function (t) {
                    return t && 'object' == typeof t ? new D.Http.PulledChange(t) : t;
                }, t.prototype.path = void 0, t.prototype.wasRemoved = void 0, t.prototype.stat = void 0, t;
            }(), D.Http.PollResult = function () {
                function t(t) {
                    this.hasChanges = t.changes, this.retryAfter = t.backoff || 0;
                }
                return t.parse = function (t) {
                    return t ? new D.Http.PollResult(t) : t;
                }, t.prototype.hasChanges = void 0, t.prototype.retryAfter = void 0, t;
            }(), D.Http.RangeInfo = function () {
                function t(t) {
                    var e;
                    (e = /^bytes (\d*)-(\d*)\/(.*)$/.exec(t)) ? (this.start = parseInt(e[1]), this.end = parseInt(e[2]), this.size = '*' === e[3] ? null : parseInt(e[3])) : (this.start = 0, this.end = 0, this.size = null);
                }
                return t.parse = function (t) {
                    return 'string' == typeof t ? new D.Http.RangeInfo(t) : t;
                }, t.prototype.start = null, t.prototype.size = null, t.prototype.end = null, t;
            }(), D.Http.UploadCursor = function () {
                function t(t) {
                    this.replace(t);
                }
                return t.parse = function (t) {
                    return !t || 'object' != typeof t && 'string' != typeof t ? t : new D.Http.UploadCursor(t);
                }, t.prototype.tag = null, t.prototype.offset = null, t.prototype.expiresAt = null, t.prototype.json = function () {
                    return this._json || (this._json = {
                        upload_id: this.tag,
                        offset: this.offset,
                        expires: this.expiresAt.toUTCString()
                    });
                }, t.prototype.replace = function (t) {
                    return 'object' == typeof t ? (this.tag = t.upload_id || null, this.offset = t.offset || 0, this.expiresAt = D.Util.parseDate(t.expires) || Date.now(), this._json = t) : (this.tag = t || null, this.offset = 0, this.expiresAt = new Date(1000 * Math.floor(Date.now() / 1000)), this._json = null), this;
                }, t;
            }(), 'function' == typeof D.Env.global.atob && 'function' == typeof D.Env.global.btoa ? (D.Util.atob = function (t) {
                return D.Env.global.atob(t);
            }, D.Util.btoa = function (t) {
                return D.Env.global.btoa(t);
            }) : D.Env.global.require && D.Env.global.Buffer ? (D.Util.atob = function (t) {
                var e, r;
                return e = new Buffer(t, 'base64'), function () {
                    var t, n, i;
                    for (i = [], r = t = 0, n = e.length; n >= 0 ? n > t : t > n; r = n >= 0 ? ++t : --t)
                        i.push(String.fromCharCode(e[r]));
                    return i;
                }().join('');
            }, D.Util.btoa = function (t) {
                var e, r;
                return e = new Buffer(function () {
                    var e, n, i;
                    for (i = [], r = e = 0, n = t.length; n >= 0 ? n > e : e > n; r = n >= 0 ? ++e : --e)
                        i.push(t.charCodeAt(r));
                    return i;
                }()), e.toString('base64');
            }) : !function () {
                var t, e, r;
                return e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', r = function (t, r, n) {
                    var i, o;
                    for (o = 3 - r, t <<= 8 * o, i = 3; i >= o;)
                        n.push(e.charAt(63 & t >> 6 * i)), i -= 1;
                    for (i = r; 3 > i;)
                        n.push('='), i += 1;
                    return null;
                }, t = function (t, e, r) {
                    var n, i;
                    for (i = 4 - e, t <<= 6 * i, n = 2; n >= i;)
                        r.push(String.fromCharCode(255 & t >> 8 * n)), n -= 1;
                    return null;
                }, D.Util.btoa = function (t) {
                    var e, n, i, o, s, a;
                    for (o = [], e = 0, n = 0, i = s = 0, a = t.length; a >= 0 ? a > s : s > a; i = a >= 0 ? ++s : --s)
                        e = e << 8 | t.charCodeAt(i), n += 1, 3 === n && (r(e, n, o), e = n = 0);
                    return n > 0 && r(e, n, o), o.join('');
                }, D.Util.atob = function (r) {
                    var n, i, o, s, a, u, l;
                    for (a = [], n = 0, o = 0, s = u = 0, l = r.length; (l >= 0 ? l > u : u > l) && (i = r.charAt(s), '=' !== i); s = l >= 0 ? ++u : --u)
                        n = n << 6 | e.indexOf(i), o += 1, 4 === o && (t(n, o, a), n = o = 0);
                    return o > 0 && t(n, o, a), a.join('');
                };
            }(), function () {
                var t, e, r, n, i, o, s, a, u, l, h;
                if (D.Util.hmac = function (e, n) {
                        return t(r(u(e), u(n), e.length, n.length));
                    }, D.Util.sha1 = function (e) {
                        return t(i(u(e), e.length));
                    }, D.Util.sha256 = function (e) {
                        return t(o(u(e), e.length));
                    }, D.Env.require)
                    try {
                        e = D.Env.require('crypto'), e.createHmac && e.createHash && (D.Util.hmac = function (t, r) {
                            var n;
                            return n = e.createHmac('sha1', r), n.update(t), n.digest('base64');
                        }, D.Util.sha1 = function (t) {
                            var r;
                            return r = e.createHash('sha1'), r.update(t), r.digest('base64');
                        }, D.Util.sha256 = function (t) {
                            var r;
                            return r = e.createHash('sha256'), r.update(t), r.digest('base64');
                        });
                    } catch (c) {
                        n = c;
                    }
                return r = function (t, e, r, n) {
                    var o, s, a, u;
                    return e.length > 16 && (e = i(e, n)), a = function () {
                        var t, r;
                        for (r = [], s = t = 0; 16 > t; s = ++t)
                            r.push(909522486 ^ e[s]);
                        return r;
                    }(), u = function () {
                        var t, r;
                        for (r = [], s = t = 0; 16 > t; s = ++t)
                            r.push(1549556828 ^ e[s]);
                        return r;
                    }(), o = i(a.concat(t), 64 + r), i(u.concat(o), 84);
                }, i = function (t, e) {
                    var r, n, i, o, s, a, u, l, h, c, d, p, _, f, g, y, m;
                    for (t[e >> 2] |= 1 << 31 - ((3 & e) << 3), t[(e + 8 >> 6 << 4) + 15] = e << 3, g = Array(80), r = 1732584193, i = 4023233417, s = 2562383102, u = 271733878, h = 3285377520, d = 0, _ = t.length; _ > d;) {
                        for (n = r, o = i, a = s, l = u, c = h, p = m = 0; 80 > m; p = ++m)
                            16 > p ? g[p] = 0 | t[d + p << 2 >> 2] : (f = (0 | g[p - 3 << 2 >> 2]) ^ (0 | g[p - 8 << 2 >> 2]) ^ (0 | g[p - 14 << 2 >> 2]) ^ (0 | g[p - 16 << 2 >> 2]), g[p] = f << 1 | f >>> 31), y = 0 | (0 | (r << 5 | r >>> 27) + h) + g[p << 2 >> 2], y = 20 > p ? 0 | y + (0 | (i & s | ~i & u) + 1518500249) : 40 > p ? 0 | y + (0 | (i ^ s ^ u) + 1859775393) : 60 > p ? 0 | (0 | y + ((i & s | i & u | s & u) - 1894007588)) : 0 | y + (0 | (i ^ s ^ u) - 899497514), h = u, u = s, s = i << 30 | i >>> 2, i = r, r = y;
                        r = 0 | n + r, i = 0 | o + i, s = 0 | a + s, u = 0 | l + u, h = 0 | c + h, d = 0 | d + 16;
                    }
                    return [
                        r,
                        i,
                        s,
                        u,
                        h
                    ];
                }, o = function (t, e) {
                    var r, n, i, o, u, l, h, c, d, p, _, f, g, y, m, v, w, b, S, D, E, A, I, O, x, T, U, C, R, k, P, L;
                    for (t[e >> 2] |= 1 << 31 - ((3 & e) << 3), t[(e + 8 >> 6 << 4) + 15] = e << 3, R = Array(80), r = s[0], i = s[1], u = s[2], c = s[3], p = s[4], f = s[5], y = s[6], D = s[7], A = 0, O = t.length; O > A;) {
                        for (n = r, o = i, l = u, d = c, _ = p, g = f, m = y, E = D, I = L = 0; 64 > L; I = ++L)
                            16 > I ? C = R[I] = 0 | t[A + I << 2 >> 2] : (w = 0 | R[I - 15 << 2 >> 2], v = (w << 25 | w >>> 7) ^ (w << 14 | w >>> 18) ^ w >>> 3, S = 0 | R[I - 2 << 2 >> 2], b = (S << 15 | S >>> 17) ^ (S << 13 | S >>> 19) ^ S >>> 10, C = R[I] = 0 | (0 | v + (0 | R[I - 7 << 2 >> 2])) + (0 | b + (0 | R[I - 16 << 2 >> 2]))), h = p & f ^ ~p & y, x = r & i ^ r & u ^ i & u, T = (r << 30 | r >>> 2) ^ (r << 19 | r >>> 13) ^ (r << 10 | r >>> 22), U = (p << 26 | p >>> 6) ^ (p << 21 | p >>> 11) ^ (p << 7 | p >>> 25), k = 0 | (0 | (0 | D + U) + (0 | h + C)) + (0 | a[I << 2 >> 2]), P = 0 | T + x, D = y, y = f, f = p, p = 0 | c + k, c = u, u = i, i = r, r = 0 | k + P;
                        r = 0 | n + r, i = 0 | o + i, u = 0 | l + u, c = 0 | d + c, p = 0 | _ + p, f = 0 | g + f, y = 0 | m + y, D = 0 | E + D, A += 16;
                    }
                    return [
                        r,
                        i,
                        u,
                        c,
                        p,
                        f,
                        y,
                        D
                    ];
                }, l = function (t) {
                    return 0 > t && (t = 4 * (1 << 30) + t), t.toString(16);
                }, s = [], a = [], function () {
                    var t, e, r, n, i, o, u;
                    for (e = function (t) {
                            return 0 | 4294967296 * (t - Math.floor(t));
                        }, i = 2, u = [], r = o = 0; 64 > o; r = ++o) {
                        for (;;) {
                            for (n = !0, t = 2; i >= t * t;) {
                                if (0 === i % t) {
                                    n = !1;
                                    break;
                                }
                                t += 1;
                            }
                            if (n)
                                break;
                            i += 1;
                        }
                        8 > r && (s[r] = e(Math.pow(i, 0.5))), a[r] = e(Math.pow(i, 1 / 3)), u.push(i += 1);
                    }
                    return u;
                }(), t = function (t) {
                    var e, r, n, i, o;
                    for (i = '', e = 0, n = 4 * t.length; n > e;)
                        r = e, o = (255 & t[r >> 2] >> (3 - (3 & r) << 3)) << 16, r += 1, o |= (255 & t[r >> 2] >> (3 - (3 & r) << 3)) << 8, r += 1, o |= 255 & t[r >> 2] >> (3 - (3 & r) << 3), i += h[63 & o >> 18], i += h[63 & o >> 12], e += 1, i += e >= n ? '=' : h[63 & o >> 6], e += 1, i += e >= n ? '=' : h[63 & o], e += 1;
                    return i;
                }, h = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', u = function (t) {
                    var e, r, n, i, o;
                    for (e = [], n = 255, r = i = 0, o = t.length; o >= 0 ? o > i : i > o; r = o >= 0 ? ++i : --i)
                        e[r >> 2] |= (t.charCodeAt(r) & n) << (3 - (3 & r) << 3);
                    return e;
                };
            }(), D.Util.Oauth = function () {
                function t(t) {
                    this._id = null, this._secret = null, this._stateParam = null, this._authCode = null, this._token = null, this._tokenKey = null, this._tokenKid = null, this._error = null, this._appHash = null, this._loaded = null, this.setCredentials(t);
                }
                return t.prototype.setCredentials = function (t) {
                    if (t.key)
                        this._id = t.key;
                    else {
                        if (!t.token)
                            throw new Error('No API key supplied');
                        this._id = null;
                    }
                    return this._secret = t.secret || null, this._appHash = null, this._error = null, this._loaded = !0, this.reset(), t.token ? (this._token = t.token, t.tokenKey && (this._tokenKey = t.tokenKey, this._tokenKid = t.tokenKid)) : t.oauthCode ? this._authCode = t.oauthCode : t.oauthStateParam && (this._stateParam = t.oauthStateParam), this;
                }, t.prototype.credentials = function () {
                    var t;
                    return t = {}, this._id && (t.key = this._id), this._secret && (t.secret = this._secret), null !== this._token ? (t.token = this._token, this._tokenKey && (t.tokenKey = this._tokenKey, t.tokenKid = this._tokenKid)) : null !== this._authCode ? t.oauthCode = this._authCode : null !== this._stateParam && (t.oauthStateParam = this._stateParam), t;
                }, t.prototype.step = function () {
                    return null !== this._token ? D.Client.DONE : null !== this._authCode ? D.Client.AUTHORIZED : null !== this._stateParam ? this._loaded ? D.Client.PARAM_LOADED : D.Client.PARAM_SET : null !== this._error ? D.Client.ERROR : D.Client.RESET;
                }, t.prototype.setAuthStateParam = function (t) {
                    if (null === this._id)
                        throw new Error('No API key supplied, cannot do authorization');
                    return this.reset(), this._loaded = !1, this._stateParam = t, this;
                }, t.prototype.checkAuthStateParam = function (t) {
                    return this._stateParam === t && null !== this._stateParam;
                }, t.prototype.authStateParam = function () {
                    return this._stateParam;
                }, t.prototype.error = function () {
                    return this._error;
                }, t.prototype.processRedirectParams = function (t) {
                    var e;
                    if (t.error) {
                        if (null === this._id)
                            throw new Error('No API key supplied, cannot process errors');
                        return this.reset(), this._error = new D.AuthError(t), !0;
                    }
                    if (t.code) {
                        if (null === this._id)
                            throw new Error('No API key supplied, cannot do Authorization Codes');
                        return this.reset(), this._loaded = !1, this._authCode = t.code, !0;
                    }
                    if (e = t.token_type) {
                        if (e = e.toLowerCase(), 'bearer' !== e && 'mac' !== e)
                            throw new Error('Unimplemented token type ' + e);
                        if (this.reset(), this._loaded = !1, 'mac' === e) {
                            if ('hmac-sha-1' !== t.mac_algorithm)
                                throw new Error('Unimplemented MAC algorithms ' + t.mac_algorithm);
                            this._tokenKey = t.mac_key, this._tokenKid = t.kid;
                        }
                        return this._token = t.access_token, !0;
                    }
                    return !1;
                }, t.prototype.authHeader = function (t, e, r) {
                    var n, i;
                    return null === this._token ? (i = null === this._secret ? D.Util.btoa('' + this._id + ':') : D.Util.btoa('' + this._id + ':' + this._secret), 'Basic ' + i) : null === this._tokenKey ? 'Bearer ' + this._token : (n = this.macParams(t, e, r), 'MAC kid=' + n.kid + ' ts=' + n.ts + ' ' + ('access_token=' + this._token + ' mac=' + n.mac));
                }, t.prototype.addAuthParams = function (t, e, r) {
                    var n;
                    return null === this._token ? (r.client_id = this._id, null !== this._secret && (r.client_secret = this._secret)) : (null !== this._tokenKey && (n = this.macParams(t, e, r), r.kid = n.kid, r.ts = n.ts, r.mac = n.mac), r.access_token = this._token), r;
                }, t.prototype.authorizeUrlParams = function (t, e) {
                    var r;
                    if ('token' !== t && 'code' !== t)
                        throw new Error('Unimplemented /authorize response type ' + t);
                    return r = {
                        client_id: this._id,
                        state: this._stateParam,
                        response_type: t
                    }, e && (r.redirect_uri = e), r;
                }, t.prototype.accessTokenParams = function (t) {
                    var e;
                    return e = {
                        grant_type: 'authorization_code',
                        code: this._authCode
                    }, t && (e.redirect_uri = t), e;
                }, t.queryParamsFromUrl = function (t) {
                    var e, r, n, i, o, s, a, u, l, h;
                    if (i = /^[^?#]+(\?([^\#]*))?(\#(.*))?$/.exec(t), !i)
                        return {};
                    for (a = i[2] || '', '/' === a.substring(0, 1) && (a = a.substring(1)), e = i[4] || '', r = e.indexOf('?'), -1 !== r && (e = e.substring(r + 1)), '/' === e.substring(0, 1) && (e = e.substring(1)), s = {}, h = a.split('&').concat(e.split('&')), u = 0, l = h.length; l > u; u++)
                        n = h[u], o = n.indexOf('='), -1 !== o && (s[decodeURIComponent(n.substring(0, o))] = decodeURIComponent(n.substring(o + 1)));
                    return s;
                }, t.prototype.macParams = function (t, e, r) {
                    var n, i;
                    return n = {
                        kid: this._tokenKid,
                        ts: D.Util.Oauth.timestamp()
                    }, i = t.toUpperCase() + '&' + D.Util.Xhr.urlEncodeValue(e) + '&' + D.Util.Xhr.urlEncodeValue(D.Util.Xhr.urlEncode(r)), n.mac = D.Util.hmac(i, this._tokenKey), n;
                }, t.prototype.appHash = function () {
                    return this._appHash ? this._appHash : this._appHash = D.Util.sha1('oauth2-' + this._id).replace(/[\/+=]/g, '');
                }, t.prototype.reset = function () {
                    return this._stateParam = null, this._authCode = null, this._token = null, this._tokenKey = null, this._tokenKid = null, this._error = null, this;
                }, t.timestamp = function () {
                    return Math.floor(Date.now() / 1000);
                }, t.randomAuthStateParam = function () {
                    return [
                        'oas',
                        Date.now().toString(36),
                        Math.random().toString(36)
                    ].join('_');
                }, t;
            }(), null == Date.now && (D.Util.Oauth.timestamp = function () {
                return Math.floor(new Date().getTime() / 1000);
            }), 2274814865000 === new Date('Fri, 31 Jan 2042 21:01:05 +0000').valueOf() ? D.Util.parseDate = function (t) {
                return new Date(t);
            } : 2274814865000 === Date.parse('Fri, 31 Jan 2042 21:01:05 +0000') ? D.Util.parseDate = function (t) {
                return new Date(Date.parse(t));
            } : !function () {
                var t, e;
                return e = /^\w+\, (\d+) (\w+) (\d+) (\d+)\:(\d+)\:(\d+) (\+\d+|UTC|GMT)$/, t = {
                    Jan: 0,
                    Feb: 1,
                    Mar: 2,
                    Apr: 3,
                    May: 4,
                    Jun: 5,
                    Jul: 6,
                    Aug: 7,
                    Sep: 8,
                    Oct: 9,
                    Nov: 10,
                    Dec: 11
                }, D.Util.parseDate = function (r) {
                    var n;
                    return (n = e.exec(r)) ? new Date(Date.UTC(parseInt(n[3]), t[n[2]], parseInt(n[1]), parseInt(n[4]), parseInt(n[5]), parseInt(n[6]), 0)) : 0 / 0;
                };
            }(), D.Util.countUtf8Bytes = function (t) {
                var e, r, n, i, o;
                for (e = 0, n = i = 0, o = t.length; o >= 0 ? o > i : i > o; n = o >= 0 ? ++i : --i)
                    r = t.charCodeAt(n), 127 >= r ? e += 1 : 2047 >= r ? e += 2 : r >= 55296 && 57343 >= r ? e += 2 : 65535 >= r ? e += 3 : Y(!1);
                return e;
            }, D.Env.global.XMLHttpRequest ? (!D.Env.global.XDomainRequest || 'withCredentials' in new XMLHttpRequest() ? (y = XMLHttpRequest, g = !1, _ = 'undefined' != typeof FormData && -1 === navigator.userAgent.indexOf('Firefox')) : (y = XDomainRequest, g = !0, _ = !1), f = !0) : (y = D.Env.require('xhr2'), g = !1, _ = !1, f = !1), D.Env.global.Uint8Array)
            if (Object.getPrototypeOf ? p = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array(0))).constructor : Object.__proto__ && (p = new Uint8Array(0).__proto__.__proto__.constructor), D.Env.global.Blob) {
                try {
                    !function () {
                        return 2 === new Blob([new Uint8Array(2)]).size ? (v = !0, m = !0) : (m = !1, v = 2 === new Blob([new ArrayBuffer(2)]).size);
                    }();
                } catch (se) {
                    m = !1, v = !1, D.Env.global.WebKitBlobBuilder && -1 !== navigator.userAgent.indexOf('Android') && (_ = !1);
                }
                p === Object && (m = !1);
            } else
                v = !1, m = !0;
        else
            p = null, v = !1, m = !1;
        D.Util.Xhr = function () {
            function t(t, e) {
                this.method = t, this.isGet = 'GET' === this.method, this.url = e, this.wantHeaders = !1, this.headers = {}, this.params = null, this.body = null, this.preflight = !(this.isGet || 'POST' === this.method), this.signed = !1, this.completed = !1, this.responseType = null, this.callback = null, this.xhr = null, this.onError = null;
            }
            return t.Request = y, t.ieXdr = g, t.canSendForms = _, t.doesPreflight = f, t.ArrayBufferView = p, t.sendArrayBufferView = m, t.wrapBlob = v, t.prototype.xhr = null, t.prototype.onError = null, t.prototype.setParams = function (t) {
                if (this.signed)
                    throw new Error('setParams called after addOauthParams or addOauthHeader');
                if (this.params)
                    throw new Error('setParams cannot be called twice');
                return this.params = t, this;
            }, t.prototype.setCallback = function (t) {
                return this.callback = t, this;
            }, t.prototype.signWithOauth = function (t, e) {
                return D.Util.Xhr.ieXdr ? this.addOauthParams(t) : this.preflight || !D.Util.Xhr.doesPreflight ? this.addOauthHeader(t) : this.isGet && e ? this.addOauthHeader(t) : this.addOauthParams(t);
            }, t.prototype.addOauthParams = function (t) {
                if (this.signed)
                    throw new Error('Request already has an OAuth signature');
                return this.params || (this.params = {}), t.addAuthParams(this.method, this.url, this.params), this.signed = !0, this;
            }, t.prototype.addOauthHeader = function (t) {
                if (this.signed)
                    throw new Error('Request already has an OAuth signature');
                return this.params || (this.params = {}), this.signed = !0, this.setHeader('Authorization', t.authHeader(this.method, this.url, this.params));
            }, t.prototype.setBody = function (t) {
                if (this.isGet)
                    throw new Error('setBody cannot be called on GET requests');
                if (null !== this.body)
                    throw new Error('Request already has a body');
                return 'string' == typeof t || 'undefined' != typeof FormData && t instanceof FormData || (this.headers['Content-Type'] = 'application/octet-stream', this.preflight = !0), this.body = t, this;
            }, t.prototype.setResponseType = function (t) {
                return this.responseType = t, this;
            }, t.prototype.setHeader = function (t, e) {
                var r;
                if (this.headers[t])
                    throw r = this.headers[t], new Error('HTTP header ' + t + ' already set to ' + r);
                if ('Content-Type' === t)
                    throw new Error('Content-Type is automatically computed based on setBody');
                return this.preflight = !0, this.headers[t] = e, this;
            }, t.prototype.reportResponseHeaders = function () {
                return this.wantHeaders = !0;
            }, t.prototype.setFileField = function (t, e, r, n) {
                var i, o, s, a, u;
                if (null !== this.body)
                    throw new Error('Request already has a body');
                if (this.isGet)
                    throw new Error('setFileField cannot be called on GET requests');
                if ('object' == typeof r) {
                    'undefined' != typeof ArrayBuffer && (r instanceof ArrayBuffer ? D.Util.Xhr.sendArrayBufferView && (r = new Uint8Array(r)) : !D.Util.Xhr.sendArrayBufferView && 0 === r.byteOffset && r.buffer instanceof ArrayBuffer && (r = r.buffer)), n || (n = 'application/octet-stream');
                    try {
                        r = new Blob([r], { type: n });
                    } catch (l) {
                        o = l, window.WebKitBlobBuilder && (a = new WebKitBlobBuilder(), a.append(r), (i = a.getBlob(n)) && (r = i));
                    }
                    'undefined' != typeof File && r instanceof File && (r = new Blob([r], { type: r.type })), u = r instanceof Blob;
                } else
                    u = !1;
                return u ? (this.body = new FormData(), this.body.append(t, r, e)) : (n || (n = 'application/octet-stream'), s = this.multipartBoundary(), this.headers['Content-Type'] = 'multipart/form-data; boundary=' + s, this.body = [
                    '--',
                    s,
                    '\r\n',
                    'Content-Disposition: form-data; name="',
                    t,
                    '"; filename="',
                    e,
                    '"\r\n',
                    'Content-Type: ',
                    n,
                    '\r\n',
                    'Content-Transfer-Encoding: binary\r\n\r\n',
                    r,
                    '\r\n',
                    '--',
                    s,
                    '--',
                    '\r\n'
                ].join(''));
            }, t.prototype.multipartBoundary = function () {
                return [
                    Date.now().toString(36),
                    Math.random().toString(36)
                ].join('----');
            }, t.prototype.paramsToUrl = function () {
                var t;
                return this.params && (t = D.Util.Xhr.urlEncode(this.params), 0 !== t.length && (this.url = [
                    this.url,
                    '?',
                    t
                ].join('')), this.params = null), this;
            }, t.prototype.paramsToBody = function () {
                if (this.params) {
                    if (null !== this.body)
                        throw new Error('Request already has a body');
                    if (this.isGet)
                        throw new Error('paramsToBody cannot be called on GET requests');
                    this.headers['Content-Type'] = 'application/x-www-form-urlencoded', this.body = D.Util.Xhr.urlEncode(this.params), this.params = null;
                }
                return this;
            }, t.prototype.prepare = function () {
                var t, e, r, n, i = this;
                if (e = D.Util.Xhr.ieXdr, this.isGet || null !== this.body || e ? (this.paramsToUrl(), null !== this.body && 'string' == typeof this.body && (this.headers['Content-Type'] = 'text/plain; charset=utf8')) : this.paramsToBody(), this.xhr = new D.Util.Xhr.Request(), e ? (this.xhr.onload = function () {
                        return i.onXdrLoad();
                    }, this.xhr.onerror = function () {
                        return i.onXdrError();
                    }, this.xhr.ontimeout = function () {
                        return i.onXdrError();
                    }, this.xhr.onprogress = function () {
                    }) : this.xhr.onreadystatechange = function () {
                        return i.onReadyStateChange();
                    }, this.xhr.open(this.method, this.url, !0), !e) {
                    n = this.headers;
                    for (t in n)
                        re.call(n, t) && (r = n[t], this.xhr.setRequestHeader(t, r));
                }
                return this.responseType && ('b' === this.responseType ? this.xhr.overrideMimeType && this.xhr.overrideMimeType('text/plain; charset=x-user-defined') : this.xhr.responseType = this.responseType), this;
            }, t.prototype.send = function (t) {
                var e, r;
                if (this.callback = t || this.callback, null !== this.body) {
                    e = this.body, D.Util.Xhr.sendArrayBufferView ? e instanceof ArrayBuffer && (e = new Uint8Array(e)) : 0 === e.byteOffset && e.buffer instanceof ArrayBuffer && (e = e.buffer);
                    try {
                        this.xhr.send(e);
                    } catch (n) {
                        if (r = n, D.Util.Xhr.sendArrayBufferView || !D.Util.Xhr.wrapBlob)
                            throw r;
                        e = new Blob([e], { type: 'application/octet-stream' }), this.xhr.send(e);
                    }
                } else
                    this.xhr.send();
                return this;
            }, t.urlEncode = function (t) {
                var e, r, n;
                e = [];
                for (r in t)
                    n = t[r], e.push(this.urlEncodeValue(r) + '=' + this.urlEncodeValue(n));
                return e.sort().join('&');
            }, t.urlEncodeValue = function (t) {
                return encodeURIComponent(t.toString()).replace(/\!/g, '%21').replace(/'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/\*/g, '%2A');
            }, t.urlDecode = function (t) {
                var e, r, n, i, o, s;
                for (r = {}, s = t.split('&'), i = 0, o = s.length; o > i; i++)
                    n = s[i], e = n.split('='), r[decodeURIComponent(e[0])] = decodeURIComponent(e[1]);
                return r;
            }, t.prototype.onReadyStateChange = function () {
                var t, e, r, n, i, o, s, a, u, l, h, c, d, p, _;
                if (4 !== this.xhr.readyState)
                    return !0;
                if (this.completed)
                    return !0;
                if (this.completed = !0, this.xhr.status < 200 || this.xhr.status >= 300)
                    return e = new D.ApiError(this.xhr, this.method, this.url), this.onError ? this.onError(e, this.callback) : this.callback(e), !0;
                if (this.wantHeaders ? (t = this.xhr.getAllResponseHeaders(), s = t ? D.Util.Xhr.parseResponseHeaders(t) : this.guessResponseHeaders(), h = s['x-dropbox-metadata']) : (s = void 0, h = this.xhr.getResponseHeader('x-dropbox-metadata')), null != h ? h.length : void 0)
                    try {
                        l = JSON.parse(h);
                    } catch (f) {
                        if (u = f, o = h.search(/\}\,\s*\{/), -1 !== o)
                            try {
                                h = h.substring(0, o + 1), l = JSON.parse(h);
                            } catch (f) {
                                u = f, l = void 0;
                            }
                        else
                            l = void 0;
                    }
                else
                    l = void 0;
                if (this.responseType) {
                    if ('b' === this.responseType) {
                        for (i = null != this.xhr.responseText ? this.xhr.responseText : this.xhr.response, r = [], a = p = 0, _ = i.length; _ >= 0 ? _ > p : p > _; a = _ >= 0 ? ++p : --p)
                            r.push(String.fromCharCode(255 & i.charCodeAt(a)));
                        d = r.join(''), this.callback(null, d, l, s);
                    } else
                        this.callback(null, this.xhr.response, l, s);
                    return !0;
                }
                switch (d = null != this.xhr.responseText ? this.xhr.responseText : this.xhr.response, n = this.xhr.getResponseHeader('Content-Type'), n && (c = n.indexOf(';'), -1 !== c && (n = n.substring(0, c))), n) {
                case 'application/x-www-form-urlencoded':
                    this.callback(null, D.Util.Xhr.urlDecode(d), l, s);
                    break;
                case 'application/json':
                case 'text/javascript':
                    this.callback(null, JSON.parse(d), l, s);
                    break;
                default:
                    this.callback(null, d, l, s);
                }
                return !0;
            }, t.parseResponseHeaders = function (t) {
                var e, r, n, i, o, s, a, u;
                for (n = {}, r = t.split('\n'), a = 0, u = r.length; u > a; a++)
                    i = r[a], e = i.indexOf(':'), o = i.substring(0, e).trim().toLowerCase(), s = i.substring(e + 1).trim(), n[o] = s;
                return n;
            }, t.prototype.guessResponseHeaders = function () {
                var t, e, r, n, i, o;
                for (t = {}, o = [
                        'cache-control',
                        'content-language',
                        'content-range',
                        'content-type',
                        'expires',
                        'last-modified',
                        'pragma',
                        'x-dropbox-metadata'
                    ], n = 0, i = o.length; i > n; n++)
                    e = o[n], r = this.xhr.getResponseHeader(e), r && (t[e] = r);
                return t;
            }, t.prototype.onXdrLoad = function () {
                var t, e, r;
                if (this.completed)
                    return !0;
                if (this.completed = !0, r = this.xhr.responseText, t = this.wantHeaders ? { 'content-type': this.xhr.contentType } : void 0, e = void 0, this.responseType)
                    return this.callback(null, r, e, t), !0;
                switch (this.xhr.contentType) {
                case 'application/x-www-form-urlencoded':
                    this.callback(null, D.Util.Xhr.urlDecode(r), e, t);
                    break;
                case 'application/json':
                case 'text/javascript':
                    this.callback(null, JSON.parse(r), e, t);
                    break;
                default:
                    this.callback(null, r, e, t);
                }
                return !0;
            }, t.prototype.onXdrError = function () {
                var t;
                return this.completed ? !0 : (this.completed = !0, t = new D.ApiError(this.xhr, this.method, this.url), this.onError ? this.onError(t, this.callback) : this.callback(t), !0);
            }, t;
        }(), Q = 'X-Dropbox-User-Agent', M = 'X-Dropbox-Request-Id', D.DatastoresClient = {
            _dispatchDatastoreXhr: function (t, e, r, n, i, o) {
                var s, a, l;
                return l = new D.Util.Xhr(t, e), i.setRequestId && (a = 'xxxxxxxxxxxxxxxx'.replace(/x/g, function () {
                    return Math.floor(16 * Math.random()).toString(16);
                }), l.setHeader(M, a)), Y(null == r[Q]), r = te.clone(r), r[Q] = 'dropbox-js-datastore-sdk/' + u, l.setParams(r), l.signWithOauth(this._oauth, !1), s = function (t, e) {
                    return null != t ? o(t) : o(null, n.fromJSON(e));
                }, i.isLongPoll ? this._dispatchLongPollXhr(l, s) : this._dispatchXhr(l, s), l;
            },
            _listDatastores: function (t) {
                return this._dispatchDatastoreXhr('GET', this._urls.listDbs, {}, k, {}, t);
            },
            _getOrCreateDatastore: function (t, e) {
                return this._dispatchDatastoreXhr('POST', this._urls.getOrCreateDb, { dsid: t }, s, {}, e);
            },
            _createDatastore: function (t, e, r) {
                return this._dispatchDatastoreXhr('POST', this._urls.createDb, {
                    dsid: t,
                    key: e
                }, s, {}, r);
            },
            _getDatastore: function (t, e) {
                return this._dispatchDatastoreXhr('GET', this._urls.getDb, { dsid: t }, T, {}, e);
            },
            _deleteDatastore: function (t, e) {
                return this._dispatchDatastoreXhr('POST', this._urls.deleteDb, { handle: t }, b, { setRequestId: !0 }, e);
            },
            _putDelta: function (t, e, r) {
                return this._dispatchDatastoreXhr('POST', this._urls.putDelta, {
                    handle: t,
                    rev: e.rev,
                    nonce: e.nonce,
                    changes: JSON.stringify(e.changes)
                }, X, { setRequestId: !0 }, r);
            },
            _getSnapshot: function (t, e) {
                return this._dispatchDatastoreXhr('GET', this._urls.getSnapshot, { handle: t }, C, {}, e);
            },
            _datastoreAwait: function (e, r, n) {
                return this._dispatchDatastoreXhr('POST', this._urls.datastoreAwait, {
                    get_deltas: JSON.stringify({ cursors: e }),
                    list_datastores: JSON.stringify({ token: r })
                }, t, {
                    isLongPoll: !0,
                    setRequestId: !0
                }, n);
            },
            getDatastoreManager: function () {
                var t, e = this;
                return null == this._datastoreManager && (this._datastoreManager = new D.Datastore.DatastoreManager(this), t = function () {
                    return e.authStep === D.Client.SIGNED_OUT ? (e._datastoreManager.close(), e._datastoreManager = null, e.onAuthStepChange.removeListener(t)) : void 0;
                }, this.onAuthStepChange.addListener(t)), this._datastoreManager;
            }
        }, function () {
            var t, e, r, n;
            r = D.DatastoresClient, n = [];
            for (e in r)
                t = r[e], n.push(D.Client.prototype[e] = t);
            return n;
        }();
    }.call(this));
    if (typeof module != 'undefined') {
        window.Dropbox = module.exports;
    }
    return Dropbox;
});
(function () {
    var __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };
    define('views/authorize_view', [
        'backbone',
        'app'
    ], function (Backbone, app) {
        var AuthorizeView;
        return AuthorizeView = function (_super) {
            __extends(AuthorizeView, _super);
            function AuthorizeView() {
                return AuthorizeView.__super__.constructor.apply(this, arguments);
            }
            AuthorizeView.prototype.className = 'authorize-view';
            AuthorizeView.prototype.template = '<div class="close-button">&times;</div>\n<iframe></iframe>';
            AuthorizeView.show = function (url) {
                var view;
                view = new AuthorizeView();
                view.render();
                $('#main').append(view.el);
                view.$('iframe').attr('src', url);
                return view;
            };
            return AuthorizeView;
        }(Backbone.View);
    });
}.call(this));
(function () {
    define('services/dropbox_service', [
        'dropbox',
        'lodash',
        'app',
        'views/authorize_view'
    ], function (Dropbox, _, app, AuthorizeView) {
        var DropboxService;
        return DropboxService = function () {
            function DropboxService() {
                this.isReady = false;
                this.client = new Dropbox.Client({ key: 'hlzfj39a4cfzpri' });
                if (typeof cordova !== 'undefined' && cordova !== null) {
                    this.client.authDriver(new Dropbox.AuthDriver.Cordova());
                } else {
                    this.client.authDriver(new Dropbox.AuthDriver.Popup({ receiverUrl: 'https://scalableminds.github.io/scratchpad/oauth_receiver.html' }));
                }
                this.client.authenticate({ interactive: false });
                if (this.isAuthenticated()) {
                    this.initDatastore();
                    app.trigger('dropboxService:authenticated');
                }
            }
            DropboxService.prototype.authenticate = function () {
                this.client.authenticate(function (_this) {
                    return function (error) {
                        if (error) {
                            return console.error('dropboxService:authenticationError', error);
                        } else {
                            app.trigger('dropboxService:authenticated');
                            return _this.initDatastore();
                        }
                    };
                }(this));
                return this;
            };
            DropboxService.prototype.initDatastore = function () {
                var datastoreManager;
                datastoreManager = this.client.getDatastoreManager();
                datastoreManager.openDefaultDatastore(function (_this) {
                    return function (error, datastore) {
                        if (error) {
                            console.error('dropboxService:datastoreError', error);
                            return _this.initDatastore();
                        } else {
                            _this.datastore = datastore;
                            _this.notesTable = _this.datastore.getTable('notes');
                            _this.datastore.syncStatusChanged.addListener(function () {
                                console.log('dropbox syncing', _this.datastore.getSyncStatus().uploading);
                                if (_this.datastore.getSyncStatus().uploading) {
                                    app.trigger('dropboxService:syncing');
                                } else {
                                    app.trigger('dropboxService:synced');
                                }
                            });
                            _this.datastore.recordsChanged.addListener(function (changes) {
                                if (changes.isLocal()) {
                                    app.trigger('dropboxService:recordsChangedLocal', changes);
                                } else {
                                    app.trigger('dropboxService:recordsChangedRemote', changes);
                                }
                                app.trigger('dropboxService:recordsChanged', changes);
                            });
                            if (!_this.isReady) {
                                _this.isReady = true;
                                return app.trigger('dropboxService:ready', _this);
                            }
                        }
                    };
                }(this));
                return this;
            };
            DropboxService.prototype.isAuthenticated = function () {
                return this.client.isAuthenticated();
            };
            DropboxService.prototype.isTransient = function () {
                var _ref;
                return (_ref = this.datastore) != null ? _ref.getSyncStatus().uploading : void 0;
            };
            DropboxService.prototype.updateNote = function (id, obj) {
                var record;
                if (this.isReady) {
                    if (record = this.notesTable.get('note-' + id)) {
                        return record.update(obj);
                    } else {
                        return this.notesTable.getOrInsert('note-' + id, obj);
                    }
                }
            };
            DropboxService.prototype.getNote = function (id) {
                var _ref;
                if (this.isReady) {
                    return (_ref = this.notesTable.get('note-' + id)) != null ? _ref.getFields() : void 0;
                }
            };
            return DropboxService;
        }();
    });
}.call(this));
(function () {
    define('app', ['marionette'], function (Marionette) {
        return new Marionette.Application();
    });
    requirejs([
        'jquery',
        'lodash',
        'app',
        './router',
        'views/layout_view',
        'models/note_model',
        'services/dropbox_service'
    ], function ($, _, app, Router, LayoutView, NoteModel, DropboxService) {
        window.app = app;
        app.addInitializer(function () {
            app.dropboxService = new DropboxService();
            return app.router = new Router();
        });
        app.addInitializer(function () {
            return app.options = {
                panelCount: 5,
                colors: [
                    '#D1F2A5',
                    '#EFFAB4',
                    '#FFC48C',
                    '#FF9F80',
                    '#F56991'
                ]
            };
        });
        app.addInitializer(function () {
            app.models = _.times(app.options.panelCount, function (i) {
                var model;
                model = new NoteModel({ id: i });
                return model;
            });
            return app['export'] = function () {
                var a, blob, url;
                blob = new Blob([JSON.stringify(app.models.map(function (a) {
                        return a.toJSON();
                    }))], { type: 'application/octet-stream' });
                url = URL.createObjectURL(blob);
                a = $('<a>', {
                    href: url,
                    download: 'scratchpad-export.json'
                });
                a.appendTo(document.body);
                _.defer(function () {
                    return a.trigger('click');
                });
            };
        });
        app.on('start', function () {
            app.view = new LayoutView();
            $('#main').append(app.view.render().el);
            app.view.trigger('pageshow');
            Backbone.history.start();
            return window.require = window.nodereq;
        });
        return $(function () {
            return app.start();
        });
    });
}.call(this));
define('index', [
    'jquery',
    'lodash',
    'app',
    'router',
    'views/layout_view',
    'models/note_model',
    'services/dropbox_service'
], function () {
    return;
});